
//
//  Copyright (c) 2021 NXP Semiconductors N.V.
//

//
//======================================================================================
//======================================================================================
//                    In-Code Statement
//
//  Software is distributed as is, completely without warranty or service support.
//  NXP Semiconductors, along with its employees are not liable for the condition
//  or performance of the software.
//
//  NXP Semiconductors owns the copyright and grants users a perpetual, irrevocable,
//  worldwide, non-exclusive, royalty-free license with respect to the software as
//  set forth below.
//
//  NXP Semiconductors hereby disclaims all implied warranties.
//
//  NXP Semiconductors grants the users the right to modify, copy, and redistribute
//  the software and documentation, both within the user's organization and externally,
//  subject to the following restrictions:
//
//    1. The users agree not to charge for the NXP Semiconductors developed code
//       but may charge for additions, extensions, or support.
//
//    2. In any product based on the software, the users agree to acknowledge that
//       NXP Semiconductors developed the software. This acknowledgment shall appear
//       in the product documentation.
//
//    3. Redistributions to others of source code and documentation must retain the
//       copyright notice, disclaimer, and list of conditions.
//
//    4. Redistributions to others in binary form must reproduce the copyright notice,
//       disclaimer, and list of conditions in the documentation and/or other materials
//       provided with the distribution.
//
//  In-Code Statement Revision: 1.0.6 (PSPHV), November 18, 2021
//
//======================================================================================
//======================================================================================
//

//
//  psphv.va: Verilog-A definition of the PSPHV model for power MOS transistors
//
//  Version: 1.0.6
//  Date:    November 18, 2021
//  Author:  Colin McAndrew, Kejun Xia, plus PSP developers
//

//
//  PSPHV is a model for LDMOS and power MOS transistors. It combines PSP
//  for the core MOS transistor portion of the device and JFETIDG for the
//  drain drift region of the device. The partitioning of charge for the
//  drain overlap region is adapted from SP-HV, all other features are
//  as-implemented in PSP and JFETIDG.
//

`define VERSION     1
`define SUBVERSION  0
`define REVISION    5

//`define diodeReverseRecovery // comment this line out to exclude diode reverse recovery modeling
`define QSCALE 1.0e-06       // so convergence criteria is correct for Qdiff reverse recovery time modeling

`include "simulatorFlags.va" // set the flags in that file based on what simulator you use

`include "disciplines.vams"
`include "constants.vams"
`ifdef P_Q_NIST2010
`else
`define P_Q_NIST2010       1.602176565e-19
`define P_K_NIST2010       1.3806488e-23
`endif
`ifdef P_Q_OLD
`else
`define P_Q_OLD 1.6021918e-19
`endif
`include "general_v1_0_4.va"
`include "PSP103_macrodefs.include"
`define EPS_Sij 1.04479416276e-10  // JUNCAP2 value
`define LEN                1.0e-6  // reference of 1 um for length scaling
`define WEN                1.0e-6  // reference of 1 um for width scaling

//
//  Start of psphv model code
//

`ifdef diodeReverseRecovery
module psphvrr(d, g, s, b, dt);
`else
module psphv(d, g, s, b, dt);
`endif

//
//  the files included below contain analog functions so must be in module scope
//

`include "sp_functions.va"
`include "junction_v1_0_2.va"
`include "jfetidgIds_v1_0_1.va"

//
//  Node definitions
//

inout      d, g, s, b, dt;
electrical d, g, s, b;
thermal    dt;
electrical di, gi, bi, js, jd, jx; // internal nodes
`ifdef diodeReverseRecovery
electrical qrrs, qrrd, qrrx;
branch    (qrrs) b_qrrs;
branch    (qrrd) b_qrrd;
branch    (qrrx) b_qrrx;
`endif

//
//  Branch definitions
//

branch (d , di)   b_rd;    // drift  region
branch (g , gi)   b_rg;    // gate   resistance
branch (b , bi)   b_rb;    // bulk   resistance
branch (b , js)   b_rjs;   // juns   resistance
branch (b , jd)   b_rjd;   // jund   resistance
branch (b , jx)   b_rjx;   // junx   resistance
branch (gi, di)   b_gdi;   // gate-drain   of intrinsic transistor
branch (gi, s )   b_gsi;   // gate-source  of intrinsic transistor
branch (gi, bi)   b_gbi;   // gate-bulk    of intrinsic transistor
branch (di, s )   b_dsi;   // drain-source of intrinsic transistor
branch (d , s )   b_ds;    // drain-source of complete transistor
branch (s , bi)   b_sbi;   // source-bulk  of intrinsic transistor
branch (di, bi)   b_dbi;   // drain-bulk   of intrinsic transistor
branch (js, s )   b_bsd;   // bulk-source          diode
branch (jd, di)   b_bdd;   // bulk-drain           diode
branch (jx, d )   b_bxd;   // bulk-extrinsic drain diode
branch (dt    )   b_rth;   // local thermal branch
branch (b , di)   b_gbs;   // botGate-source  of drift region
branch (b , d )   b_gbd;   // botGate-drain   of drift region
branch (gi, di)   b_gts;   // topGate-source  of drift region
branch (gi, d )   b_gtd;   // topGate-drain   of drift region
branch (gi, b )   b_gtb;   // topGate-botGate of drift region

//
//  Instance parameters
//

`IPRco( w         ,   1.0e-05 ,"m"               ,1.0e-9,   inf, "design width  of channel")
`IPRco( l         ,   1.0e-05 ,"m"               ,1.0e-9,   inf, "design length of channel")
`IPRco( lgdov     ,   1.0e-06 ,"m"               ,   0.0,   inf, "design length of gate-drain thinox overlap region")
`IPRco( lgdov2    ,   0.0     ,"m"               ,   0.0,   inf, "design length of second gate-drain overlap region")
`IPRco( wdrift    ,   w       ,"m"               ,1.0e-9,   inf, "design width  of drift region")
`IPRco( ldrift    ,   1.0e-06 ,"m"               ,1.0e-9,   inf, "design length of drift region (thinox to drain contact region)")
`IPIco( ncs       ,   1       ,""                ,   0  ,   inf, "# contacts at source end")
`IPIco( ncd       ,   1       ,""                ,   0  ,   inf, "# contacts at drain  end")
`IPRco( jw        ,   w       ,"m"               ,   0.0,   inf, "gate edge length of source and drain junctions (local model)")
`IPRco( as        ,   0.0     ,"m^2"             ,   0.0,   inf, "area          of source junction")
`IPRco( ps        ,   0.0     ,"m"               ,   0.0,   inf, "perimeter     of source junction")
`IPRco( ad        ,   0.0     ,"m^2"             ,   0.0,   inf, "area          of drain junction")
`IPRco( pd        ,   0.0     ,"m"               ,   0.0,   inf, "perimeter     of drain junction")
`IPRco( adx       ,   0.0     ,"m^2"             ,   0.0,   inf, "area          of extrinsic drain junction")
`IPRco( pdx       ,   0.0     ,"m"               ,   0.0,   inf, "perimeter     of extrinsic drain junction")
`IPRco( sa        ,   0.0     ,"m"               ,   0.0,   inf, "distance between OD-edge and poly from one side")
`IPRco( sb        ,   0.0     ,"m"               ,   0.0,   inf, "distance between OD-edge and poly from other side")
`IPRco( sd        ,   0.0     ,"m"               ,   0.0,   inf, "distance between neighbouring fingers")
`IPRco( sca       ,   0.0     ,""                ,   0.0,   inf, "integral of the first  distribution function for scattered well dopants")
`IPRco( scb       ,   0.0     ,""                ,   0.0,   inf, "integral of the second distribution function for scattered well dopants")
`IPRco( scc       ,   0.0     ,""                ,   0.0,   inf, "integral of the third  distribution function for scattered well dopants")
`IPRco( sc        ,   0.0     ,"m"               ,   0.0,   inf, "distance between OD-edge and nearest well edge")
`IPIco( nf        ,   1       ,""                ,   1  ,   inf, "number of fingers")
`IPIcc( ngcon     ,   1       ,""                ,   1  ,   2  , "number of gate contacts")
`IPRco( xgw       ,   1.0e-07 ,"m"               ,   0.0,   inf, "distance from the gate contact to the channel edge")
`IPRoo( dta       ,   0.0     ,"degC"            ,  -inf,   inf, "local temperature delta to ambient (before self-heating)")
`IPRoo( delvto    ,   0.0     ,"V"               ,  -inf,   inf, "threshold voltage shift (main transistor)")
`IPRoo( delvtoedge,   0.0     ,"V"               ,  -inf,   inf, "threshold voltage shift (edge transistor)")
`IPRoo( factuo    ,   1.0     ,""                ,   0.0,   inf, "mobility scale          (main transistor)")
`IPRoo( factuoedge,   1.0     ,""                ,   0.0,   inf, "mobility scale          (edge transistor)")
`IPIco( mult      ,   1       ,""                ,   1  ,   inf, "number of devices in parallel")

//
//  Parameters that can be instance and/or model (the former overrides the latter)
//

`IPIsw( swnoise   ,   1       ,""                              , "switch to include noise:            0=no and 1=yes")
`IPIsw( swet      ,   1       ,""                              , "switch to include self-heating:     0=no and 1=yes")
`IPIsw( swdrlin   ,   0       ,""                              , "switch to make drift region linear: 0=no and 1=yes")

//
//  Special model parameters, some may be simulator global parameters
//

`MPIco( version   ,   `VERSION,""                ,   1  ,   inf, "model version")
`MPIco( subversion,`SUBVERSION,""                ,   0  ,   inf, "model subversion")
`MPIco( revision  ,  `REVISION,""                ,   0  ,   inf, "model revision")
`MPRcc( tmin      ,-100.0     ,"degC"            ,-250.0,  27.0, "minimum ambient temperature")
`MPRcc( tmax      , 500.0     ,"degC"            ,  27.0,1000.0, "maximum ambient temperature")
//`MPRco( gmin      ,`SIMPARGMIN,"S"               ,   0.0,   inf, "minimum parasitic conductance")
`MPRco( gmin      ,`GMIN,      "S"               ,   0.0,   inf, "minimum parasitic conductance")
`MPRco( imax      ,`SIMPARIMAX,"A"               ,1.0e-6,   inf, "current at which to linearize diode currents")
`MPRoc( scale     ,`SIMPARSCAL,""                ,   0.0,   1.0, "scale  factor for instance geometries")
`MPRco( shrink    ,`SIMPARSHRI,"%"               ,   0.0, 100.0, "shrink percentage for instance geometries")
`MPRoo( rthresh   ,`SIMPARRTHR,"Ohm"             ,   0.0,   inf, "threshold to switch end resistance to V=I*R form")

//
//  General model parameters
//

`MPIty( type      ,   1       ,""                              , "channel type                        : +1/-1 for NMOS/PMOS")
`MPIsw( swgeo     ,   1       ,""                              , "switch for geometry modeling        :  0/ 1 for local/global")
`MPIsw( swigate   ,   0       ,""                              , "switch for gate current             :  0/ 1 for off/on")
`MPIsw( swimpact  ,   0       ,""                              , "switch for impact ionization current:  0/ 1 for off/on")
`MPIsw( swgidl    ,   0       ,""                              , "switch for GIDL current             :  0/ 1 for off/on")
`MPIsw( swjunc    ,   1       ,""                              , "switch for junction modeling        :  0/ 1 for off/on")
`MPIsw( swjunasym ,   1       ,""                              , "switch for asymmetric junctions     :  0/ 1 for symmetric/asymmetric")
`MPIcc( swnud     ,   0       ,""                ,   0  ,   2  , "switch for NUD-effect               :  0/ 1/ 2 for none/DC/DC+CV")
`MPIsw( swedge    ,   0       ,""                              , "switch for edge transistors         :  0/ 1 for off/on")
`MPIsw( swdelvtac ,   0       ,""                              , "switch for separate CV psi_s calc   :  0/ 1 for off/on")
`MPIsw( swvdimp   ,   0       ,""                              , "switch for Vds for impact ionization:  0/ 1 for intrinsic/extrinsic")
`MPIsw( swvdiclmp ,   0       ,""                              , "switch for Vdi clamping             :  0/ 1 for off/on")
`MPIsw( swptest   ,   0       ,""                              , "switch to  force PMOS=NMOS for QA   :  0/ 1 for off/on")
`MPRcz( qmc       ,   1.0     ,""                              , "Quantum-mechanical correction factor")
`MPIsw( swbgmos   ,   0       ,""                              , "switch for drift region bottom gate :  0/ 1 for=pn-junction/mos")
`MPIsw( swtgmos   ,   1       ,""                              , "switch for drift region bottom gate :  0/ 1 for=pn-junction/mos")
`MPRcc( tr        ,  21.0     ,"degC"            ,-250.0,1000.0, "reference temperature")
`MPRcc( trj       ,  21.0     ,"degC"            ,-250.0,1000.0, "reference temperature for junctions")
`MPRcc( tminclip  ,-100.0     ,"degC"            ,-250.0,  27.0, "clip minimum temperature")
`MPRcc( tmaxclip  , 800.0     ,"degC"            ,  27.0,1000.0, "clip maximum temperature")
`MPRoc( grpo      ,   1.0e-12 ,""                ,   0.0,   0.1, "minimum body conductance in pinch-off (ratio w.r.t. Vc=0)")

//
//  Parameters for improvements added on top of underlying PSP and JFETIDG models
//

`MPRco( vdscale   ,   0.0     ,""                ,   0.0,   inf, "Vds scale factor for nonuniform lateral doping")
`MPRoo( vdscaleo  ,   0.0     ,""                ,  -inf,   inf, "vdscale geometry independent part")
`MPRoo( vdscalel  ,   0.0     ,""                ,  -inf,   inf, "vdscale 1/l     coefficient")
`MPRco( vdscalele ,   1.0     ,""                ,   0.0,   inf, "vdscale 1/l     exponent")
`MPRoo( vdscalew  ,   0.0     ,""                ,  -inf,   inf, "vdscale 1/l     coefficient")
`MPRoo( vdscalelw ,   0.0     ,""                ,  -inf,   inf, "vdscale 1/(l*w) coefficient")
`MPRoo( vdscaleb  ,   0.0     ,"/V"              ,  -inf,   inf,  "body bias dependence of vdscale")
`MPRoo( vdscalebo ,   0.0     ,"/V"              ,  -inf,   inf, "vdscaleb geometry independent part")
`MPRoo( vdscalebl ,   0.0     ,""                ,  -inf,   inf, "vdscaleb 1/l     coefficient")
`MPRco( vdscaleble,   1.0     ,""                ,   0.0,   inf, "vdscaleb 1/l     exponent")
`MPRoo( vdscalebw ,   0.0     ,""                ,  -inf,   inf, "vdscaleb 1/l     coefficient")
`MPRoo( vdscaleblw,   0.0     ,""                ,  -inf,   inf, "vdscaleb 1/(l*w) coefficient")
`MPRoo( stvdscale ,   0.0     ,""                ,  -inf,   inf, "vdscale temperature exponent")
`MPRoo( stvdscaleo,   0.0     ,""                ,  -inf,   inf, "stvdscale geometry independent part")
`MPRoo( stvdscalel,   0.0     ,""                ,  -inf,   inf, "stvdscale 1/l     coefficient")
`MPRco( stvdscalele,  1.0     ,""                ,   0.0,   inf, "stvdscale 1/l     exponent")
`MPRoo( stvdscalew,   0.0     ,""                ,  -inf,   inf, "stvdscale 1/l     coefficient")
`MPRoo( stvdscalelw,  0.0     ,""                ,  -inf,   inf, "stvdscale 1/(l*w) coefficient")
`MPRco( vdimin    ,   0.5     ,"V"               ,   0.0,   inf, "minimum clamping value for Vdi")
`MPRoo( vdi0      ,1000.0     ,"V"               ,  -inf,   inf, "clamped Vdi value at Vds=0")
`MPRoo( vdi0o     ,1000.0     ,"V"               ,  -inf,   inf, "vdio geometry independent part")
`MPRoo( vdi0l     ,   0.0     ,""                ,  -inf,   inf, "vdio 1/l     coefficient")
`MPRco( vdi0le    ,   1.0     ,""                ,   0.0,   inf, "vdio 1/w     exponent")
`MPRoo( vdi0w     ,   0.0     ,""                ,  -inf,   inf, "vdio 1/w     coefficient")
`MPRoo( vdi0lw    ,   0.0     ,""                ,  -inf,   inf, "vdio 1/(l*w) coefficient")
`MPRoo( vdislope  ,   0.04    ,""                ,  -inf,   inf, "slope of clamped Vdi w.r.t. Vds")
`MPRoo( vdislopeo ,   0.04    ,""                ,  -inf,   inf, "vdislope geometry independent part")
`MPRoo( vdislopel ,   0.0     ,""                ,  -inf,   inf, "vdislope 1/l     coefficient")
`MPRco( vdislopele,   1.0     ,""                ,   0.0,   inf, "vdislope 1/l     exponent")
`MPRoo( vdislopew ,   0.0     ,""                ,  -inf,   inf, "vdislope 1/l     coefficient")
`MPRoo( vdislopelw,   0.0     ,""                ,  -inf,   inf, "vdislope 1/(l*w) coefficient")
`MPRoo( vdislopg  ,   0.0     ,""                ,  -inf,   inf, "slope of clamped Vdi w.r.t. Vgs")
`MPRoo( vdislopgo ,   0.0     ,""                ,  -inf,   inf, "vdislope geometry independent part")
`MPRoo( vdislopgl ,   0.0     ,""                ,  -inf,   inf, "vdislope 1/l     coefficient")
`MPRco( vdislopgle,   1.0     ,""                ,   0.0,   inf, "vdislope 1/l     exponent")
`MPRoo( vdislopgw ,   0.0     ,""                ,  -inf,   inf, "vdislope 1/l     coefficient")
`MPRoo( vdislopglw,   0.0     ,""                ,  -inf,   inf, "vdislope 1/(l*w) coefficient")
`MPRco( vdismooth ,   0.1     ,""                , 0.001,   inf, "smoothing factor for Vdi clamping")
`MPRco( jhc       ,   0.0     ,"A/m"             ,   0.0,   inf, "threshold current for drift region impact ionization Kirk effect")
`MPRco( mhc       ,   0.5     ,""                ,   0.0,   inf, "power of drain drift junction")
`MPRoo( a3cvd     ,   0.0     ,"/V"              ,  -inf,   inf, "Vd coefficient of Vd dependence of A3")
`MPRoo( a3cvdo    ,   0.0     ,"/V"              ,  -inf,   inf, "Vd coeff of Vd dependence of A3")
`MPRoo( a3cvdl    ,   0.0     ,""                ,  -inf,   inf, "Vd coeff of Vd dependence of A3")
`MPRoo( a3cvdle   ,   1.0     ,""                ,   0.0,   inf, "Vd coeff of Vd dependence of A3")
`MPRoo( a3cvdw    ,   0.0     ,""                ,  -inf,   inf, "Vd coeff of Vd dependence of A3")
`MPRoo( a3cvdlw   ,   0.0     ,""                ,  -inf,   inf, "Vd coeff of Vd dependence of A3")
`MPRoo( sta3cvd   ,   0.0     ,""                ,  -inf,   inf, "a3cvd temperature exponent")
`MPRoo( sta3cvdo  ,   0.0     ,""                ,  -inf,   inf, "sta3cvd geometry independent part")
`MPRoo( sta3cvdl  ,   0.0     ,""                ,  -inf,   inf, "sta3cvd 1/l     coefficient")
`MPRco( sta3cvdle ,   1.0     ,""                ,   0.0,   inf, "sta3cvd 1/l     exponent")
`MPRoo( sta3cvdw  ,   0.0     ,""                ,  -inf,   inf, "sta3cvd 1/l     coefficient")
`MPRoo( sta3cvdlw ,   0.0     ,""                ,  -inf,   inf, "sta3cvd 1/(l*w) coefficient")
`MPRoo( a3mvd     ,   1.0     ,""                ,   0.0,   inf, "power of Vd dependence of A3")

//
//  PSP local model parameters
//

`MPRnb(vfb            ,-1.0       ,"V"                                  ,"Flat band voltage at tr")
`MPRnb(stvfb          ,5.0e-4     ,"V/K"                                ,"Temperature dependence of vfb")
`MPRnb(st2vfb         ,0.0        ,"K^-1"                               ,"Quadratic temperature dependence of vfb")
`MPRco(tox            ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Gate oxide thickness")
`MPRco(epsrox         ,3.9        ,""         ,1.0         ,inf         ,"Relative permittivity of gate dielectric")
`MPRcc(neff           ,5.0e23     ,"m^-3"     ,1.0e20      ,1.0e26      ,"Effective substrate doping")
`MPRcz(facneffac      ,1.0        ,""                                   ,"Pre-factor for effective substrate doping in separate charge calculation")
`MPRco(gfacnud        ,1.0        ,""         ,0.01        ,inf         ,"Body-factor change due to NUD-effect")
`MPRcz(vsbnud         ,0.0        ,"V"                                  ,"Lower Vsb value for NUD-effect")
`MPRco(dvsbnud        ,1.0        ,"V"        ,0.1         ,inf         ,"Vsb-range for NUD-effect")
`MPRnb(vnsub          ,0.0        ,"V"                                  ,"Effective doping bias-dependence parameter")
`MPRco(nslp           ,0.05       ,"V"        ,1.0e-3      ,inf         ,"Effective doping bias-dependence parameter")
`MPRcc(dnsub          ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Effective doping bias-dependence parameter")
`MPRnb(dphib          ,0.0        ,"V"                                  ,"Offset parameter for PHIB")
`MPRnb(delvtac        ,0.0        ,"V"                                  ,"Offset parameter for PHIB in separate charge calculation")
`MPRcz(np             ,1.0e26     ,"m^-3"                               ,"Gate poly-silicon doping")
`MPRco(toxov          ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness")
`MPRco(toxovd         ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness for drain side")
`MPRco(toxovd2        ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"oxide thickness for second gate-drain overlap")
`MPRcc(nov            ,5.0e25     ,"m^-3"     ,1.0e20      ,1.0e27      ,"Effective doping of overlap region")
`MPRcc(novd           ,5.0e25     ,"m^-3"     ,1.0e20      ,1.0e27      ,"Effective doping of overlap region for drain side")
`MPRcc(novd2          ,5.0e25     ,"m^-3"     ,1.0e20      ,1.0e27      ,"Effective doping of second overlap region for drain side")
`MPRnb(vfbov          , 0.0       ,"V"                                  ,"Flat band voltage for overlap region for source side")
`MPRnb(vfbovd         , 0.0       ,"V"                                  ,"Flat band voltage for overlap region for drain side")
`MPRnb(vfbovd2        , 0.0       ,"V"                                  ,"Flat band voltage for second overlap region for drain side")

//  Interface states parameters: PSP 103.6

`MPRcz(ct             ,0.0        ,""                                   ,"Interface states factor")
`MPRcz(ctg            ,0.0        ,""                                   ,"Gate voltage dependence of interface states factor")
`MPRnb(ctb            ,0.0        ,""                                   ,"Bulk voltage dependence of interface states factor")
`MPRnb(stct           ,1.0        ,""                                   ,"Geometry-independent temperature dependence of ct")

//  DIBL parameters

`MPRcz(cf             ,0.0        ,""                                   ,"DIBL-parameter")
`MPRcz(cfd            ,0.0        ,"V^-1"                               ,"Drain voltage dependence of cf")
`MPRcc(cfb            ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Back bias dependence of cf")

//  Subthreshold slope parameters of short channel transistor

`MPRcz(psce           ,0.0        ,""                                   ,"Subthreshold slope coefficient for short channel transistor")
`MPRcc(psceb          ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel transistor")
`MPRcz(psced          ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel transistor")

//  Mobility parameters

`MPRcz(betn           ,7.0e-2     ,"m^2/V/s"                            ,"Channel aspect ratio times zero-field mobility")
`MPRnb(stbet          ,1.0        ,""                                   ,"Temperature dependence of betn")
`MPRcz(mue            ,0.5        ,"m/V"                                ,"Mobility reduction coefficient at tr")
`MPRnb(stmue          ,0.0        ,""                                   ,"Temperature dependence of mue")
`MPRcz(themu          ,1.5        ,""                                   ,"Mobility reduction exponent at tr")
`MPRnb(stthemu        ,1.5        ,""                                   ,"Temperature dependence of themu")
`MPRcz(cs             ,0.0        ,""                                   ,"Coulomb scattering parameter at tr")
`MPRnb(stcs           ,0.0        ,""                                   ,"Temperature dependence of cs")
`MPRcz(thecs          ,2.0        ,""                                   ,"Coulomb scattering exponent at tr")
`MPRnb(stthecs        ,0.0        ,""                                   ,"Temperature dependence of thecs")
`MPRcz(xcor           ,0.0        ,"V^-1"                               ,"Non-universality factor")
`MPRnb(stxcor         ,0.0        ,""                                   ,"Temperature dependence of xcor")
`MPRcz(feta           ,1.0        ,""                                   ,"Effective field parameter")

//  Series-resistance parameters (for resistance modeling as part of intrinsic mobility reduction)

`MPRcz(rs             ,30.0       ,"Ohm"                                ,"Series resistance at tr")
`MPRnb(strs           ,0.0        ,""                                   ,"Temperature dependence of rs")
`MPRcc(rsb            ,0.0        ,"V^-1"     ,-0.5        ,1.0         ,"Back-bias dependence of series resistance")
`MPRco(rsg            ,0.0        ,"V^-1"     ,-0.5        ,inf         ,"Gate-bias dependence of series resistance")

//  Velocity saturation parameters

`MPRcz(thesat         ,1.0        ,"V^-1"                               ,"Velocity saturation parameter at tr")
`MPRnb(stthesat       ,1.0        ,""                                   ,"Temperature dependence of thesat")
`MPRcc(thesatb        ,0.0        ,"V^-1"     ,-0.5        ,1.0         ,"Back-bias dependence of velocity saturation")
`MPRco(thesatg        ,0.0        ,"V^-1"     ,-0.5        ,inf         ,"Gate-bias dependence of velocity saturation")

//  Saturation voltage parameters

`MPRco(ar             ,0.01       ,""         ,0.0         ,inf         ,"Linear/saturation transition factor")

//  Channel length modulation (CLM) parameters

`MPRcz(alp            ,0.01       ,""                                   ,"CLM pre-factor")
`MPRcz(alp1           ,0.0        ,"V"                                  ,"CLM enhancement factor above threshold")
`MPRcz(alp2           ,0.0        ,"V^-1"                               ,"CLM enhancement factor below threshold")
`MPRco(vp             ,0.05       ,"V"        ,1.0e-10     ,inf         ,"CLM logarithm dependence factor")

//  Impact ionization (II) parameters

`MPRcz(a1             ,1.0        ,""                                   ,"Impact-ionization pre-factor")
`MPRcz(a2             ,10.0       ,"V"                                  ,"Impact-ionization exponent at tr")
`MPRnb(sta2           ,0.0        ,"V"                                  ,"Temperature dependence of a2")
`MPRcz(a3             ,1.0        ,""                                   ,"Saturation-voltage dependence of impact-ionization")
`MPRcz(a4             ,0.0        ,"V^-0.5"                             ,"Back-bias dependence of impact-ionization")

//  Gate current parameters

`MPRcc(gco            ,0.0        ,""         ,-10.0       ,10.0        ,"Gate tunnelling energy adjustment")
`MPRcz(iginv          ,0.0        ,"A"                                  ,"Gate channel current pre-factor")
`MPRcz(igov           ,0.0        ,"A"                                  ,"Gate overlap current pre-factor")
`MPRcz(igovd          ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for drain side")
`MPRnb(stig           ,2.0        ,""                                   ,"Temperature dependence of iginv and igov")
`MPRcc(gc2            ,0.375      ,""         ,0.0         ,10.0        ,"Gate current slope factor")
`MPRcc(gc3            ,0.063      ,""         ,-2.0        ,2.0         ,"Gate current curvature factor")
`MPRco(chib           ,3.1        ,"V"        ,1.0         ,inf         ,"Tunnelling barrier height")

//  Gate Induced Drain/Source Leakage (GIDL) parameters

`MPRcz(agidl          ,0.0        ,"A/V^3"                              ,"GIDL pre-factor")
`MPRcz(agidld         ,0.0        ,"A/V^3"                              ,"GIDL pre-factor for drain side")
`MPRcz(bgidl          ,41.0       ,"V"                                  ,"GIDL probability factor at tr")
`MPRcz(bgidld         ,41.0       ,"V"                                  ,"GIDL probability factor at tr for drain side")
`MPRnb(stbgidl        ,0.0        ,"V/K"                                ,"Temperature dependence of bgidl")
`MPRnb(stbgidld       ,0.0        ,"V/K"                                ,"Temperature dependence of bgidl for drain side")
`MPRnb(cgidl          ,0.0        ,""                                   ,"Back-bias dependence of GIDL")
`MPRnb(cgidld         ,0.0        ,""                                   ,"Back-bias dependence of GIDL for drain side")

//  Charge model parameters

`MPRcz(cox            ,1.0e-14    ,"F"                                  ,"Oxide capacitance for intrinsic channel")
`MPRcz(cgov           ,1.0e-15    ,"F"                                  ,"Oxide capacitance for gate-drain/source overlap")
`MPRcz(cgovd          ,1.0e-15    ,"F"                                  ,"Oxide capacitance for gate-drain overlap")
`MPRcz(cgovd2         ,0.0        ,"F"                                  ,"Oxide capacitance for second gate-drain overlap")
`MPRcz(cgbov          ,0.0        ,"F"                                  ,"Oxide capacitance for gate-bulk overlap")
`MPRcz(cfr            ,0.0        ,"F"                                  ,"Outer fringe capacitance")
`MPRcz(cfrd           ,0.0        ,"F"                                  ,"Outer fringe capacitance for drain side")

//  Noise parameters

`MPRcz(fnt            ,1.0        ,""                                   ,"Thermal noise coefficient")
`MPRcz(fntexc         ,0.0        ,""                                   ,"Excess noise coefficient")
`MPRcz(nfa            ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise")
`MPRcz(nfb            ,3.0e07     ,"V^-1/m^2"                           ,"Second coefficient of flicker noise")
`MPRcz(nfc            ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise")
`MPRcz(ef             ,1.0        ,""                                   ,"Flicker noise frequency exponent")

// Edge transistor parameters: PSP 103.4

`MPRnb(vfbedge        ,-1.0       ,"V"                                  ,"Flat band voltage of edge transistors at tr")
`MPRnb(stvfbedge      ,5.0e-4     ,"V/K"                                ,"Temperature dependence of vfbedge")
`MPRnb(dphibedge      ,0.0        ,"V"                                  ,"Offset parameter for PHIB of edge transistors")
`MPRcc(neffedge       ,5.0e23     ,"m^-3"     ,1.0e20      ,1.0e26      ,"Effective substrate doping of edge transistors")
`MPRcz(ctedge         ,0.0        ,""                                   ,"Interface states factor of edge transistors")
`MPRcz(betnedge       ,5.0e-4     ,"m^2/V/s"                            ,"Channel aspect ratio times zero-field mobility of edge transistor")
`MPRnb(stbetedge      ,1.0        ,""                                   ,"Temperature dependence of betnedge")
`MPRcz(psceedge       ,0.0        ,""                                   ,"Subthreshold slope coefficient for short channel edge transistors")
`MPRcc(pscebedge      ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
`MPRcz(pscededge      ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
`MPRcz(cfedge         ,0.0        ,""                                   ,"DIBL parameter of edge transistors")
`MPRcz(cfdedge        ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of DIBL-parameter of edge transistors")
`MPRcc(cfbedge        ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of DIBL-parameter of edge transistors")
`MPRcz(fntedge        ,1.0        ,""                                   ,"Thermal noise coefficient of edge transistors")
`MPRcz(nfaedge        ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise of edge transistors")
`MPRcz(nfbedge        ,3.0e07     ,"V^-1/m^2"                           ,"Second coefficient of flicker noise of edge transistors")
`MPRcz(nfcedge        ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise of edge transistors")
`MPRcz(efedge         ,1.0        ,""                                   ,"Flicker noise frequency exponent of edge transistors")

// Parasitic resistance parameters

`MPRcz(rge            ,0.0        ,"Ohm"                                ,"Gate resistance")
`MPRcz(rjuns          ,0.0        ,"Ohm"                                ,"source diode series resistance")
`MPRcz(rjund          ,0.0        ,"Ohm"                                ,"intrinsic drain diode series resistance")
`MPRcz(rjunx          ,0.0        ,"Ohm"                                ,"extrinsic drain diode series resistance")
`MPRcz(rbulk          ,0.0        ,"Ohm"                                ,"bulk series resistance")
`MPRnb(strjuns        ,0.0        ,""                                   ,"temperature dependence of rjuns")
`MPRnb(strjund        ,0.0        ,""                                   ,"temperature dependence of rjund")
`MPRnb(strjunx        ,0.0        ,""                                   ,"temperature dependence of rjunx")
`MPRnb(strbulk        ,0.0        ,""                                   ,"temperature dependence of rbulk")
`ALIAS(strjunso,strjuns)
`ALIAS(strjundo,strjund)
`ALIAS(strjunxo,strjunx)
`ALIAS(strbulko,strbulk)

//
//  PSP global model parameters
//

`MPRnb(lvaro          ,0.0        ,"m"                                  ,"Geom. independent difference between actual and programmed gate length")
`MPRnb(lvarl          ,0.0        ,""                                   ,"Length dependence of LVAR")
`MPRnb(lvarw          ,0.0        ,""                                   ,"Width dependence of LVAR")
`MPRnb(lap            ,0.0        ,"m"                                  ,"Effective channel length reduction per side")
`MPRnb(wvaro          ,0.0        ,"m"                                  ,"Geom. independent difference between actual and programmed field-oxide opening")
`MPRnb(wvarl          ,0.0        ,""                                   ,"Length dependence of WVAR")
`MPRnb(wvarw          ,0.0        ,""                                   ,"Width dependence of WVAR")
`MPRnb(wot            ,0.0        ,"m"                                  ,"Effective channel width reduction per side")
`MPRnb(dlq            ,0.0        ,"m"                                  ,"Effective channel length reduction for CV")
`MPRnb(dwq            ,0.0        ,"m"                                  ,"Effective channel width reduction for CV")
`MPRnb(vfbo           ,-1.0       ,"V"                                  ,"Geometry-independent flat-band voltage at tr")
`MPRnb(vfbl           ,0.0        ,"V"                                  ,"Length dependence of flat-band voltage")
`MPRnb(vfbw           ,0.0        ,"V"                                  ,"Width dependence of flat-band voltage")
`MPRnb(vfblw          ,0.0        ,"V"                                  ,"Area dependence of flat-band voltage")
`MPRnb(stvfbo         ,5.0e-4     ,"V/K"                                ,"Geometry-independent temperature dependence of vfb")
`MPRnb(stvfbl         ,0.0        ,"V/K"                                ,"Length dependence of temperature dependence of vfb")
`MPRnb(stvfbw         ,0.0        ,"V/K"                                ,"Width dependence of temperature dependence of vfb")
`MPRnb(stvfblw        ,0.0        ,"V/K"                                ,"Area dependence of temperature dependence of vfb")
`MPRnb(st2vfbo        ,0.0        ,"K^-1"                               ,"Quadratic temperature dependence of vfb")
`MPRco(toxo           ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Gate oxide thickness")
`MPRco(epsroxo        ,3.9        ,""         ,1.0         ,inf         ,"Relative permittivity of gate dielectric")
`MPRco(nsubo          ,3.0e23     ,"m^-3"     ,1.0e20      ,inf         ,"Geometry independent substrate doping")
`MPRnb(nsubw          ,0.0        ,""                                   ,"Width dependence of background doping nsubo due to segregation")
`MPRco(wseg           ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of segregation of background doping nsubo")
`MPIcc(xpck           ,1          ,""         ,0           ,2           ,"# ends with pocket doping")
`MPRcz(npck           ,0.0        ,"m^-3"                               ,"Pocket doping level")
`MPRnb(npckw          ,0.0        ,""                                   ,"Width dependence of pocket doping npck due to segregation")
`MPRco(wsegp          ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of segregation of pocket doping npck")
`MPRco(lpck           ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of lateral doping profile")
`MPRnb(lpckw          ,0.0        ,""                                   ,"Width dependence of char. length of lateral doping profile")
`MPRnb(fol1           ,0.0        ,""                                   ,"First length dependence coefficient for short channel body effect")
`MPRnb(fol2           ,0.0        ,""                                   ,"Second length dependence coefficient for short channel body effect")
`MPRnb(facneffaco     ,1.0        ,""                                   ,"Geom. independent pre-factor for effective substrate doping in separate charge calculation")
`MPRnb(facneffacl     ,0.0        ,""                                   ,"Length dependence of facneffac")
`MPRnb(facneffacw     ,0.0        ,""                                   ,"Width dependence of facneffac")
`MPRnb(facneffaclw    ,0.0        ,""                                   ,"Area dependence of facneffac")
`MPRnb(gfacnudo       ,1.0        ,""                                   ,"Geom. independent body-factor change due to NUD-effect")
`MPRnb(gfacnudl       ,0.0        ,""                                   ,"Length dependence of gfacnud")
`MPRnb(gfacnudlexp    ,1.0        ,""                                   ,"Exponent for length dependence of gfacnud")
`MPRnb(gfacnudw       ,0.0        ,""                                   ,"Width dependence of gfacnud")
`MPRnb(gfacnudlw      ,0.0        ,""                                   ,"Area dependence of gfacnud")
`MPRnb(vsbnudo        ,0.0        ,"V"                                  ,"Lower Vsb value for NUD-effect")
`MPRnb(dvsbnudo       ,1.0        ,"V"                                  ,"Vsb range for NUD-effect")
`MPRnb(vnsubo         ,0.0        ,"V"                                  ,"Effective doping bias-dependence parameter")
`MPRnb(nslpo          ,0.05       ,"V"                                  ,"Effective doping bias-dependence parameter")
`MPRnb(dnsubo         ,0.0        ,"V^-1"                               ,"Effective doping bias-dependence parameter")
`MPRnb(dphibo         ,0.0        ,"V"                                  ,"Geometry independent offset of PHIB")
`MPRnb(dphibl         ,0.0        ,"V"                                  ,"Length dependence offset of PHIB")
`MPRnb(dphiblexp      ,1.0        ,""                                   ,"Exponent for length dependence of offset of PHIB")
`MPRnb(dphibw         ,0.0        ,"V"                                  ,"Width dependence of offset of PHIB")
`MPRnb(dphiblw        ,0.0        ,"V"                                  ,"Area dependence of offset of PHIB")
`MPRnb(delvtaco       ,0.0        ,"V"                                  ,"Geom. independent offset parameter for PHIB in separate charge calculation")
`MPRnb(delvtacl       ,0.0        ,"V"                                  ,"Length dependence of delvtac")
`MPRnb(delvtaclexp    ,1.0        ,""                                   ,"Exponent for length dependence of offset of delvtac")
`MPRnb(delvtacw       ,0.0        ,"V"                                  ,"Width dependence of delvtac")
`MPRnb(delvtaclw      ,0.0        ,"V"                                  ,"Area dependence of delvtac")
`MPRnb(npo            ,1.0e26     ,"m^-3"                               ,"Geometry-independent gate poly-silicon doping")
`MPRnb(npl            ,0.0        ,""                                   ,"Length dependence of gate poly-silicon doping")
`MPRco(toxovo         ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness")
`MPRco(toxovdo        ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness for drain side")
`MPRco(toxovd2o       ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"oxide thickness for second gate-drain overlap")
`MPRcz(lov            ,0.0        ,"m"                                  ,"Overlap length for gate/drain and gate/source overlap capacitance")
`MPRnb(novo           ,5e25       ,"m^-3"                               ,"Effective doping of overlap region")
`MPRnb(novdo          ,5e25       ,"m^-3"                               ,"Effective doping of overlap region for drain side")
`MPRnb(novd2o         ,5e25       ,"m^-3"                               ,"Effective doping of second overlap region for drain side")

//  Interface states parameters: PSP 103.6

`MPRnb(cto            ,0.0        ,""                                   ,"Geometry-independent interface states factor")
`MPRnb(ctl            ,0.0        ,""                                   ,"Length dependence of interface states factor")
`MPRnb(ctlexp         ,1.0        ,""                                   ,"Exponent for length dependence of interface states factor")
`MPRnb(ctw            ,0.0        ,""                                   ,"Width dependence of interface states factor")
`MPRnb(ctlw           ,0.0        ,""                                   ,"Area dependence of interface states factor")
`MPRcz(ctgo           ,0.0        ,""                                   ,"Gate voltage dependence of interface states factor")
`MPRnb(ctbo           ,0.0        ,""                                   ,"Bulk voltage dependence of interface states factor")
`MPRnb(stcto          ,1.0        ,""                                   ,"Geometry-independent temperature dependence of ct")

// DIBL Parameters

`MPRnb(cfl            ,0.0        ,""                                   ,"Length dependence of DIBL-parameter")
`MPRnb(cflexp         ,2.0        ,""                                   ,"Exponent for length dependence of cf")
`MPRnb(cfw            ,0.0        ,""                                   ,"Width dependence of cf")
`MPRcz(cfdo           ,0.0        ,"V^-1"                               ,"Drain voltage dependence of cf")
`MPRnb(cfbo           ,0.0        ,"V^-1"                               ,"Back-bias dependence of cf")

//  Subthreshold slope parameters of short channel transistor

`MPRnb(pscel          ,0.0        ,""                                   ,"Length dependence of subthreshold slope coefficient for short channel transistor")
`MPRnb(pscelexp       ,2.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel transistor")
`MPRnb(pscew          ,0.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel transistor")
`MPRcc(pscebo         ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel transistor")
`MPRcz(pscedo         ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel transistor")

// Mobility Parameters

`MPRcz(uo             ,5.0e-2     ,"m^2/V/s"                            ,"Zero-field mobility at tr")
`MPRnb(fbet1          ,0.0        ,""                                   ,"Relative mobility decrease due to first lateral profile")
`MPRnb(fbet1w         ,0.0        ,""                                   ,"Width dependence of relative mobility decrease due to first lateral profile")
`MPRco(lp1            ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Mobility-related characteristic length of first lateral profile")
`MPRnb(lp1w           ,0.0        ,""                                   ,"Width dependence of mobility-related characteristic length of first lateral profile")
`MPRnb(fbet2          ,0.0        ,""                                   ,"Relative mobility decrease due to second lateral profile")
`MPRco(lp2            ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Mobility-related characteristic length of second lateral profile")
`MPRnb(betw1          ,0.0        ,""                                   ,"First higher-order width scaling coefficient of betn")
`MPRnb(betw2          ,0.0        ,""                                   ,"Second higher-order width scaling coefficient of betn")
`MPRco(wbet           ,1.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Characteristic width for width scaling of betn")
`MPRnb(stbeto         ,1.0        ,""                                   ,"Geometry independent temperature dependence of betn")
`MPRnb(stbetl         ,0.0        ,""                                   ,"Length dependence of temperature dependence of betn")
`MPRnb(stbetw         ,0.0        ,""                                   ,"Width dependence of temperature dependence of betn")
`MPRnb(stbetlw        ,0.0        ,""                                   ,"Area dependence of temperature dependence of betn")
`MPRnb(mueo           ,0.5        ,"m/V"                                ,"Geometry independent mobility reduction coefficient at tr")
`MPRnb(muew           ,0.0        ,""                                   ,"Width dependence of mobility reduction coefficient at tr")
`MPRnb(stmueo         ,0.0        ,""                                   ,"Temperature dependence of mue")
`MPRnb(themuo         ,1.5        ,""                                   ,"Mobility reduction exponent at tr")
`MPRnb(stthemuo       ,1.5        ,""                                   ,"Temperature dependence of themu")
`MPRnb(cso            ,0.0        ,""                                   ,"Geometry independent coulomb scattering parameter at tr")
`MPRnb(csl            ,0.0        ,""                                   ,"Length dependence of cs")
`MPRnb(cslexp         ,1.0        ,""                                   ,"Exponent for length dependence of cs")
`MPRnb(csw            ,0.0        ,""                                   ,"Width dependence of cs")
`MPRnb(cslw           ,0.0        ,""                                   ,"Area dependence of cs")
`MPRnb(stcso          ,0.0        ,""                                   ,"Temperature dependence of cs")
`MPRcz(thecso         ,2.0        ,""                                   ,"Coulomb scattering exponent at tr")
`MPRnb(stthecso       ,0.0        ,""                                   ,"Temperature dependence of thecs")
`MPRnb(xcoro          ,0.0        ,"V^-1"                               ,"Geometry independent non-universality parameter")
`MPRnb(xcorl          ,0.0        ,""                                   ,"Length dependence of non-universality parameter")
`MPRnb(xcorw          ,0.0        ,""                                   ,"Width dependence of non-universality parameter")
`MPRnb(xcorlw         ,0.0        ,""                                   ,"Area dependence of non-universality parameter")
`MPRnb(stxcoro        ,0.0        ,""                                   ,"Temperature dependence of xcor")
`MPRnb(fetao          ,1.0        ,""                                   ,"Effective field parameter")

// Series Resistance

`MPRnb(rsw1           ,0.0        ,"Ohm"                                ,"Source/drain series resistance for 1 um wide channel at tr")
`MPRnb(rsw2           ,0.0        ,""                                   ,"Higher-order width scaling of rs")
`MPRnb(strso          ,0.0        ,""                                   ,"Temperature dependence of rs")
`MPRnb(rsbo           ,0.0        ,"V^-1"                               ,"Back-bias dependence of series resistance")
`MPRnb(rsgo           ,0.0        ,"V^-1"                               ,"Gate-bias dependence of series resistance")

// Velocity Saturation

`MPRnb(thesato        ,0.0        ,"V^-1"                               ,"Geometry independent velocity saturation parameter at tr")
`MPRnb(thesatl        ,0.05       ,"V^-1"                               ,"Length dependence of thesat")
`MPRnb(thesatlexp     ,1.0        ,""                                   ,"Exponent for length dependence of thesat")
`MPRnb(thesatw        ,0.0        ,""                                   ,"Width dependence of velocity saturation parameter")
`MPRnb(thesatlw       ,0.0        ,""                                   ,"Area dependence of velocity saturation parameter")
`MPRnb(stthesato      ,1.0        ,""                                   ,"Geometry independent temperature dependence of thesat")
`MPRnb(stthesatl      ,0.0        ,""                                   ,"Length dependence of temperature dependence of thesat")
`MPRnb(stthesatw      ,0.0        ,""                                   ,"Width dependence of temperature dependence of thesat")
`MPRnb(stthesatlw     ,0.0        ,""                                   ,"Area dependence of temperature dependence of thesat")
`MPRnb(thesatbo       ,0.0        ,"V^-1"                               ,"Back-bias dependence of velocity saturation")
`MPRnb(thesatgo       ,0.0        ,"V^-1"                               ,"Gate-bias dependence of velocity saturation")

// Saturation Voltage

`MPRnb(aro            ,0.01       ,""                                   ,"Geometry independent linear/saturation transition factor")
`MPRcz(arl            ,0.1        ,""                                   ,"Length dependence of ar")
`MPRnb(arlexp         ,1.0        ,""                                   ,"Exponent for length dependence of ar")

// Channel Length Modulation

`MPRnb(alpl           ,5.0e-4     ,""                                   ,"Length dependence of alp")
`MPRnb(alplexp        ,1.0        ,""                                   ,"Exponent for length dependence of alp")
`MPRnb(alpw           ,0.0        ,""                                   ,"Width dependence of alp")
`MPRnb(alp1l1         ,0.0        ,"V"                                  ,"Length dependence of CLM enhancement factor above threshold")
`MPRnb(alp1lexp       ,0.5        ,""                                   ,"Exponent for length dependence of alp1")
`MPRcz(alp1l2         ,0.0        ,""                                   ,"Second order length dependence of alp1")
`MPRnb(alp1w          ,0.0        ,""                                   ,"Width dependence of alp1")
`MPRnb(alp2l1         ,0.0        ,"V^-1"                               ,"Length dependence of CLM enhancement factor below threshold")
`MPRnb(alp2lexp       ,0.5        ,""                                   ,"Exponent for length dependence of alp2")
`MPRcz(alp2l2         ,0.0        ,""                                   ,"Second order length dependence of alp2")
`MPRnb(alp2w          ,0.0        ,""                                   ,"Width dependence of alp2")
`MPRnb(vpo            ,0.05       ,"V"                                  ,"CLM logarithmic dependence parameter")

// Weak-avalanche parameters

`MPRnb(a1o            ,1.0        ,""                                   ,"Geometry independent impact-ionization pre-factor")
`MPRnb(a1l            ,0.0        ,""                                   ,"Length dependence of a1")
`MPRnb(a1w            ,0.0        ,""                                   ,"Width dependence of a1")
`MPRnb(a2o            ,10.0       ,"V"                                  ,"Impact-ionization exponent at tr")
`MPRnb(sta2o          ,0.0        ,"V"                                  ,"Temperature dependence of a2")
`MPRnb(a3o            ,1.0        ,""                                   ,"Geometry independent saturation-voltage dependence of II")
`MPRnb(a3l            ,0.0        ,""                                   ,"Length dependence of a3")
`MPRnb(a3w            ,0.0        ,""                                   ,"Width dependence of a3")
`MPRnb(a4o            ,0.0        ,"V^-0.5"                             ,"Geometry independent back-bias dependence of II")
`MPRnb(a4l            ,0.0        ,""                                   ,"Length dependence of a4")
`MPRnb(a4w            ,0.0        ,""                                   ,"Width dependence of a4")

// Gate current parameters

`MPRnb(gcoo           ,0.0        ,""                                   ,"Gate tunnelling energy adjustment")
`MPRnb(iginvlw        ,0.0        ,"A"                                  ,"Gate channel current pre-factor for 1 um^2 channel area")
`MPRnb(igovw          ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for 1 um wide channel")
`MPRnb(igovdw         ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for 1 um wide channel for drain side")
`MPRnb(stigo          ,2.0        ,""                                   ,"Temperature dependence of iginv and igov")
`MPRnb(gc2o           ,0.375      ,""                                   ,"Gate current slope factor")
`MPRnb(gc3o           ,0.063      ,""                                   ,"Gate current curvature factor")
`MPRnb(chibo          ,3.1        ,"V"                                  ,"Tunnelling barrier height")

// Gate-induced drain leakage parameters

`MPRnb(agidlw         ,0.0        ,"A/V^3"                              ,"Width dependence of GIDL pre-factor")
`MPRnb(agidldw        ,0.0        ,"A/V^3"                              ,"Width dependence of GIDL pre-factor for drain side")
`MPRnb(bgidlo         ,41.0       ,"V"                                  ,"GIDL probability factor at tr")
`MPRnb(bgidldo        ,41.0       ,"V"                                  ,"GIDL probability factor at tr for drain side")
`MPRnb(stbgidlo       ,0.0        ,"V/K"                                ,"Temperature dependence of bgidl")
`MPRnb(stbgidldo      ,0.0        ,"V/K"                                ,"Temperature dependence of bgidl for drain side")
`MPRnb(cgidlo         ,0.0        ,""                                   ,"Back-bias dependence of GIDL")
`MPRnb(cgidldo        ,0.0        ,""                                   ,"Back-bias dependence of GIDL for drain side")

// Charge Model Parameters

`MPRnb(cgbovl         ,0.0        ,"F"                                  ,"Oxide capacitance for gate-bulk overlap for 1 um long channel")
`MPRnb(cfrw           ,0.0        ,"F"                                  ,"Outer fringe capacitance for 1 um wide channel")
`MPRnb(cfrdw          ,0.0        ,"F"                                  ,"Outer fringe capacitance for 1 um wide channel for drain side")

// Noise Model Parameters

`MPRnb(fnto           ,1.0        ,""                                   ,"Thermal noise coefficient")
`MPRcz(fntexcl        ,0.0        ,""                                   ,"Length dependence coefficient of excess noise")
`MPRnb(nfalw          ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(nfblw          ,3.0e7      ,"V^-1/m^2"                           ,"Second coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(nfclw          ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(efo            ,1.0        ,""                                   ,"Flicker noise frequency exponent")
`MPRnb(lintnoi        ,0.0        ,"m"                                  ,"Length offset for flicker noise")
`MPRnb(alpnoi         ,2.0        ,""                                   ,"Exponent for length offset for flicker noise")

// Edge transistor parameters: PSP 103.4

`MPRcz(wedge          ,1.0e-8     ,"m"                                  ,"Electrical width of edge transistor per side")
`MPRcz(wedgew         ,0.0        ,""                                   ,"Width dependence of edge wedge")
`MPRnb(vfbedgeo       ,-1.0       ,"V"                                  ,"Geometry-independent flat-band voltage of edge transistors at tr")
`MPRnb(stvfbedgeo     ,5.0e-4     ,"V/K"                                ,"Geometry-independent temperature dependence of vfbedge")
`MPRnb(stvfbedgel     ,0.0        ,"V/K"                                ,"Length dependence of temperature dependence of vfbedge")
`MPRnb(stvfbedgew     ,0.0        ,"V/K"                                ,"Width dependence of temperature dependence of vfbedge")
`MPRnb(stvfbedgelw    ,0.0        ,"V/K"                                ,"Area dependence of temperature dependence of vfbedge")
`MPRnb(dphibedgeo     ,0.0        ,"V"                                  ,"Geometry independent of edge transistor PHIB offset")
`MPRnb(dphibedgel     ,0.0        ,"V"                                  ,"Length dependence of edge transistor PHIB offset")
`MPRnb(dphibedgelexp  ,1.0        ,""                                   ,"Exponent for length dependence of edge transistor PHIB offset")
`MPRnb(dphibedgew     ,0.0        ,"V"                                  ,"Width dependence of edge transistor PHIB offset")
`MPRnb(dphibedgelw    ,0.0        ,"V"                                  ,"Area dependence of edge transistor PHIB offset")
`MPRco(nsubedgeo      ,5.0e23     ,"m^-3"     ,1.0e20      ,inf         ,"Geometry independent substrate doping of edge transistors")
`MPRnb(nsubedgel      ,0.0        ,""                                   ,"Length dependence of edge transistor substrate doping")
`MPRnb(nsubedgelexp   ,1.0        ,""                                   ,"Exponent for length dependence of edge transistor substrate doping")
`MPRnb(nsubedgew      ,0.0        ,""                                   ,"Width dependence of edge transistor substrate doping")
`MPRnb(nsubedgelw     ,0.0        ,""                                   ,"Area dependence of edge transistor substrate doping")
`MPRnb(ctedgeo        ,0.0        ,""                                   ,"Geometry-independent interface states factor of edge transistors")
`MPRnb(ctedgel        ,0.0        ,""                                   ,"Length dependence of interface states factor of edge transistors")
`MPRnb(ctedgelexp     ,1.0        ,""                                   ,"Exponent for length dependence of interface states factor of edge transistors")
`MPRnb(fbetedge       ,0.0        ,""                                   ,"Length dependence of edge transistor mobility")
`MPRco(lpedge         ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Exponent for length dependence of edge transistor mobility")
`MPRnb(betedgew       ,0.0        ,""                                   ,"Width scaling coefficient of edge transistor mobility")
`MPRnb(stbetedgeo     ,1.0        ,""                                   ,"Geometry independent temperature dependence of betnedge")
`MPRnb(stbetedgel     ,0.0        ,""                                   ,"Length dependence of temperature dependence of betnedge")
`MPRnb(stbetedgew     ,0.0        ,""                                   ,"Width dependence of temperature dependence of betnedge")
`MPRnb(stbetedgelw    ,0.0        ,""                                   ,"Area dependence of temperature dependence of betnedge")
`MPRnb(psceedgel      ,0.0        ,""                                   ,"Length dependence of subthreshold slope coefficient for short channel edge transistors")
`MPRnb(psceedgelexp   ,2.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel edge transistors")
`MPRnb(psceedgew      ,0.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel edge transistor")
`MPRcc(pscebedgeo     ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
`MPRcz(pscededgeo     ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
`MPRnb(cfedgel        ,0.0        ,""                                   ,"Length dependence of DIBL-parameter of edge transistors")
`MPRnb(cfedgelexp     ,2.0        ,""                                   ,"Exponent for length dependence of DIBL-parameter of edge transistors")
`MPRnb(cfedgew        ,0.0        ,""                                   ,"Width dependence of DIBL-parameter of edge transistors")
`MPRcz(cfdedgeo       ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of DIBL-parameter of edge transistors")
`MPRcc(cfbedgeo       ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of DIBL-parameter of edge transistors")
`MPRnb(fntedgeo       ,1.0        ,""                                   ,"Thermal noise coefficient")
`MPRnb(nfaedgelw      ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(nfbedgelw      ,3.0e7      ,"V^-1/m^2"                           ,"Second coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(nfcedgelw      ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise for 1 um^2 channel area")
`MPRnb(efedgeo        ,1.0        ,""                                   ,"Flicker noise frequency exponent")

// Well proximity effect Parameters

`MPRnb(kvthoweo       ,0.0        ,""                                   ,"Geometrical independent threshold shift parameter")
`MPRnb(kvthowel       ,0.0        ,""                                   ,"Length dependent threshold shift parameter")
`MPRnb(kvthowew       ,0.0        ,""                                   ,"Width dependent threshold shift parameter")
`MPRnb(kvthowelw      ,0.0        ,""                                   ,"Area dependent threshold shift parameter")
`MPRnb(kuoweo         ,0.0        ,""                                   ,"Geometrical independent mobility degradation factor")
`MPRnb(kuowel         ,0.0        ,""                                   ,"Length dependent mobility degradation factor")
`MPRnb(kuowew         ,0.0        ,""                                   ,"Width dependent mobility degradation factor")
`MPRnb(kuowelw        ,0.0        ,""                                   ,"Area dependent mobility degradation factor")

// Parasitic resistance parameters

`MPRnb(rgo            ,0.0        ,"Ohm"                                ,"Gate resistance")
`MPRcz(rint           ,0.0        ,"Ohm m^2"                            ,"Contact resistance between silicide and ploy")
`MPRcz(rvpoly         ,0.0        ,"Ohm m^2"                            ,"Vertical poly resistance")
`MPRcz(rshg           ,0.0        ,"Ohm/sq"                             ,"Gate electrode diffusion sheet resistance")
`MPRnb(dlsil          ,0.0        ,"m"                                  ,"Silicide extension over the physical gate length")
`MPRcz(rjunso         ,0.0        ,"Ohm/m"                              ,"source diode series resistance per width")
`MPRcz(rjundo         ,0.0        ,"Ohm/m"                              ,"intrinsic drain diode series resistance per width")
`MPRcz(rjunxo         ,0.0        ,"Ohm/m"                              ,"extrinsic drain diode series resistance per width")
`MPRcz(rbulko         ,0.0        ,"Ohm/m"                              ,"bulk series resistance per width")
`MPRnb(dwrjuns        ,0.0        ,"m"                                  ,"source diode series resistance width offset")
`MPRnb(dwrjund        ,0.0        ,"m"                                  ,"intrinsic drain diode series resistance width offset")
`MPRnb(dwrjunx        ,0.0        ,"m"                                  ,"extrinsic drain diode series resistance width offset")
`MPRnb(dwrbulk        ,0.0        ,"m"                                  ,"bulk series resistance width offset")

// Stress Model Parameters

`MPRco(saref          ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Reference distance between OD-edge and poly from one side")
`MPRco(sbref          ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Reference distance between OD-edge and poly from other side")
`MPRnb(wlod           ,0.0        ,"m"                                  ,"Width parameter")
`MPRnb(kuo            ,0.0        ,"m"                                  ,"Mobility degradation/enhancement coefficient")
`MPRcc(kvsat          ,0.0        ,"m"        ,-1.0        ,1.0         ,"Saturation velocity degradation/enhancement coefficient")
`MPRnb(tkuo           ,0.0        ,""                                   ,"Temperature dependence of kuo")
`MPRnb(lkuo           ,0.0        ,"m^llodkuo"                          ,"Length dependence of kuo")
`MPRnb(wkuo           ,0.0        ,"m^wlodkuo"                          ,"Width dependence of kuo")
`MPRnb(pkuo           ,0.0        ,"m^(llodkuo+wlodkuo)"                ,"Cross-term dependence of kuo")
`MPRcz(llodkuo        ,0.0        ,""                                   ,"Length parameter for uo stress effect")
`MPRcz(wlodkuo        ,0.0        ,""                                   ,"Width parameter for uo stress effect")
`MPRnb(kvtho          ,0.0        ,"Vm"                                 ,"Threshold shift parameter")
`MPRnb(lkvtho         ,0.0        ,"m^llodvth"                          ,"Length dependence of kvtho")
`MPRnb(wkvtho         ,0.0        ,"m^wlodvth"                          ,"Width dependence of kvtho")
`MPRnb(pkvtho         ,0.0        ,"m^(llodvth+wlodvth)"                ,"Cross-term dependence of kvtho")
`MPRcz(llodvth        ,0.0        ,""                                   ,"Length parameter for VTH-stress effect")
`MPRcz(wlodvth        ,0.0        ,""                                   ,"Width parameter for VTH-stress effect")
`MPRnb(stetao         ,0.0        ,"m"                                  ,"Eta0 shift factor related to VTHO change")
`MPRcz(lodetao        ,1.0        ,""                                   ,"Eta0 shift modification factor for stress effect")

// Well proximity effect Parameters

`MPRcz(scref          ,1.0e-6     ,"m"                                  ,"Distance between OD-edge and well edge of a reference device")
`MPRnb(web            ,0.0        ,""                                   ,"Coefficient for scb")
`MPRnb(wec            ,0.0        ,""                                   ,"Coefficient for scc")

//
//  JUNCAP2 parameters (BOT/STI/GAT=area/sti-edge/gate-edge component)
//

`MPRcc( frev      ,   1.0e03  ,""                ,  10.0,1.0e10, "breakdown linearization is at vbr*(1-1/frev)")
`MPRcc( fc        ,   0.9     ,""                ,   0.0,  0.99, "depletion capacitance linearization factor")
`MPRnb( aj        ,  -0.5     ,"V"                             , "depletion capacitance smoothing parameter")
`MPIcc( eglev     ,   1       ,""                ,   1  ,   2  , "bandgap model selector: 1=Tsividis, 2=Sze1981")
`MPRoo( egdelta   ,   0.0     ,"eV"              ,  -inf,   inf, "bandgap-delta     for eglev=1 model")
`MPRoo( phig      ,   1.16    ,"eV"              ,  -inf,   inf, "bandgap Eg(T=0 K) for eglev=2 model")
`MPRoo( alphaeg   ,   7.02e-04,"eV/K^2"          ,  -inf,   inf, "bandgap alpha     for eglev=2 model")
`MPRoo( betaeg    ,1108.0     ,"K"               ,  -inf,   inf, "bandgap beta      for eglev=2 model")
`MPRoo( stfbbt    ,   0.0     ,"/K"              ,  -inf,   inf, "fbbt linear TC")
`MPRoo( stvbr     ,   0.0     ,"/K"              ,  -inf,   inf, "vbr  linear TC")
`MPRoo( stfbbtd   ,   0.0     ,"/K"              ,  -inf,   inf, "fbbt linear TC (drain and extrinsci drain)")
`MPRoo( stvbrd    ,   0.0     ,"/K"              ,  -inf,   inf, "vbr  linear TC (drain and extrinsic drain)")

`MPRco( idsatrbot ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) ideal saturation current at trj")
`MPRoo( nbot      ,   1.0     ,""                ,   0.0,   inf, "(bot) ideality factor for idsatbot")
`MPRoo( xisbot    ,   3.0     ,""                ,  -inf,   inf, "(bot) exponent for temperature dependence of idsatbot")
`MPRco( ikrbot    ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) knee current at trj")
`MPRco( nkbot     ,   0.5     ,""                ,   0.0,   inf, "(bot) knee current rolloff coefficient")
`MPRoo( xikbot    ,   0.0     ,""                ,  -inf,   inf, "(bot) temperature exponent of ikrbot")
`MPRco( csrhrbot  ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) SRH prefactor at trj")
`MPRcc( neffbot   ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(bot) effective junction doping [0.5*NA*ND/(NA+ND)]")
`MPRco( ctatrbot  ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) TAT prefactor at trj")
`MPRco( mefftatbot,   0.25    ,""                ,   0.01,  inf, "(bot) TAT meff/m0 ratio")
`MPRco( cbbtrbot  ,   0.0     ,"A/V^3"           ,   0.0,   inf, "(bot) BBT prefactor")
`MPRco( fbbtrbot  ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(bot) BBT normalization field at trj")
`MPRco( vbrrbot   ,   0.0     ,"V"               ,   0.0,   inf, "(bot) breakdown voltage (<0.1 means no breakdown)")
`MPRco( pbrbot    ,   4.0     ,""                ,   0.1,   inf, "(bot) breakdown onset tuning parameter")
`MPRco( cjorbot   ,   0.0     ,"F/m^2"           ,   0.0,   inf, "(bot) zero-bias depletion capacitance at trj")
`MPRco( vbirbot   ,   0.75    ,"V"               ,   0.05,  inf, "(bot) built-in potential at trj")
`MPRoo( pbot      ,   0.33    ,""                ,   0.05, 0.95, "(bot) grading coefficient")
`MPRco( idsatrsti ,   0.0     ,"A/m"             ,   0.0,   inf, "(sti) ideal saturation current at trj")
`MPRoo( nsti      ,   1.0     ,""                ,   0.0,   inf, "(sti) ideality factor for idsatsti")
`MPRoo( xissti    ,   3.0     ,""                ,  -inf,   inf, "(sti) exponent for temperature dependence of idsatsti")
`MPRco( ikrsti    ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) knee current at trj")
`MPRco( nksti     ,   0.5     ,""                ,   0.0,   inf, "(sti) knee current rolloff coefficient")
`MPRoo( xiksti    ,   0.0     ,""                ,  -inf,   inf, "(sti) temperature exponent of ikrsti")
`MPRco( csrhrsti  ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) SRH prefactor at trj")
`MPRcc( neffsti   ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(sti) effective junction doping [0.5*NA*ND/(NA+ND)]")
`MPRco( ctatrsti  ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) TAT prefactor at trj")
`MPRco( mefftatsti,   0.25    ,""                ,   0.01,  inf, "(sti) TAT meff/m0 ratio")
`MPRco( cbbtrsti  ,   0.0     ,"A/V^3*m"         ,   0.0,   inf, "(sti) BBT prefactor")
`MPRco( fbbtrsti  ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(sti) BBT normalization field at trj")
`MPRco( vbrrsti   ,   0.0     ,"V"               ,   0.0,   inf, "(sti) breakdown voltage (<0.1 means no breakdown)")
`MPRco( pbrsti    ,   4.0     ,""                ,   0.1,   inf, "(sti) breakdown onset tuning parameter")
`MPRco( cjorsti   ,   0.0     ,"F/m"             ,   0.0,   inf, "(sti) zero-bias depletion capacitance at trj")
`MPRco( vbirsti   ,   0.75    ,"V"               ,   0.05,  inf, "(sti) built-in potential at trj")
`MPRoo( psti      ,   0.33    ,""                ,   0.05, 0.95, "(sti) grading coefficient")
`MPRco( idsatrgat ,   0.0     ,"A/m"             ,   0.0,   inf, "(gat) ideal saturation current at trj")
`MPRoo( ngat      ,   1.0     ,""                ,   0.0,   inf, "(gat) ideality factor for idsatgat")
`MPRoo( xisgat    ,   3.0     ,""                ,  -inf,   inf, "(gat) exponent for temperature dependence of idsatgat")
`MPRco( ikrgat    ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) knee current at trj")
`MPRco( nkgat     ,   0.5     ,""                ,   0.0,   inf, "(gat) knee current rolloff coefficient")
`MPRoo( xikgat    ,   0.0     ,""                ,  -inf,   inf, "(gat) temperature exponent of ikrgat")
`MPRco( csrhrgat  ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) SRH prefactor at trj")
`MPRcc( neffgat   ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(gat) effective junction doping [0.5*NA*ND/(NA+ND)]")
`MPRco( ctatrgat  ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) TAT prefactor at trj")
`MPRco( mefftatgat,   0.25    ,""                ,   0.01,  inf, "(gat) TAT meff/m0 ratio")
`MPRco( cbbtrgat  ,   0.0     ,"A/V^3*m"         ,   0.0,   inf, "(gat) BBT prefactor")
`MPRco( fbbtrgat  ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(gat) BBT normalization field at trj")
`MPRco( vbrrgat   ,   0.0     ,"V"               ,   0.0,   inf, "(gat) breakdown voltage (<0.1 means no breakdown)")
`MPRco( pbrgat    ,   4.0     ,""                ,   0.1,   inf, "(gat) breakdown onset tuning parameter")
`MPRco( cjorgat   ,   0.0     ,"F/m"             ,   0.0,   inf, "(gat) zero-bias depletion capacitance at trj")
`MPRco( vbirgat   ,   0.75    ,"V"               ,   0.05,  inf, "(gat) built-in potential at trj")
`MPRoo( pgat      ,   0.33    ,""                ,   0.05, 0.95, "(gat) grading coefficient")

`MPRco( idsatrbotd,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) ideal saturation current at trj (drain)")
`MPRoo( nbotd     ,   1.0     ,""                ,   0.0,   inf, "(bot) ideality factor for idsatbotd (drain)")
`MPRoo( xisbotd   ,   3.0     ,""                ,  -inf,   inf, "(bot) exponent for temperature dependence of idsatbotd")
`MPRco( ikrbotd   ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) knee current at trj (drain)")
`MPRco( nkbotd    ,   0.5     ,""                ,   0.0,   inf, "(bot) knee current rolloff coefficient (drain)")
`MPRoo( xikbotd   ,   0.0     ,""                ,  -inf,   inf, "(bot) temperature exponent of ikrbotd")
`MPRco( csrhrbotd ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) SRH prefactor at trj (drain)")
`MPRcc( neffbotd  ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(bot) effective junction doping [0.5*NA*ND/(NA+ND)] (drain)")
`MPRco( ctatrbotd ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) TAT prefactor at trj (drain)")
`MPRco( mefftatbotd,  0.25    ,""                ,   0.01,  inf, "(bot) TAT meff/m0 ratio (drain)")
`MPRco( cbbtrbotd ,   0.0     ,"A/V^3"           ,   0.0,   inf, "(bot) BBT prefactor (drain)")
`MPRco( fbbtrbotd ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(bot) BBT normalization field at trj (drain)")
`MPRco( vbrrbotd  ,   0.0     ,"V"               ,   0.0,   inf, "(bot) breakdown voltage (<0.1 means no breakdown) (drain)")
`MPRco( pbrbotd   ,   4.0     ,""                ,   0.1,   inf, "(bot) breakdown onset tuning parameter (drain)")
`MPRco( cjorbotd  ,   0.0     ,"F/m^2"           ,   0.0,   inf, "(bot) zero-bias depletion capacitance at trj (drain)")
`MPRco( vbirbotd  ,   0.75    ,"V"               ,   0.05,  inf, "(bot) built-in potential at trj (drain)")
`MPRoo( pbotd     ,   0.33    ,""                ,   0.05, 0.95, "(bot) grading coefficient (drain)")
`MPRco( idsatrstid,   0.0     ,"A/m"             ,   0.0,   inf, "(sti) ideal saturation current at trj (drain)")
`MPRoo( nstid     ,   1.0     ,""                ,   0.0,   inf, "(sti) ideality factor for idsatstid (drain)")
`MPRoo( xisstid   ,   3.0     ,""                ,  -inf,   inf, "(sti) exponent for temperature dependence of idsatstid")
`MPRco( ikrstid   ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) knee current at trj (drain)")
`MPRco( nkstid    ,   0.5     ,""                ,   0.0,   inf, "(sti) knee current rolloff coefficient (drain)")
`MPRoo( xikstid   ,   0.0     ,""                ,  -inf,   inf, "(sti) temperature exponent of ikrstid")
`MPRco( csrhrstid ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) SRH prefactor at trj (drain)")
`MPRcc( neffstid  ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(sti) effective junction doping [0.5*NA*ND/(NA+ND)] (drain)")
`MPRco( ctatrstid ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) TAT prefactor at trj (drain)")
`MPRco( mefftatstid,  0.25    ,""                ,   0.01,  inf, "(sti) TAT meff/m0 ratio (drain)")
`MPRco( cbbtrstid ,   0.0     ,"A/V^3*m"         ,   0.0,   inf, "(sti) BBT prefactor (drain)")
`MPRco( fbbtrstid ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(sti) BBT normalization field at trj (drain)")
`MPRco( vbrrstid  ,   0.0     ,"V"               ,   0.0,   inf, "(sti) breakdown voltage (<0.1 means no breakdown) (drain)")
`MPRco( pbrstid   ,   4.0     ,""                ,   0.1,   inf, "(sti) breakdown onset tuning parameter (drain)")
`MPRco( cjorstid  ,   0.0     ,"F/m"             ,   0.0,   inf, "(sti) zero-bias depletion capacitance at trj (drain)")
`MPRco( vbirstid  ,   0.75    ,"V"               ,   0.05,  inf, "(sti) built-in potential at trj (drain)")
`MPRoo( pstid     ,   0.33    ,""                ,   0.05, 0.95, "(sti) grading coefficient (drain)")
`MPRco( idsatrgatd,   0.0     ,"A/m"             ,   0.0,   inf, "(gat) ideal saturation current at trj (drain)")
`MPRoo( ngatd     ,   1.0     ,""                ,   0.0,   inf, "(gat) ideality factor for idsatgatd (drain)")
`MPRoo( xisgatd   ,   3.0     ,""                ,  -inf,   inf, "(gat) exponent for temperature dependence of idsatgatd")
`MPRco( ikrgatd   ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) knee current at trj (drain)")
`MPRco( nkgatd    ,   0.5     ,""                ,   0.0,   inf, "(gat) knee current rolloff coefficient (drain)")
`MPRoo( xikgatd   ,   0.0     ,""                ,  -inf,   inf, "(gat) temperature exponent of ikrgatd")
`MPRco( csrhrgatd ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) SRH prefactor at trj (drain)")
`MPRcc( neffgatd  ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(gat) effective junction doping [0.5*NA*ND/(NA+ND)] (drain)")
`MPRco( ctatrgatd ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(gat) TAT prefactor at trj (drain)")
`MPRco( mefftatgatd,  0.25    ,""                ,   0.01,  inf, "(gat) TAT meff/m0 ratio (drain)")
`MPRco( cbbtrgatd ,   0.0     ,"A/V^3*m"         ,   0.0,   inf, "(gat) BBT prefactor (drain)")
`MPRco( fbbtrgatd ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(gat) BBT normalization field at trj (drain)")
`MPRco( vbrrgatd  ,   0.0     ,"V"               ,   0.0,   inf, "(gat) breakdown voltage (<0.1 means no breakdown) (drain)")
`MPRco( pbrgatd   ,   4.0     ,""                ,   0.1,   inf, "(gat) breakdown onset tuning parameter (drain)")
`MPRco( cjorgatd  ,   0.0     ,"F/m"             ,   0.0,   inf, "(gat) zero-bias depletion capacitance at trj (drain)")
`MPRco( vbirgatd  ,   0.75    ,"V"               ,   0.05,  inf, "(gat) built-in potential at trj (drain)")
`MPRoo( pgatd     ,   0.33    ,""                ,   0.05, 0.95, "(gat) grading coefficient (drain)")

`MPRco( idsatrbotx,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) ideal saturation current at trj (extrinsic drain)")
`MPRoo( nbotx     ,   1.0     ,""                ,   0.0,   inf, "(bot) ideality factor for idsatbotx (extrinsic drain)")
`MPRoo( xisbotx   ,   3.0     ,""                ,  -inf,   inf, "(bot) exponent for temperature dependence of idsatbotx")
`MPRco( ikrbotx   ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(bot) knee current at trj (extrinsic drain)")
`MPRco( nkbotx    ,   0.5     ,""                ,   0.0,   inf, "(bot) knee current rolloff coefficient (extrinsic drain)")
`MPRoo( xikbotx   ,   0.0     ,""                ,  -inf,   inf, "(bot) temperature exponent of ikrbotx")
`MPRco( csrhrbotx ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) SRH prefactor at trj (extrinsic drain)")
`MPRcc( neffbotx  ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(bot) effective junction doping [0.5*NA*ND/(NA+ND)] (extrinsic drain)")
`MPRco( ctatrbotx ,   0.0     ,"A/m^3"           ,   0.0,   inf, "(bot) TAT prefactor at trj (extrinsic drain)")
`MPRco( mefftatbotx,  0.25    ,""                ,   0.01,  inf, "(bot) TAT meff/m0 ratio (extrinsic drain)")
`MPRco( cbbtrbotx ,   0.0     ,"A/V^3"           ,   0.0,   inf, "(bot) BBT prefactor (extrinsic drain)")
`MPRco( fbbtrbotx ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(bot) BBT normalization field at trj (extrinsic drain)")
`MPRco( vbrrbotx  ,   0.0     ,"V"               ,   0.0,   inf, "(bot) breakdown voltage (<0.1 means no breakdown) (extrinsic drain)")
`MPRco( pbrbotx   ,   4.0     ,""                ,   0.1,   inf, "(bot) breakdown onset tuning parameter (extrinsic drain)")
`MPRco( cjorbotx  ,   0.0     ,"F/m^2"           ,   0.0,   inf, "(bot) zero-bias depletion capacitance at trj (extrinsic drain)")
`MPRco( vbirbotx  ,   0.75    ,"V"               ,   0.05,  inf, "(bot) built-in potential at trj (extrinsic drain)")
`MPRoo( pbotx     ,   0.33    ,""                ,   0.05, 0.95, "(bot) grading coefficient (extrinsic drain)")
`MPRco( idsatrstix,   0.0     ,"A/m"             ,   0.0,   inf, "(sti) ideal saturation current at trj (extrinsic drain)")
`MPRoo( nstix     ,   1.0     ,""                ,   0.0,   inf, "(sti) ideality factor for idsatstix (extrinsic drain)")
`MPRoo( xisstix   ,   3.0     ,""                ,  -inf,   inf, "(sti) exponent for temperature dependence of idsatstix")
`MPRco( ikrstix   ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) knee current at trj (extrinsic drain)")
`MPRco( nkstix    ,   0.5     ,""                ,   0.0,   inf, "(sti) knee current rolloff coefficient (extrinsic drain)")
`MPRoo( xikstix   ,   0.0     ,""                ,  -inf,   inf, "(sti) temperature exponent of ikrstix")
`MPRco( csrhrstix ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) SRH prefactor at trj (extrinsic drain)")
`MPRcc( neffstix  ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "(sti) effective junction doping [0.5*NA*ND/(NA+ND)] (extrinsic drain)")
`MPRco( ctatrstix ,   0.0     ,"A/m^2"           ,   0.0,   inf, "(sti) TAT prefactor at trj (extrinsic drain)")
`MPRco( mefftatstix,  0.25    ,""                ,   0.01,  inf, "(sti) TAT meff/m0 ratio (extrinsic drain)")
`MPRco( cbbtrstix ,   0.0     ,"A/V^3*m"         ,   0.0,   inf, "(sti) BBT prefactor (extrinsic drain)")
`MPRco( fbbtrstix ,   1.0e09  ,"V/m"             ,   0.0,   inf, "(sti) BBT normalization field at trj (extrinsic drain)")
`MPRco( vbrrstix  ,   0.0     ,"V"               ,   0.0,   inf, "(sti) breakdown voltage (<0.1 means no breakdown) (extrinsic drain)")
`MPRco( pbrstix   ,   4.0     ,""                ,   0.1,   inf, "(sti) breakdown onset tuning parameter (extrinsic drain)")
`MPRco( cjorstix  ,   0.0     ,"F/m"             ,   0.0,   inf, "(sti) zero-bias depletion capacitance at trj (extrinsic drain)")
`MPRco( vbirstix  ,   0.75    ,"V"               ,   0.05,  inf, "(sti) built-in potential at trj (extrinsic drain)")
`MPRoo( pstix     ,   0.33    ,""                ,   0.05, 0.95, "(sti) grading coefficient (extrinsic drain)")

`MPRco( ttbot     ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for bottom component of source-bulk junction")
`MPRco( ttsti     ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for STI-edge component of source-bulk junction")
`MPRco( ttgat     ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for gate-edge component of source-bulk junction")
`MPRco( ttbotd    ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for bottom component of drain-bulk junction")
`MPRco( ttstid    ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for STI-edge component of drain-bulk junction")
`MPRco( ttgatd    ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for gate-edge component of drain-bulk junction")
`MPRco( ttbotx    ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for bottom component of extrinsic drain-bulk junction")
`MPRco( ttstix    ,   0.0     ,"s"               ,   0.0,   inf, "diffusion charge transit time for STI-edge component of extrinsic drain-bulk junction")

`ifdef diodeReverseRecovery
`MPRcz( trrs      ,   0.0     ,"s"                             , "source diode reverse-recovery relaxation time")
`MPRcz( trrd      ,   0.0     ,"s"                             , "intrinsic drain diode reverse-recovery relaxation time")
`MPRcz( trrx      ,   0.0     ,"s"                             , "extrinsic drain diode reverse-recovery relaxation time")
`endif

//
//  JFETIDG basic drift region resistance model parameters
//

`MPRoo( xw        ,   0.0     ,"m"               ,  -inf,   inf, "width  offset (total)")
`MPRoo( nwxw      ,   0.0     ,"m"               ,  -inf,   inf, "narrow width width offset correction coefficient")
`MPRoo( fdrwo     ,   1.0e-06 ,"m"               ,   0.0,   inf, "finite doping  width offset reference width")
`MPRoo( fdxwo     ,   0.0     ,"m"               ,  -inf,   inf, "finite doping  width offset width value for wide devices")
`MPRoo( xl        ,   0.0     ,"m"               ,  -inf,   inf, "length offset (total)")
`MPRoo( xlw       ,   0.0     ,"m"               ,  -inf,   inf, "width dependence of length offset")
`MPRoo( dxlsat    ,   0.0     ,"m"               ,  -inf,   inf, "additional length offset for velocity saturation calculation")
`MPRoo( xlgdovq   ,   0.0     ,"m"               ,  -inf,   inf, "length offset for gate-drain overlap charge")
`MPRco( lspread   ,   0.0     ,"m"               ,   0.0,   inf, "drain spreading resistance maximum length")
`MPRco( dlspread  ,   0.0     ,"m"               ,   0.0,   inf, "drain spreading resistance offset length")
`MPRco( xspread   ,   0.0     ,""                ,   0.0,   inf, "drain spreading resistance area factor")
`MPRco( aspread   ,   0.0     ,""                ,   0.0,   inf, "drain spreading resistance smoothing parameter")
`MPRco( rgdovr    ,   0.0     ,""                ,   0.0,   inf, "gate-drain overlap sheet rho relative to drift region")
`MPRco( tm        ,   5.0e-07 ,"m"               ,1.0e-8,   inf, "channel     thickness (metallurgical)")
`MPRcc( nc        ,   1.0e23  ,"/m^3"            ,1.0e18,1.0e28, "channel     doping concentration")
`MPRcc( nb        ,   1.0e22  ,"/m^3"            ,1.0e18,1.0e28, "bottom gate doping concentration")
`MPRco( toxb      ,   4.0e-07  ,"m"              ,0.1e-9,   inf, "bottom gate oxide thickness")
`MPRcc( vfbb      ,   0.0     ,"V"               , -10.0,  10.0, "bottom gate flatband voltage")
`MPRcc( nt        ,   1.0e26  ,"/m^3"            ,1.0e18,1.0e28, "top gate    doping concentration")
`MPRco( toxt      ,   4.0e-07  ,"m"              ,0.1e-9,   inf, "top gate    oxide thickness")
`MPRcc( vfbt      ,   0.0     ,"V"               , -10.0,  10.0, "top    gate flatband voltage")
`MPRco( dfb       ,   0.01    ,"/V^0.5"          ,   0.0,   inf, "bottom gate depletion factor (overrides calculation if specified)")
`MPRco( dfbo      ,   0.01    ,"/V^0.5"          ,   0.0,   inf, "dfb   geometry independent part")
`MPRoo( dfbl      ,   0.0     ,""                ,  -inf,   inf, "dfb   1/l     coefficient")
`MPRoo( dfble     ,   1.0     ,""                ,  -inf,   inf, "dfb   1/l     exponent")
`MPRoo( dfbw      ,   0.0     ,""                ,  -inf,   inf, "dfb   1/w     coefficient")
`MPRoo( dfbwe     ,   1.0     ,""                ,  -inf,   inf, "dfb   1/w     exponent")
`MPRoo( dfblw     ,   0.0     ,""                ,  -inf,   inf, "dfb   1/(l*w) coefficient")
`MPRco( dfbfac    ,   1.0     ,""                ,   0.0,   inf, "dfb   adjustment coefficient")
`MPRco( psirb     ,   2.0     ,"V"               ,   0.1,   inf, "bottom gate depletion potential (overrides calculation if specified)")
`MPRco( psirbo    ,   2.0     ,"V"               ,   0.1,   inf, "psirb geometry independent part")
`MPRoo( psirbl    ,   0.0     ,""                ,  -inf,   inf, "psirb 1/l     coefficient")
`MPRoo( psirble   ,   1.0     ,""                ,  -inf,   inf, "psirb 1/l     exponent")
`MPRoo( psirbw    ,   0.0     ,""                ,  -inf,   inf, "psirb 1/w     coefficient")
`MPRoo( psirbwe   ,   1.0     ,""                ,  -inf,   inf, "psirb 1/w     exponent")
`MPRoo( psirblw   ,   0.0     ,""                ,  -inf,   inf, "psirb 1/(l*w) coefficient")
`MPRoo( psirbfac  ,   1.0     ,""                ,   0.0,   inf, "psirb adjustment coefficient")
`MPRco( dft       ,   0.0     ,"/V^0.5"          ,   0.0,   inf, "top gate depletion factor (overrides calculation if specified)")
`MPRco( dfto      ,   0.0     ,"/V^0.5"          ,   0.0,   inf, "dft   geometry independent part")
`MPRoo( dftl      ,   0.0     ,""                ,  -inf,   inf, "dft   1/l     coefficient")
`MPRoo( dftle     ,   1.0     ,""                ,  -inf,   inf, "dft   1/l     exponent")
`MPRoo( dftw      ,   0.0     ,""                ,  -inf,   inf, "dft   1/w     coefficient")
`MPRoo( dftwe     ,   1.0     ,""                ,  -inf,   inf, "dft   1/w     exponent")
`MPRoo( dftlw     ,   0.0     ,""                ,  -inf,   inf, "dft   1/(l*w) coefficient")
`MPRco( dftfac    ,   1.0     ,""                ,   0.0,   inf, "dft   adjustment coefficient")
`MPRco( psirt     ,   2.0     ,"V"               ,   0.1,   inf, "top gate depletion potential (overrides calculation if specified)")
`MPRco( psirto    ,   2.0     ,"V"               ,   0.1,   inf, "psirt geometry independent part")
`MPRoo( psirtl    ,   0.0     ,""                ,  -inf,   inf, "psirt 1/l     coefficient")
`MPRoo( psirtle   ,   1.0     ,""                ,  -inf,   inf, "psirt 1/l     exponent")
`MPRoo( psirtw    ,   0.0     ,""                ,  -inf,   inf, "psirt 1/w     coefficient")
`MPRoo( psirtwe   ,   1.0     ,""                ,  -inf,   inf, "psirt 1/w     exponent")
`MPRoo( psirtlw   ,   0.0     ,""                ,  -inf,   inf, "psirt 1/(l*w) coefficient")
`MPRoo( psirtfac  ,   1.0     ,""                ,   0.0,   inf, "psirt adjustment coefficient")
`MPRoo( mu0       ,   0.05    ,"m^2/V/s"         ,   0.0,   inf, "low-field mobility")
`MPRoo( r0        , 100.0     ,"Ohm"             ,   0.0,   inf, "zero-bias resistance")
`MPRoo( rsh0      , 100.0     ,"Ohm/sq"          ,   0.0,   inf, "zero-bias sheet resistance (overrides calculation if specified)")
`MPRoo( rzd       , 100.0     ,"Ohm"             ,   0.0,   inf, "zero-depletion resistance")
`MPRoo( rshzd     , 100.0     ,"Ohm/sq"          ,   0.0,   inf, "zero-depletion sheet resistance (overrides calculation if specified)")
`MPRco( diblb     ,   0.0     ,""                ,   0.0,   inf, "bottom gate dibl")
`MPRco( diblbl    ,   0.0     ,""                ,   0.0,   inf, "diblb l dependence coefficient")
`MPRco( diblt     ,   0.0     ,""                ,   0.0,   inf, "top    gate dibl")
`MPRco( dibltl    ,   0.0     ,""                ,   0.0,   inf, "diblt l dependence coefficient")
`MPRco( diblle    ,   1.0     ,""                ,   0.0,   inf, "dibl  l dependence exponent")
`MPRco( diblv     ,   0.1     ,"V"               ,   0.01,  inf, "dibl  voltage offset")
`MPRco( dible     ,   0.5     ,""                ,   0.01,  1.0, "dibl  voltage exponent")
`MPRco( clm1      ,   0.0     ,""                ,   0.0,   inf, "clm     linear component")
`MPRco( clm1l     ,   0.0     ,""                ,   0.0,   inf, "clm1 l dependence coefficient")
`MPRco( clm1le    ,   1.0     ,""                ,   0.0,   inf, "clm1 l dependence exponent")
`MPRco( clm1c     ,   0.0     ,"/V"              ,   0.0,   inf, "clm1 V(gx) dependence coefficient")
`MPRco( clm2      ,   0.0     ,""                ,   0.0,   inf, "clm  nonlinear component")
`MPRco( clm2l     ,   0.0     ,""                ,   0.0,   inf, "clm2 l dependence coefficient")
`MPRco( clm2le    ,   1.0     ,""                ,   0.0,   inf, "clm2 l dependence exponent")
`MPRco( clm2v     ,   0.1     ,"V"               ,   0.01,  inf, "clm2 voltage offset")
`MPRco( clm2e     ,   0.5     ,""                ,   0.01,  1.0, "clm2 voltage exponent")
`MPRco( ats       ,   0.0     ,"V"               ,   0.0,   inf, "saturation smoothing parameter")
`MPRco( atso      ,   0.0     ,"V"               ,   0.0,   inf, "ats geometry independent part")
`MPRco( atsl      ,   0.0     ,"V"               ,   0.0,   inf, "ats 1/l coefficient")
`MPRco( axs       ,   0.0     ,""                ,   0.0,   inf, "2nd saturation smoothing parameter")
`MPRco( axso      ,   0.0     ,""                ,   0.0,   inf, "axs geometry independent part")
`MPRco( axsl      ,   0.0     ,""                ,   0.0,   inf, "axs 1/l coefficient")
`MPRcc( nspo      ,   1.0     ,""                ,   0.1,   5.0, "slope parameter under source pinch-off")
`MPRcc( nspoo     ,   1.0     ,""                ,   0.1,   5.0, "nspo geometry independent part")
`MPRoo( nspol     ,   0.0     ,""                ,  -inf,   inf, "nspo 1/l     coefficient")
`MPRoo( nspole    ,   1.0     ,""                ,  -inf,   inf, "nspo 1/l     exponent")
`MPRoo( nspow     ,   0.0     ,""                ,  -inf,   inf, "nspo 1/w     coefficient")
`MPRoo( nspowe    ,   1.0     ,""                ,  -inf,   inf, "nspo 1/w     exponent")
`MPRoo( nspolw    ,   0.0     ,""                ,  -inf,   inf, "nspo 1/(l*w) coefficient")
`MPRco( alphab    ,   0.0     ,"/V"              ,   0.0,   inf, "bottom gate impact ionization current prefactor")
`MPRnb( alphabo   ,   0.0     ,"/V"                            , "alphab geometry independent part")
`MPRnb( alphabl   ,   0.0     ,"/V"                            , "alphab 1/l coefficient")
`MPRnb( alphable  ,   1.0     ,""                              , "alphab 1/l exponent")
`MPRnb( alphabw   ,   0.0     ,"/V"                            , "alphab 1/w coefficient")
`MPRnb( alphabwe  ,   1.0     ,""                              , "alphab 1/w exponent")
`MPRco( alphat    ,   0.0     ,"/V"              ,   0.0,   inf, "top    gate impact ionization current prefactor")
`MPRco( alphato   ,   0.0     ,"/V"              ,   0.0,   inf, "alphat geometry independent part")
`MPRco( alphatl   ,   0.0     ,"/V"              ,   0.0,   inf, "alphat 1/l coefficient")
`MPRco( beta      ,  10.0     ,"V"               ,   0.0,   inf, "impact ionization current exponent for both gates")
`MPRoo( mumb      ,   0.0     ,"/V"              ,  -inf,   inf, "bottom gate mobility modulation coefficient")
`MPRoo( mumboff   ,   0.0     ,"V"               ,  -inf,   inf, "bottom gate mobility modulation voltage offset")
`MPRco( mumbs     ,   1.0     ,""                ,   0.0,   inf, "bottom gate mobility modulation smoothing parameter")
`MPRco( mumbe     ,   1.0     ,""                ,   0.0,   inf, "bottom gate mobility modulation exponent")
`MPRco( mumbo     ,   0.0     ,"/V"              ,   0.0,   inf, "mumb geometry independent part")
`MPRoo( mumbl     ,   0.0     ,""                ,  -inf,   inf, "mumb 1/l     coefficient")
`MPRoo( mumbw     ,   0.0     ,""                ,  -inf,   inf, "mumb 1/w     coefficient")
`MPRoo( mumblw    ,   0.0     ,""                ,  -inf,   inf, "mumb 1/(l*w) coefficient")
`MPRoo( mumt      ,   0.0     ,"/V"              ,  -inf,   inf, "top gate mobility modulation coefficient")
`MPRoo( mumtoff   ,   0.0     ,"V"               ,  -inf,   inf, "top gate mobility modulation voltage offset")
`MPRco( mumts     ,   1.0     ,""                ,   0.0,   inf, "top gate mobility modulation smoothing parameter")
`MPRco( mumte     ,   1.0     ,""                ,   0.0,   inf, "top gate mobility modulation exponent")
`MPRco( mumto     ,   0.0     ,"/V"              ,   0.0,   inf, "mumt geometry independent part")
`MPRoo( mumtl     ,   0.0     ,""                ,  -inf,   inf, "mumt 1/l     coefficient")
`MPRoo( mumtw     ,   0.0     ,""                ,  -inf,   inf, "mumt 1/w     coefficient")
`MPRoo( mumtlw    ,   0.0     ,""                ,  -inf,   inf, "mumt 1/(l*w) coefficient")
`MPRco( mumii1    ,   0.0     ,"/V^2"            ,   0.0,   inf, "linear    impact ionization mobility modulation coefficient")
`MPRnb( mumii1o   ,   0.0     ,"/V^2"                          , "mumii1 geometry independent part")
`MPRnb( mumii1l   ,   0.0     ,"/V^2"                          , "mumii1 1/l coefficient")
`MPRnb( mumii1le  ,   1.0     ,""                              , "mumii1 1/l exponent")
`MPRnb( mumii1w   ,   0.0     ,"/V^2"                          , "mumii1 1/w coefficient")
`MPRnb( mumii1we  ,   1.0     ,""                              , "mumii1 1/w exponent")
`MPRco( mumii2    ,   0.0     ,"/V^4"            ,   0.0,   inf, "quadratic impact ionization mobility modulation coefficient")
`MPRnb( mumii2o   ,   0.0     ,"/V^2"                          , "mumii2 geometry independent part")
`MPRnb( mumii2l   ,   0.0     ,"/V^2"                          , "mumii2 1/l coefficient")
`MPRnb( mumii2le  ,   1.0     ,""                              , "mumii2 1/l exponent")
`MPRnb( mumii2w   ,   0.0     ,"/V^2"                          , "mumii2 1/w coefficient")
`MPRnb( mumii2we  ,   1.0     ,""                              , "mumii2 1/w exponent")
`MPRoo( vcrit     ,   4.0     ,"V"               ,   0.0,   inf, "velocity saturation critical voltage")
`MPRoo( ecrito    ,   4.0e06  ,"V/m"             ,   0.0,   inf, "velocity saturation critical field geometry independent part")
`MPRoo( ecritw    ,   0.0     ,""                ,  -inf,   inf, "ecrit 1/w coefficient, also used for ecorn")
`MPRoo( vcorn     ,   0.4     ,"V"               ,   0.0,   inf, "velocity saturation corner voltage")
`MPRoo( ecorno    ,   0.4e06  ,"V/m"             ,   0.0,   inf, "velocity saturation corner field geometry independent part")
`MPRcc( du        ,   0.02    ,""                ,   0.0,1000.0, "mobility reduction at ecorn")
`MPRcc( voffspo   ,   0.0     ,""                ,   0.0, 100.0, "source pinchoff offset (number of nspo*phi_t)")
`MPRoc( moffspo   ,   1.0     ,""                ,   0.0,   1.0, "source pinchoff smoothing factor")

//
//  Thermal resistance and capacitance model parameters
//

`MPRco( gth       ,   0.0     ,"W/K"             ,   0.0,   inf, "thermal conductance")
`MPRco( gtho      ,   0.0     ,"W/K"             ,   0.0,   inf, "gth geometry independent part")
`MPRco( gthl      ,   0.0     ,"W/K/m"           ,   0.0,   inf, "gth length component")
`MPRco( gthw      ,   0.0     ,"W/K/m"           ,   0.0,   inf, "gth width  component")
`MPRco( gtha      ,   0.0     ,"W/K/m^2"         ,   0.0,   inf, "gth area component")
`MPRco( gthc      ,   0.0     ,"W/K"             ,   0.0,   inf, "gth contact component")
`MPRco( cth       ,   0.0     ,"s*W/K"           ,   0.0,   inf, "thermal capacitance")
`MPRco( ctho      ,   0.0     ,"s*W/K"           ,   0.0,   inf, "cth geometry independent part")
`MPRco( cthl      ,   0.0     ,"W/K/m"           ,   0.0,   inf, "cth length component")
`MPRco( cthw      ,   0.0     ,"W/K/m"           ,   0.0,   inf, "cth width  component")
`MPRco( ctha      ,   0.0     ,"s*W/K/m^2"       ,   0.0,   inf, "cth area component")
`MPRco( cthc      ,   0.0     ,"s*W/K"           ,   0.0,   inf, "cth contact component")

//
//  1/f noise model parameters
//

`MPRco( kfn       ,   0.0     ,"m^2"             ,   0.0,   inf, "flicker noise coefficient")
`MPRoo( afn       ,   2.0     ,""                ,   0.0,   inf, "flicker noise current exponent")
`MPRoo( bfn       ,   1.0     ,""                ,   0.0,   inf, "flicker noise 1/f exponent")

//
//  Temperature dependence model parameters
//

`MPRoo( tc1psirb  ,   0.0     ,"/K"              ,  -inf,   inf, "psirb linear         TC")
`MPRoo( tc2psirb  ,   0.0     ,"/K^2"            ,  -inf,   inf, "psirb quadratic      TC")
`MPRoo( tc1psirt  ,   0.0     ,"/K"              ,  -inf,   inf, "psirt linear         TC")
`MPRoo( tc2psirt  ,   0.0     ,"/K^2"            ,  -inf,   inf, "psirt quadratic      TC")
`MPRoo( tc1       ,   0.0     ,"/K"              ,  -inf,   inf, "resistance linear    TC")
`MPRoo( tc2       ,   0.0     ,"/K^2"            ,  -inf,   inf, "resistance quadratic TC")
`MPRoo( tc1o      ,   0.0     ,"/K"              ,  -inf,   inf, "tc1 geometry independent part")
`MPRoo( tc2o      ,   0.0     ,"/K^2"            ,  -inf,   inf, "tc2 geometry independent part")
`MPRoo( tc1w      ,   0.0     ,"m/K"             ,  -inf,   inf, "tc1 1/w     coefficient")
`MPRoo( tc2w      ,   0.0     ,"m/K^2"           ,  -inf,   inf, "tc2 1/w     coefficient")
`MPRoo( tc1l      ,   0.0     ,"m/K"             ,  -inf,   inf, "tc1 1/l     coefficient")
`MPRoo( tc2l      ,   0.0     ,"m/K^2"           ,  -inf,   inf, "tc2 1/l     coefficient")
`MPRoo( tc1lw     ,   0.0     ,"m^2/K"           ,  -inf,   inf, "tc1 1/(l*w) coefficient")
`MPRoo( tc2lw     ,   0.0     ,"m^2/K^2"         ,  -inf,   inf, "tc2 1/(l*w) coefficient")
`MPRoo( tsl       ,   0.0     ,"/K"              ,  -inf,   inf, "slope of resistance change vs. temperature at low  temperature")
`MPRoo( tsh       ,   0.0     ,"/K"              ,  -inf,   inf, "slope of resistance change vs. temperature at high temperature")
`MPRcc( tsct      , 100.0     ,"degC"            ,-100.0, 800.0, "critical temperature where resistance change slope goes from tsl to tsh")
`MPRco( tssm      ,  10.0     ,"degC"            ,   0.0,   inf, "resistance change slope smoothing parameter")
`MPRoo( tslo      ,   0.0     ,"/K"              ,  -inf,   inf, "tsl  geometry independent part")
`MPRoo( tsho      ,   0.0     ,"/K"              ,  -inf,   inf, "tsh  geometry independent part")
`MPRcc( tscto     , 100.0     ,"degC"            ,-100.0, 800.0, "tsct geometry independent part")
`MPRcc( tssmo     ,  10.0     ,"degC"            ,-100.0, 800.0, "tssm geometry independent part")
`MPRoo( tslw      ,   0.0     ,"m/K"             ,  -inf,   inf, "tsl  1/w     coefficient")
`MPRoo( tshw      ,   0.0     ,"m/K"             ,  -inf,   inf, "tsh  1/w     coefficient")
`MPRoo( tsctw     ,   0.0     ,"m*degC"          ,  -inf,   inf, "tsct 1/w     coefficient")
`MPRoo( tssmw     ,   0.0     ,"m*degC"          ,  -inf,   inf, "tssm 1/w     coefficient")
`MPRoo( tsll      ,   0.0     ,"m/K"             ,  -inf,   inf, "tsl  1/l     coefficient")
`MPRoo( tshl      ,   0.0     ,"m/K"             ,  -inf,   inf, "tsh  1/l     coefficient")
`MPRoo( tsctl     ,   0.0     ,"m*degC"          ,  -inf,   inf, "tsct 1/l     coefficient")
`MPRoo( tssml     ,   0.0     ,"m*degC"          ,  -inf,   inf, "tssm 1/l     coefficient")
`MPRoo( tsllw     ,   0.0     ,"m^2/K"           ,  -inf,   inf, "tsl  1/(l*w) coefficient")
`MPRoo( tshlw     ,   0.0     ,"m^2/K"           ,  -inf,   inf, "tsh  1/(l*w) coefficient")
`MPRoo( tsctlw    ,   0.0     ,"m^2*degC"        ,  -inf,   inf, "tsct 1/(l*w) coefficient")
`MPRoo( tssmlw    ,   0.0     ,"m^2*degC"        ,  -inf,   inf, "tssm 1/(l*w) coefficient")
`MPRoo( xbeta     ,   0.0     ,""                ,  -inf,   inf, "exponent for impact ionization current exponent temperature dependence")
`MPRoo( tegth     ,   0.0     ,""                ,  -inf,   inf, "thermal conductance temperature exponent")
`MPRoo( xvsat     ,   0.0     ,""                ,  -inf,   inf, "exponent for saturation velocity temperature dependence")
`MPRoo( xvsato    ,   0.0     ,""                ,  -inf,   inf, "xvsat geometry independent part")
`MPRoo( xvsatl    ,   0.0     ,""                ,  -inf,   inf, "xvsat 1/l coefficient")
`MPRco( xvsatle   ,   1.0     ,""                ,   0.0,   inf, "xvsat 1/l exponent")
`MPRoo( tc1kfn    ,   0.0     ,"/K"              ,  -inf,   inf, "flicker noise coefficient linear TC")

//
//  OP operating point parameters
//

//  --------------------------------------------------------------------------------------------------------------
//  Variables for operating point info
//  --------------------------------------------------------------------------------------------------------------

real id_op, is, ig, ib, P_D, facvsb, facvsb0, vth_i, vts_i, ids_i;
`OPP(ctype             ,""             ,"Flag for channel type")
`OPP(sdint             ,""             ,"Flag for source-drain interchange")
`OPM(ise               ,"A"            ,"Total source current")
`OPM(ige               ,"A"            ,"Total gate current")
`OPM(ide               ,"A"            ,"Total drain current")
`OPM(ibe               ,"A"            ,"Total bulk current")
`OPM(ids               ,"A"            ,"Drain current, excl. edge transistor currents, avalanche, tunnel, GISL, GIDL, and junction currents")
`OPM(idb               ,"A"            ,"Drain to bulk current")
`OPM(isb               ,"A"            ,"Source to bulk current")
`OPM(igs               ,"A"            ,"Gate-source tunneling current")
`OPM(igd               ,"A"            ,"Gate-drain tunneling current")
`OPM(igb               ,"A"            ,"Gate-bulk tunneling current")
`OPM(idedge            ,"A"            ,"Drain current of edge transistors")
`OPM(igcs              ,"A"            ,"Gate-channel tunneling current (source component)")
`OPM(igcd              ,"A"            ,"Gate-channel tunneling current (drain component)")
`OPM(iavl              ,"A"            ,"Substrate current due to weak avelanche")
`OPM(igisl             ,"A"            ,"Gate-induced source leakage current")
`OPM(igidl             ,"A"            ,"Gate-induced drain leakage current")
`OPM(ijs               ,"A"            ,"Total source junction current")
`OPM(ijsbot            ,"A"            ,"Source junction current (bottom component)")
`OPM(ijsgat            ,"A"            ,"Source junction current (gate-edge component)")
`OPM(ijssti            ,"A"            ,"Source junction current (STI-edge component)")
`OPM(ijd               ,"A"            ,"Total drain junction current")
`OPM(ijdbot            ,"A"            ,"Drain junction current (bottom component)")
`OPM(ijdgat            ,"A"            ,"Drain junction current (gate-edge component)")
`OPM(ijdsti            ,"A"            ,"Drain junction current (STI-edge component)")
`OPP(vds               ,"V"            ,"Drain-source voltage")
`OPP(vgs               ,"V"            ,"Gate-source voltage")
`OPP(vsb               ,"V"            ,"Source-bulk voltage")
`OPP(vto               ,"V"            ,"Zero-bias threshold voltage")
`OPP(vts               ,"V"            ,"Threshold voltage including back bias effects")
`OPP(vth               ,"V"            ,"Threshold voltage including back bias and drain bias effects")
`OPP(vgt               ,"V"            ,"Effective gate drive voltage including back bias and drain bias effects")
`OPP(vdss              ,"V"            ,"Drain saturation voltage at actual bias")
`OPP(vsat              ,""             ,"Saturation limit")
`OPM(gm                ,"S"            ,"Transconductance")
`OPM(gmb               ,"S"            ,"Substrate transconductance")
`OPM(gds               ,"S"            ,"Output conductance")
`OPM(gjs               ,"S"            ,"Source junction conductance")
`OPM(gjd               ,"S"            ,"Drain junction conductance")
`OPM(cdd               ,"F"            ,"Drain capacitance")
`OPM(cdg               ,"F"            ,"Drain-gate capacitance")
`OPM(cds               ,"F"            ,"Drain-source capacitance")
`OPM(cdb               ,"F"            ,"Drain-bulk capacitance")
`OPM(cgd               ,"F"            ,"Gate-drain capacitance")
`OPM(cgg               ,"F"            ,"Gate capacitance")
`OPM(cgs               ,"F"            ,"Gate-source capacitance")
`OPM(cgb               ,"F"            ,"Gate-bulk capacitance")
`OPM(csd               ,"F"            ,"Source-drain capacitance")
`OPM(csg               ,"F"            ,"Source-gate capacitance")
`OPM(css               ,"F"            ,"Source capacitance")
`OPM(csb               ,"F"            ,"Source-bulk capacitance")
`OPM(cbd               ,"F"            ,"Bulk-drain capacitance")
`OPM(cbg               ,"F"            ,"Bulk-gate capacitance")
`OPM(cbs               ,"F"            ,"Bulk-source capacitance")
`OPM(cbb               ,"F"            ,"Bulk capacitance")
`OPM(cgsol             ,"F"            ,"Total gate-source overlap capacitance")
`OPM(cgdol             ,"F"            ,"Total gate-drain overlap capacitance")
`OPM(cjs               ,"F"            ,"Total source junction capacitance")
`OPM(cjsbot            ,"F"            ,"Source junction capacitance (bottom component)")
`OPM(cjsgat            ,"F"            ,"Source junction capacitance (gate-edge component)")
`OPM(cjssti            ,"F"            ,"Source junction capacitance (STI-edge component)")
`OPM(cjd               ,"F"            ,"Total drain junction capacitance")
`OPM(cjdbot            ,"F"            ,"Drain junction capacitance (bottom component)")
`OPM(cjdgat            ,"F"            ,"Drain junction capacitance (gate-edge component)")
`OPM(cjdsti            ,"F"            ,"Drain junction capacitance (STI-edge component)")
`OPP(weff              ,"m"            ,"Effective channel width for geometrical models")
`OPP(leff              ,"m"            ,"Effective channel length for geometrical models")
`OPP(u                 ,""             ,"Transistor gain")
`OPD(rout              ,"Ohm"          ,"Small-signal output resistance")
`OPP(vearly            ,"V"            ,"Equivalent Early voltage")
`OPM(beff              ,"A/V^2"        ,"Gain factor")
`OPP(fug               ,"Hz"           ,"Unity gain frequency at actual bias")
`OPD(rg                ,"Ohm"          ,"Gate resistance")
`OPM(sfl               ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz")
`OPP(sqrtsff           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density at 1 kHz")
`OPP(sqrtsfw           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density")
`OPM(sid               ,"A^2/Hz"       ,"White noise current spectral density")
`OPP(fknee             ,"Hz"           ,"Cross-over frequency above which white noise is dominant")
`OPM(sigs              ,"A^2/Hz"       ,"Gate-source current noise spectral density")
`OPM(sigd              ,"A^2/Hz"       ,"Gate-drain current noise spectral density")
`OPM(siavl             ,"A^2/Hz"       ,"Impact ionization current noise spectral density")
`OPM(ssi               ,"A^2/Hz"       ,"Total source junction current noise spectral density")
`OPM(sdi               ,"A^2/Hz"       ,"Total drain junction current noise spectral density")
`OPM(sfledge           ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz of edge transistors")
`OPM(sidedge           ,"A^2/Hz"       ,"White noise current spectral density of edge transistors")

// local parameters after scaling, T-scaling, and clipping

`OPP(lp_vfb            ,"V"            ,"Local parameter vfb after T-scaling and clipping")
`OPP(lp_stvfb          ,"V/K"          ,"Local parameter stvfb after clipping")
`OPP(lp_st2vfb         ,"K^-1"         ,"Local parameter st2vfb after clipping")
`OPP(lp_tox            ,"m"            ,"Local parameter tox after clipping")
`OPP(lp_epsrox         ,""             ,"Local parameter epsrox after clipping")
`OPP(lp_neff           ,"m^-3"         ,"Local parameter neff after clipping")
`OPP(lp_facneffac      ,""             ,"Local parameter facneffac after clipping")
`OPP(lp_gfacnud        ,""             ,"Local parameter gfacnud after clipping")
`OPP(lp_vsbnud         ,"V"            ,"Local parameter vsbnud after clipping")
`OPP(lp_dvsbnud        ,"V"            ,"Local parameter dvsbnud after clipping")
`OPP(lp_vnsub          ,"V"            ,"Local parameter vnsub after clipping")
`OPP(lp_nslp           ,"V"            ,"Local parameter nslp after clipping")
`OPP(lp_dnsub          ,"V^-1"         ,"Local parameter dnsub after clipping")
`OPP(lp_dphib          ,"V"            ,"Local parameter dphib after clipping")
`OPP(lp_delvtac        ,"V"            ,"Local parameter delvtac after clipping")
`OPP(lp_np             ,"m^-3"         ,"Local parameter np after clipping")
`OPP(lp_toxov          ,"m"            ,"Local parameter toxov after clipping")
`OPP(lp_toxovd         ,"m"            ,"Local parameter toxovd after clipping")
`OPP(lp_toxovd2        ,"m"            ,"Local parameter toxovd2 after clipping")
`OPP(lp_nov            ,"m^-3"         ,"Local parameter nov after clipping")
`OPP(lp_novd           ,"m^-3"         ,"Local parameter novd after clipping")
`OPP(lp_novd2          ,"m^-3"         ,"Local parameter toxovd2 after clipping")
`OPP(lp_ct             ,""             ,"Local parameter ct after clipping")
`OPP(lp_ctg            ,""             ,"Local parameter ctg after clipping")
`OPP(lp_ctb            ,""             ,"Local parameter ctb after clipping")
`OPP(lp_stct           ,""             ,"Local parameter stct after clipping")
`OPP(lp_cf             ,""             ,"Local parameter cf after clipping")
`OPP(lp_cfd            ,"V^-1"         ,"Local parameter cfd after clipping")
`OPP(lp_cfb            ,"V^-1"         ,"Local parameter cfb after clipping")
`OPP(lp_psce           ,""             ,"Local parameter psce after clipping")
`OPP(lp_psceb          ,"V^-1"         ,"Local parameter psceb after clipping")
`OPP(lp_psced          ,"V^-1"         ,"Local parameter psced after clipping")
`OPP(lp_betn           ,"m^2/(V s)"    ,"Local parameter betn after T-scaling and clipping")
`OPP(lp_stbet          ,""             ,"Local parameter stbet after clipping")
`OPP(lp_mue            ,"m/V"          ,"Local parameter mue after T-scaling and clipping")
`OPP(lp_stmue          ,""             ,"Local parameter stmue after clipping")
`OPP(lp_themu          ,""             ,"Local parameter themu after T-scaling and clipping")
`OPP(lp_stthemu        ,""             ,"Local parameter stthemu after clipping")
`OPP(lp_cs             ,""             ,"Local parameter cs after T-scaling and clipping")
`OPP(lp_stcs           ,""             ,"Local parameter stcs after clipping")
`OPP(lp_thecs          ,""             ,"Local parameter thecs after T-scaling and clipping")
`OPP(lp_stthecs        ,""             ,"Local parameter stthecs after clipping")
`OPP(lp_xcor           ,"V^-1"         ,"Local parameter xcor after T-scaling and clipping")
`OPP(lp_stxcor         ,""             ,"Local parameter stxcor after clipping")
`OPP(lp_feta           ,""             ,"Local parameter feta after clipping")
`OPD(lp_rs             ,"Ohm"          ,"Local parameter rs after T-scaling and clipping")
`OPP(lp_strs           ,""             ,"Local parameter strs after clipping")
`OPP(lp_rsb            ,"V^-1"         ,"Local parameter rsb after clipping")
`OPP(lp_rsg            ,"V^-1"         ,"Local parameter rsg after clipping")
`OPP(lp_thesat         ,"V^-1"         ,"Local parameter thesat after T-scaling and clipping")
`OPP(lp_stthesat       ,""             ,"Local parameter stthesat after clipping")
`OPP(lp_thesatb        ,"V^-1"         ,"Local parameter thesatb after clipping")
`OPP(lp_thesatg        ,"V^-1"         ,"Local parameter thesatg after clipping")
`OPP(lp_ar             ,""             ,"Local parameter ar after clipping")
`OPP(lp_alp            ,""             ,"Local parameter alp after clipping")
`OPP(lp_alp1           ,"V"            ,"Local parameter alp1 after clipping")
`OPP(lp_alp2           ,"V^-1"         ,"Local parameter alp2 after clipping")
`OPP(lp_vp             ,"V"            ,"Local parameter vp after clipping")
`OPP(lp_a1             ,""             ,"Local parameter a1 after clipping")
`OPP(lp_a2             ,"V"            ,"Local parameter a2 after T-scaling and clipping")
`OPP(lp_sta2           ,""             ,"Local parameter sta2 after clipping")
`OPP(lp_a3             ,""             ,"Local parameter a3 after clipping")
`OPP(lp_a4             ,"1/sqrt(V)"    ,"Local parameter a4 after clipping")
`OPP(lp_gco            ,""             ,"Local parameter gco after clipping")
`OPM(lp_iginv          ,"A"            ,"Local parameter iginv after T-scaling and clipping")
`OPM(lp_igov           ,"A"            ,"Local parameter igov after T-scaling and clipping")
`OPM(lp_igovd          ,"A"            ,"Local parameter igovd after T-scaling and clipping")
`OPP(lp_stig           ,""             ,"Local parameter stig after clipping")
`OPP(lp_gc2            ,""             ,"Local parameter gc2 after clipping")
`OPP(lp_gc3            ,""             ,"Local parameter gc3 after clipping")
`OPP(lp_chib           ,"V"            ,"Local parameter chib after clipping")
`OPP(lp_agidl          ,"A/V^3"        ,"Local parameter agidl after clipping")
`OPP(lp_agidld         ,"A/V^3"        ,"Local parameter agidld after clipping")
`OPP(lp_bgidl          ,"V"            ,"Local parameter bgidl after T-scaling and clipping")
`OPP(lp_bgidld         ,"V"            ,"Local parameter bgidld after T-scaling and clipping")
`OPP(lp_stbgidl        ,"V/K"          ,"Local parameter stbgidl after clipping")
`OPP(lp_stbgidld       ,"V/K"          ,"Local parameter stbgidld after clipping")
`OPP(lp_cgidl          ,""             ,"Local parameter cgidl after clipping")
`OPP(lp_cgidld         ,""             ,"Local parameter cgidld after clipping")
`OPM(lp_cox            ,"F"            ,"Local parameter cox after clipping")
`OPM(lp_cgov           ,"F"            ,"Local parameter cgov after clipping")
`OPM(lp_cgovd          ,"F"            ,"Local parameter cgovd after clipping")
`OPM(lp_cgovd2         ,"F"            ,"Local parameter cgovd2 after clipping")
`OPM(lp_cgbov          ,"F"            ,"Local parameter cgbov after clipping")
`OPM(lp_cfr            ,"F"            ,"Local parameter cfr after clipping")
`OPM(lp_cfrd           ,"F"            ,"Local parameter cfrd after clipping")
`OPP(lp_fnt            ,""             ,"Local parameter fnt after clipping")
`OPP(lp_fntexc         ,""             ,"Local parameter fntexc after clipping")
`OPP(lp_nfa            ,"1/(V m^4)"    ,"Local parameter nfa after clipping")
`OPP(lp_nfb            ,"1/(V m^4)"    ,"Local parameter nfb after clipping")
`OPP(lp_nfc            ,"V^-1"         ,"Local parameter nfc after clipping")
`OPP(lp_ef             ,""             ,"Local parameter ef after clipping")
`OPP(lp_vfbedge        ,"V"            ,"Local parameter vfbedge after T-scaling and clipping")
`OPP(lp_stvfbedge      ,"V/K"          ,"Local parameter stvfbedge after clipping")
`OPP(lp_dphibedge      ,"V"            ,"Local parameter dphibedge after clipping")
`OPP(lp_neffedge       ,"m^-3"         ,"Local parameter neffedge after clipping")
`OPP(lp_ctedge         ,""             ,"Local parameter ctedge after clipping")
`OPP(lp_betnedge       ,"m^2/V/s"      ,"Local parameter betnedge after T-scaling and clipping")
`OPP(lp_stbetedge      ,""             ,"Local parameter stbetedge after clipping")
`OPP(lp_psceedge       ,""             ,"Local parameter psceedge after clipping")
`OPP(lp_pscebedge      ,"V^-1"         ,"Local parameter pscebedge after clipping")
`OPP(lp_pscededge      ,"V^-1"         ,"Local parameter pscededge after clipping")
`OPP(lp_cfedge         ,"V"            ,"Local parameter cfedge after clipping")
`OPP(lp_cfdedge        ,"V^-1"         ,"Local parameter cfdedge after clipping")
`OPP(lp_cfbedge        ,"V^-1"         ,"Local parameter cfbedge after clipping")
`OPP(lp_fntedge        ,""             ,"Local parameter fntedge after clipping")
`OPP(lp_nfaedge        ,"1/(V m^4)"    ,"Local parameter nfaedge after clipping")
`OPP(lp_nfbedge        ,"1/(V m^4)"    ,"Local parameter nfbedge after clipping")
`OPP(lp_nfcedge        ,"V^-1"         ,"Local parameter nfcedge after clipping")
`OPP(lp_efedge         ,""             ,"Local parameter efedge after clipping")
`OPD(lp_rg             ,"Ohm"          ,"Local parameter rge after clipping")
`OPD(lp_rjund          ,"Ohm"          ,"Local parameter rjund after clipping")
`OPP(pdiss             ,"w"            ,"Power dissipation")
`OPP(dtsh              ,"K"            ,"Temperature rise due to self heating")
`OPP(tk                ,"K"            ,"Device Temperature")
`OPM(cjosbot           ,"F"            ,"Bottom component of total zero-bias source junction capacitance at device temperature")
`OPM(cjossti           ,"F"            ,"STI-edge component of total zero-bias source junction capacitance at device temperature")
`OPM(cjosgat           ,"F"            ,"Gate-edge component of total zero-bias source junction capacitance at device temperature")
`OPP(vbisbot           ,"V"            ,"Built-in voltage of source-side bottom junction at device temperature")
`OPP(vbissti           ,"V"            ,"Built-in voltage of source-side STI-edge junction at device temperature")
`OPP(vbisgat           ,"V"            ,"Built-in voltage of source-side gate-edge junction at device temperature")
`OPM(idsatsbot         ,"A"            ,"Total source-side bottom junction saturation current")
`OPM(idsatssti         ,"A"            ,"Total source-side STI-edge junction saturation current")
`OPM(idsatsgat         ,"A"            ,"Total source-side gate-edge junction saturation current")
`OPM(cjosbotd          ,"F"            ,"Bottom component of total zero-bias drain junction capacitance at device temperature")
`OPM(cjosstid          ,"F"            ,"STI-edge component of total zero-bias drain junction capacitance at device temperature")
`OPM(cjosgatd          ,"F"            ,"Gate-edge component of total zero-bias drain junction capacitance at device temperature")
`OPP(vbisbotd          ,"V"            ,"Built-in voltage of drain-side bottom junction at device temperature")
`OPP(vbisstid          ,"V"            ,"Built-in voltage of drain-side STI-edge junction at device temperature")
`OPP(vbisgatd          ,"V"            ,"Built-in voltage of drain-side gate-edge junction at device temperature")
`OPM(idsatsbotd        ,"A"            ,"Total drain-side bottom junction saturation current")
`OPM(idsatsstid        ,"A"            ,"Total drain-side STI-edge junction saturation current")
`OPM(idsatsgatd        ,"A"            ,"Total drain-side gate-edge junction saturation current")

analog begin : psphvModel

//  --------------------------------------------------------------------------------------------------------------
//  Variables
//  --------------------------------------------------------------------------------------------------------------

// Variables for switch (initial_model parts)

    integer CHNL_TYPE;

// Instance local variables

    real NF_i, invNF, L_i, W_i, SA_i, SB_i, SD_i, SC_i, XGW_i, SCA_i, SCB_i, SCC_i, NGCON_i, MULT_i, FACTUO_i, DELVTO_i;
    real FACTUOEDGE_i, DELVTOEDGE_i;


// Variables of clipped global model parameters

    real TOXO_i, EPSROXO_i, NSUBO_i, WSEG_i, NPCK_i, WSEGP_i, LPCK_i, TOXOVO_i, TOXOVDO_i, TOXOVD2O_i, LOV_i, LP1_i, LP2_i, WBET_i;
    real ARL_i, ALP1L2_i, ALP2L2_i, SAREF_i, SBREF_i, KVSAT_i, LLODKUO_i, WLODKUO_i, LLODVTH_i, WLODVTH_i, LODETAO_i, SCREF_i;
    real WEB_i, WEC_i, RSHG_i, RINT_i, RVPOLY_i, NSUBEDGEO_i, LPEDGE_i;

// Variables of local model parameters

    real VFB_p, STVFB_p, ST2VFB_p, TOX_p, EPSROX_p, NEFF_p, FACNEFFAC_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, VNSUB_p, NSLP_p, DNSUB_p;
    real DPHIB_p, DELVTAC_p, NP_p, CT_p, CTG_p, CTB_p, STCT_p, TOXOV_p, TOXOVD_p, TOXOVD2_p, NOVD2_p, NOV_p, NOVD_p, PSCE_p, PSCED_p, PSCEB_p, CF_p;
    real CFD_p, CFB_p, BETN_p, STBET_p, MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, THECS_p, STTHECS_p, XCOR_p, STXCOR_p;
    real FETA_p, RS_p, STRS_p, RSB_p, RSG_p, THESAT_p, STTHESAT_p, THESATB_p, THESATG_p, AR_p, ALP_p, ALP1_p, ALP2_p, VP_p, A1_p;
    real A2_p, STA2_p, A3_p, A4_p, GCO_p, IGINV_p, IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, CHIB_p, AGIDL_p, AGIDLD_p, BGIDL_p, BGIDLD_p;
    real STBGIDL_p, STBGIDLD_p, CGIDL_p, CGIDLD_p, COX_p, CGOV_p, CGOVD_p, CGOVD2_p, CGBOV_p, CFR_p, CFRD_p, FNT_p, FNTEXC_p, NFA_p, NFB_p, NFC_p;
    real EF_p, VFBEDGE_p, STVFBEDGE_p, DPHIBEDGE_p, NEFFEDGE_p, CTEDGE_p, BETNEDGE_p, STBETEDGE_p, PSCEEDGE_p, PSCEBEDGE_p, PSCEDEDGE_p;
    real CFEDGE_p, CFDEDGE_p, CFBEDGE_p, FNTEDGE_p, NFAEDGE_p, NFBEDGE_p, NFCEDGE_p, EFEDGE_p, RGE_p;
    real RJUNS_p, RBULK_p, RJUND_p, RJUNX_p;

// Variables of clipped local model parameters

    real TR_i, VFB_i, STVFB_i, ST2VFB_i, STCT_i, TOX_i, EPSROX_i, NEFF_i, FACNEFFAC_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, VNSUB_i, NSLP_i;
    real DNSUB_i, DPHIB_i, DELVTAC_i, NP_i, CT_i, CTG_i, CTB_i, TOXOV_i, TOXOVD_i, TOXOVD2_i, NOVD2_i, NOV_i, NOVD_i, CF_i, CFD_i, CFB_i, PSCE_i, PSCEB_i, PSCED_i;
    real BETN_i, STBET_i, MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, THECS_i, STTHECS_i, XCOR_i, STXCOR_i, FETA_i, RS_i, STRS_i;
    real RSB_i, RSG_i, THESAT_i, STTHESAT_i, THESATB_i, THESATG_i, AR_i, ALP_i, ALP1_i, ALP2_i, VP_i, A1_i, A2_i, STA2_i, A3_i, A4_i;
    real GCO_i, IGINV_i, IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, CHIB_i, AGIDL_i, AGIDLD_i, BGIDL_i, BGIDLD_i, STBGIDL_i, STBGIDLD_i;
    real CGIDL_i, CGIDLD_i, COX_i, CGOV_i, CGOVD_i, CGOVD2_i, CGBOV_i, CFR_i, CFRD_i, FNT_i, FNTEXC_i, NFA_i, NFB_i, NFC_i, EF_i, VFBEDGE_i;
    real STVFBEDGE_i, DPHIBEDGE_i, NEFFEDGE_i, CTEDGE_i, BETNEDGE_i, STBETEDGE_i, PSCEEDGE_i, PSCEBEDGE_i, PSCEDEDGE_i, CFEDGE_i;
    real CFDEDGE_i, CFBEDGE_i, FNTEDGE_i, NFAEDGE_i, NFBEDGE_i, NFCEDGE_i, EFEDGE_i, RGE_i, RJUNS_i, RBULK_i, RJUND_i, RJUNX_i;

// Variables for scaling rules

    real iL, iW, delLPS, delWOD, LE, WE, LEcv, WEcv, Lcv, Wcv, iLE, iWE, L_f, L_slif, W_f, XGWE, NSUB0e, NPCKe, LPCKe, AA, BB, NSUB;
    real FBET1e, LP1e, GPE, GWE, tmpx, Lnoi, Lred, WE_edge, iWE_edge, GPE_edge, KVTHOWE, KUOWE;

// Variables for general temperature scaling

    real TKR, TKA, rTa, delTa, phita, inv_phita, TKD, TKD_sq, delT, rTn, ln_rTn, inv_phit, Eg, phibFac;

// source/bulk and drain/bulk junction diode variables

    real tRefKj, phi_tj, alphabrj, egTrefj, egTdevj;
    real vLin, invnPhit, inv2Phit, sq2Phit, sq2Phitr;
    real csrh, ctat, aTAT, bTATfctr, cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer;

//
//  NOTE: the i4Noise quantities below are not used, the standard 2*q*I from PSP is used instead
//

    real ABSOURCE_i, LSSOURCE_i, LGSOURCE_i;
    real idsatbot, idsatsti, idsatgat;
    real iIkbot, iIksti, iIkgat;
    real cjobot, cjosti, cjogat;
    real vbibot, vbisti, vbigat;
    real w0bot, w0sti, w0gat;
    real pd1mpbot, pd1mpsti, pd1mpgat;
    real vbbtLimbot, vbbtLimsti, vbbtLimgat;
    real i4Qdiffbot, i4Noisebot, i4Qdiffsti, i4Noisesti, i4Qdiffgat, i4Noisegat;

    real ABDRAIN_i, LSDRAIN_i, LGDRAIN_i;
    real idsatbot_d, idsatsti_d, idsatgat_d;
    real iIkbot_d, iIksti_d, iIkgat_d;
    real cjobot_d, cjosti_d, cjogat_d;
    real vbibot_d, vbisti_d, vbigat_d;
    real w0bot_d, w0sti_d, w0gat_d;
    real pd1mpbot_d, pd1mpsti_d, pd1mpgat_d;
    real vbbtLimbot_d, vbbtLimsti_d, vbbtLimgat_d, stvbr_d, stfbbt_d;
    real i4Qdiffbot_d, i4Noisebot_d, i4Qdiffsti_d, i4Noisesti_d, i4Qdiffgat_d, i4Noisegat_d;

    real ABDRAINX_i, LSDRAINX_i;
    real idsatbot_x, idsatsti_x;
    real iIkbot_x, iIksti_x;
    real cjobot_x, cjosti_x;
    real vbibot_x, vbisti_x;
    real w0bot_x, w0sti_x;
    real pd1mpbot_x, pd1mpsti_x;
    real vbbtLimbot_x, vbbtLimsti_x;
    real i4Qdiffbot_x, i4Noisebot_x, i4Qdiffsti_x, i4Noisesti_x;



// Local parameters after temperature scaling and variables used in self heating effect

    real VFB_T, CT_T, CTG_T, BETN_T, MUE_T, THEMU_T, CS_T, THECS_T, XCOR_T, RS_T, BGIDL_T, BGIDLD_T, A2_T, VFBEDGE_T, BETNEDGE_T;

// Variables for channel temperature scaling (including self heating effect)

    real phib_dc, G_0_dc, kpp, npp, arg2max, qlim2, qb0, dphibq, sqrt_phib_dc, phix_dc, aphi_dc, bphi_dc, phix2, phix1_dc, alpha_b;
    real us1, us21, phib_ac, G_0_ac, phix_ac, aphi_ac, bphi_ac, phix1_ac, tf_ct, tf_bet, tf_mue, tf_cs, tf_xcor, tf_ther, THER_i, tf_thesat;
    real tf_betedge, phibedge, Gfedge, phixedge, aphiedge, bphiedge, phix2edge, phix1edge;

// Variables used in instance initializing

    real EPSSI, EPSOX, CoxPrime, tox_sq, Cox_over_q, NEFFAC_i, qq, E_eff0, eta_mu, eta_mu1, inv_VP, GOV_s;
    real GOV_d, GOV2_s, GOV2_d, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s, inv_CHIB, B_fact, BCH;
    real inv_Gf2d, xid, inv_xid, margind, delta_novd;
    real inv_Gf2d2, xid2, inv_xid2, margind2, delta_novd2, GOV_d2, GOV2_d2;
    real phib_ov_d, phix_ov_d, lphi_ov_d, aphi_ov_d, xn_ov_d, xn_ov_d2;
    real Qgd_ov_b, Qgd_ov_d, Qgd2_ov, Qgd2_ov_b, Qgd2_ov_d, VgdxPrime, VdxbPrime, xi0ovd, Eovd, Dovd, Povd, sqrtPovd, vfbovd_i;
    real tmp_uss, kv_uss, kvv_uss, kvv2_uss;
    real BOV, BOV_d, GCQ, tf_ig, AGIDLs, AGIDLDs, BGIDLs, BGIDLDs, fac_exc;

// Variables for bias affectation

    real Vgs, Vds, Vsb, Vdb, Vgb, Vjun_s, Vjun_d, Vjun_x, VgsPrime, VsbPrime, VdbPrime, VgdPrime, Vds_ii, VdsPrime, VdsPrime_ld, gf_per_w;
    real Vdsx, vdscale_i, vdscaleb_i, stvdscale_i, a3cvd_i, a3cvd_t, sta3cvd_i;

// Global variables used in PSP103_SPCalculation.include

    real Vgbstar, Vgb1, Vdsp, delVg, Vdsat_lim, Vdsat;

// Global variables used in current and charge calculations

    real xgs_ov, xgd_ov, xgd2_ov, Vovd2, xd2_ov, Vsbstar_dc, Vsbstar_dc_tmp, Vmb, us, usnew, Vmbnew, qeff1_dc, Voxm_dc, GdL_dc, eta_p_dc, x_ds_dc;
    real x_m_dc, Gf_dc, Vdsat_dc, Udse_dc, SP_OV_xg, xs_ov, xd_ov, Vovs, Vovd, zg, TP, Fs1, Fs2, Fs3, Fs, Vm, Dch, arg2mina, psi_t, arg1;
    real Dsi, Dgate, Igc0, igc, igcd_h, u0, x, u0_div_H, Bg, Ag, xsq, inv_x, ex, inv_ex, Sg, Igc, Igb, Vtovd, Igidl, Vtovs, Igisl;
    real delVsat, Vsbstar_ac, xg_ac, qeff1_ac, Voxm_ac, alpha_ac, dps_ac, qim_ac, GdL_ac, H_ac, QG, QI, QD, QB, Fj, Fj2;
    real QCLM, Qg, Qd, Qb, Qs, Qgs_ov, Qgd_ov, Qgb_ov, Qfgs, Qfgd;

// Global variables used in macros

    real tme1, tme2;
    real inv_GOV, SP_OV_eps, SP_OV_delta;
    real Q_EDGE_xsth, Q_EDGE_xth0, Q_EDGE_xth, Q_EDGE_n, Q_EDGE_n_inv, Q_EDGE_xgt, Q_EDGE_xgt0, Q_EDGE_xgt0e, Q_EDGE_qi0si, Q_EDGE_qi0;
    real Q_EDGE_exp_x, Q_EDGE_d0, Q_EDGE_d0p, Q_EDGE_sqerr, Q_EDGE_errq;

// Global variables used in noise section

    real N1, Nm1, Delta_N1, Sfl, t1, sqt2, t2, r, lc, lcinv2, g_ideal, mid, temp2_exc, wsat_exc, temp_exc, thesat1_exc, zsat_exc, Gvsat_exc;
    real gfac, Sidexc, sqid, shot_igcsx, shot_igcdx, shot_igsov, shot_igdov, shot_iavl, jnoisex_s, jnoisex_d;
    real shot_igs, shot_igd, anoisedge, N1edge, Nm1edge, Delta_N1edge, H0edge, t1edge, sqt2edge, t2edge, redge, lcedge, lcinv2edge;
    real g_idealedge;

    real mMod, vdsScale, vdi0_i, vdisl_i, vdislg_i;
    real dt_et, Vsp, Vdsatdr, Idsdr, lFactor, aFactor, tiniK, tdevC, tdevK, phi_t, ni, rT, dT;
    real wdrift_m, ldrift_m, lgdov_m, lgdovq_m, lgdov2_m, lth_m, wth_m;
    real a_m2, weff_m, leff_m, delr_rsh;
    real trdr, gamma, psirb_t, psirt_t, atspo, nspofac;
    real iw, il, iw_fac, il_fac;
    real geff;
    real diblo, clm2o, expmvoff;
    real gzd, dfac, gf, gth_t;
    real beta_t, iiFac;
    real Vdsdr, Vgbs, Vgbd, Vgts, Vgtd, tcr, tcrref, tcvsat, kfn_t;
    real vcrit_t, vcorn_t, vcrneff, dufctr, uoff, invDv, ivcrit;
    real Ipgbs, Ipgbd, Ipgts, Ipgtd;
    real tambC, tambK, Irth;
    real Qcth;
    real tc1_i, tc2_i, gth_i, cth_i, alphab_i, alphat_i, mumii1_i, mumii2_i, xvsat_i, nspo_i, axs_i, ats_i;
    real diblb_i, diblt_i, clm1_i, clm2_i, psirb_i, dfb_i, psirt_i, dft_i, vcrit_i, vcorn_i;
    real mumt_i, mumb_i, tsl_i, tshl_i, tsct_i, tssmsq_i;

    real qDiffs, qDiffd, qDiffx;
`ifdef diodeReverseRecovery
    real qDiffEqs, qDiffEqd, qDiffEqx;
`endif

//  --------------------------------------------------------------------------------------------------------------
//  Definition of bias/instance independent model variables
//  --------------------------------------------------------------------------------------------------------------

    begin : initial_model

`ifdef compilerDoesNotHandleMfactorProperly
        mMod     =  1.0;
`else
        mMod     =  $mfactor;
`endif

// Clipping and rounding of switch parameters

        if (type >= 0) begin
            CHNL_TYPE   = `NMOS;
        end else begin
            CHNL_TYPE   = `PMOS;
        end
        EPSSI       = `P_EPS0_NIST2002 * `EPSRSI_PSP;

// Clipping of global model parameters

        TOXO_i      = `MAX(toxo, 1.0e-10);
        EPSROXO_i   = `MAX(epsroxo, 1.0);
        NSUBO_i     = `MAX(nsubo, 1.0e20);
        WSEG_i      = `MAX(wseg, 1.0e-10);
        NPCK_i      = `MAX(npck, 0.0);
        WSEGP_i     = `MAX(wsegp, 1.0e-10);
        LPCK_i      = `MAX(lpck, 1.0e-10);
        TOXOVO_i    = `MAX(toxovo, 1.0e-10);
        TOXOVDO_i   = `MAX(toxovdo, 1.0e-10);
        TOXOVD2O_i  = `MAX(toxovd2o, 1.0e-10);
        LOV_i       = `MAX(lov, 0.0);
        LP1_i       = `MAX(lp1, 1.0e-10);
        LP2_i       = `MAX(lp2, 1.0e-10);
        WBET_i      = `MAX(wbet, 1.0e-10);
        ARL_i       = `MAX(arl, 0.0);
        ALP1L2_i    = `MAX(alp1l2, 0.0);
        ALP2L2_i    = `MAX(alp2l2, 0.0);
        SAREF_i     = `MAX(saref, 1.0e-9);
        SBREF_i     = `MAX(sbref, 1.0e-9);
        KVSAT_i     = `CLAMP(kvsat, -1.0, 1.0);
        LLODKUO_i   = `MAX(llodkuo, 0.0);
        WLODKUO_i   = `MAX(wlodkuo, 0.0);
        LLODVTH_i   = `MAX(llodvth, 0.0);
        WLODVTH_i   = `MAX(wlodvth, 0.0);
        LODETAO_i   = `MAX(lodetao, 0.0);
        SCREF_i     = `MAX(scref, 0.0);
        WEB_i       =  web;
        WEC_i       =  wec;
        RSHG_i      = `MAX(rshg, 0.0);
        RINT_i      = `MAX(rint, 0.0);
        RVPOLY_i    = `MAX(rvpoly, 0.0);
        NSUBEDGEO_i = `MAX(nsubedgeo, 1.0e20);
        LPEDGE_i    = `MAX(lpedge, 1.0e-10);

// Transistor temperature

        TR_i        = `MAX(tr, -273.0);
        TKR         = `P_CELSIUS0 + TR_i;
        TKA         =  $temperature + dta;
        rTa         =  TKA / TKR;
        delTa       =  TKA - TKR;
        phita       =  TKA * `P_K_NIST2002 / `P_Q_OLD;
        inv_phita   =  1.0 / phita;


        lFactor  =  (1.0-0.01*shrink)*scale;            // linear dimension conversion factor
        aFactor  =  lFactor*lFactor;                    // area conversion factor
        tiniK    = `P_CELSIUS0+tr;
        if (swgeo) begin // global geometry model
            if ($param_given(dfbo)||$param_given(psirbo)) begin
                if (!($param_given(dfbo)&&$param_given(psirbo))) begin
                    $error("ERROR (psphv): dfbo and psirbo must both be specified if either one of them is");
                end
            end
            if ($param_given(dfto)||$param_given(psirto)) begin
                if (!($param_given(dfto)&&$param_given(psirto))) begin
                    $error("ERROR (psphv): dfto and psirto must both be specified if either one of them is");
                end
            end
        end else begin   // local  geometry model
            if ($param_given(dfb)||$param_given(psirb)) begin
                if (!($param_given(dfb)&&$param_given(psirb))) begin
                    $error("ERROR (psphv): dfb and psirb must both be specified if either one of them is");
                end
            end
            if ($param_given(dft)||$param_given(psirt)) begin
                if (!($param_given(dft)&&$param_given(psirt))) begin
                    $error("ERROR (psphv): dft and psirt must both be specified if either one of them is");
                end
            end
        end
        delr_rsh =  1.0;
    end // initial_model

//  --------------------------------------------------------------------------------------------------------------
//  Definition of instance dependent and bias independent variables
//  --------------------------------------------------------------------------------------------------------------

    begin : initial_instance

// Declaration of local variables

        real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
        real temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

// Instance variables

        NF_i        =  1.0;
        invNF       =  1.0;
        LE          =  0.0;
        WE          =  0.0;
        if ($param_given(l)) begin
            L_i         =  l*lFactor;
        end else begin
            L_i         =  l;
        end
        if ($param_given(w)) begin
            W_i         =  w*lFactor;
        end else begin
            W_i         =  w;
        end
        SA_i        =  sa*lFactor;
        SB_i        =  sb*lFactor;
        SD_i        =  sd*lFactor;
        SC_i        =  sc*lFactor;
        if ($param_given(xgw)) begin
            XGW_i       =  xgw*lFactor;
        end else begin
            XGW_i       =  xgw;
        end
        if ($param_given(wdrift) || $param_given(w)) begin
            wdrift_m    =  wdrift*lFactor;
        end else begin
            wdrift_m    =  wdrift;
        end
        if ($param_given(ldrift)) begin
            ldrift_m    =  ldrift*lFactor;
        end else begin
            ldrift_m    =  ldrift;
        end
        if ($param_given(lgdov)) begin
            lgdov_m     =  lgdov*lFactor;
        end else begin
            lgdov_m     =  lgdov;
        end
        lgdov2_m    =  lgdov2*lFactor;
        wth_m       =  (w+wdrift)*lFactor;
        lth_m       =  2.0*(l+lgdov+ldrift)*lFactor;
        a_m2        =  (w*l+wdrift*(lgdov+ldrift))*aFactor;
        lgdovq_m    =  `MAX(lgdov_m+xlgdovq, 0.0);

// Clipping of the instance parameters

        if ((swgeo == 1)) begin
            NF_i        = `MAX(nf, 1.0);
            NF_i        =  floor(NF_i + 0.5); // round to nearest integer
            invNF       =  1.0 / NF_i;
        end
        L_i          = `MAX(L_i, 1.0e-9);
        W_i          = `MAX(W_i * invNF, 1.0e-9);
        SCA_i        = `MAX(sca, 0.0);
        SCB_i        = `MAX(scb, 0.0);
        SCC_i        = `MAX(scc, 0.0);
        NGCON_i      =  (ngcon < 1.5) ? 1.0 : 2.0;

// Geometrical device variables
// Transistor geometry

        iL           = `LEN / L_i;
        iW           = `WEN / W_i;
        delLPS       =  lvaro * (1.0 + lvarl * iL) * (1.0 + lvarw * iW);
        delWOD       =  wvaro * (1.0 + wvarl * iL) * (1.0 + wvarw * iW);
        LE           = `MAX(L_i + delLPS - 2.0 * lap, 1.0e-9);
        WE           = `MAX(W_i + delWOD - 2.0 * wot, 1.0e-9);
        LEcv         = `MAX(L_i + delLPS - 2.0 * lap + dlq, 1.0e-9);
        WEcv         = `MAX(W_i + delWOD - 2.0 * wot + dwq, 1.0e-9);
        Lcv          = `MAX(L_i + delLPS + dlq, 1.0e-9);
        Wcv          = `MAX(W_i + delWOD + dwq, 1.0e-9);
        iLE          = `LEN / LE;
        iWE          = `WEN / WE;

// Geometry for multi-finger devices

        L_f          = `MAX(L_i + delLPS, 1.0e-9);
        L_slif       = `MAX(L_f + dlsil, 1.0e-9);
        W_f          = `MAX(W_i + delWOD, 1.0e-9);
        XGWE         = `MAX(XGW_i - 0.5 * delWOD, 1.0e-9);

// Local model parameters

        VFB_p        =  vfb;
        STVFB_p      =  stvfb;
        ST2VFB_p     =  st2vfb;
        TOX_p        =  tox;
        EPSROX_p     =  epsrox;
        NEFF_p       =  neff;
        FACNEFFAC_p  =  facneffac;
        GFACNUD_p    =  gfacnud;
        VSBNUD_p     =  vsbnud;
        DVSBNUD_p    =  dvsbnud;
        VNSUB_p      =  vnsub;
        NSLP_p       =  nslp;
        DNSUB_p      =  dnsub;
        DPHIB_p      =  dphib;
        DELVTAC_p    =  delvtac;
        NP_p         =  np;
        TOXOV_p      =  toxov;
        TOXOVD_p     =  toxovd;
        TOXOVD2_p    =  toxovd2;
        NOV_p        =  nov;
        NOVD_p       =  novd;
        NOVD2_p      =  novd2;
        CT_p         =  ct;
        CTG_p        =  ctg;
        CTB_p        =  ctb;
        STCT_p       =  stct;
        PSCE_p       =  psce;
        PSCED_p      =  psced;
        PSCEB_p      =  psceb;
        CF_p         =  cf;
        CFD_p        =  cfd;
        CFB_p        =  cfb;
        BETN_p       =  betn;
        STBET_p      =  stbet;
        MUE_p        =  mue;
        STMUE_p      =  stmue;
        THEMU_p      =  themu;
        STTHEMU_p    =  stthemu;
        CS_p         =  cs;
        STCS_p       =  stcs;
        THECS_p      =  thecs;
        STTHECS_p    =  stthecs;
        XCOR_p       =  xcor;
        STXCOR_p     =  stxcor;
        FETA_p       =  feta;
        RS_p         =  rs;
        STRS_p       =  strs;
        RSB_p        =  rsb;
        RSG_p        =  rsg;
        THESAT_p     =  thesat;
        STTHESAT_p   =  stthesat;
        THESATB_p    =  thesatb;
        THESATG_p    =  thesatg;
        AR_p         =  ar;
        ALP_p        =  alp;
        ALP1_p       =  alp1;
        ALP2_p       =  alp2;
        VP_p         =  vp;
        A1_p         =  a1;
        A2_p         =  a2;
        STA2_p       =  sta2;
        A3_p         =  a3;
        A4_p         =  a4;
        GCO_p        =  gco;
        IGINV_p      =  iginv;
        IGOV_p       =  igov;
        IGOVD_p      =  igovd;
        STIG_p       =  stig;
        GC2_p        =  gc2;
        GC3_p        =  gc3;
        CHIB_p       =  chib;
        AGIDL_p      =  agidl;
        AGIDLD_p     =  agidld;
        BGIDL_p      =  bgidl;
        BGIDLD_p     =  bgidld;
        STBGIDL_p    =  stbgidl;
        STBGIDLD_p   =  stbgidld;
        CGIDL_p      =  cgidl;
        CGIDLD_p     =  cgidld;
        COX_p        =  cox;
        CGOV_p       =  cgov;
        CGOVD_p      =  cgovd;
        CGOVD2_p     =  cgovd2;
        CGBOV_p      =  cgbov;
        CFR_p        =  cfr;
        CFRD_p       =  cfrd;
        FNT_p        =  fnt;
        FNTEXC_p     =  fntexc;
        NFA_p        =  nfa;
        NFB_p        =  nfb;
        NFC_p        =  nfc;
        EF_p         =  ef;
        VFBEDGE_p    =  vfbedge;
        STVFBEDGE_p  =  stvfbedge;
        DPHIBEDGE_p  =  dphibedge;
        NEFFEDGE_p   =  neffedge;
        CTEDGE_p     =  ctedge;
        BETNEDGE_p   =  betnedge;
        STBETEDGE_p  =  stbetedge;
        PSCEEDGE_p   =  psceedge;
        PSCEBEDGE_p  =  pscebedge;
        PSCEDEDGE_p  =  pscededge;
        CFEDGE_p     =  cfedge;
        CFDEDGE_p    =  cfdedge;
        CFBEDGE_p    =  cfbedge;
        FNTEDGE_p    =  fntedge;
        NFAEDGE_p    =  nfaedge;
        NFBEDGE_p    =  nfbedge;
        NFCEDGE_p    =  nfcedge;
        EFEDGE_p     =  efedge;
        RGE_p         =  rge;
        RJUND_p      =  rjund;
        RJUNS_p      =  rjuns;
        RJUNX_p      =  rjunx;
        RBULK_p      =  rbulk;

// Geometry scaling with physical scaling rules

        if (swgeo == 1) begin

// Process parameters

            VFB_p        =  vfbo + vfbl * iLE + vfbw * iWE + vfblw * iLE * iWE;
            STVFB_p      =  stvfbo + stvfbl * iLE + stvfbw * iWE + stvfblw * iLE * iWE;
            ST2VFB_p     =  st2vfbo;
            TOX_p        =  toxo;
            EPSROX_p     =  epsroxo;
            NSUB0e       =  NSUBO_i * `MAX(( 1.0 + nsubw * iWE * ln( 1.0 + WE / WSEG_i )), 1.0e-03);
            NPCKe        =  NPCK_i * `MAX(( 1.0 + npckw * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0e-03);
            LPCKe        =  LPCK_i * `MAX(( 1.0 + lpckw * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0e-03);
            if (xpck == 1) begin
                if (LE > LPCKe) begin
                    AA         = 7.5e10;
                    BB         = sqrt(NSUB0e + NPCKe) - sqrt(NSUB0e);
                    NSUB       = sqrt(NSUB0e) + AA * ln(1 + LPCKe / LE * (exp(BB / AA) -1));
                    NSUB       = NSUB * NSUB;
                end else begin
                    NSUB       = NSUB0e + NPCKe;
                end
            end else begin
                if (xpck == 2) begin
                    if (LE > (2.0 * LPCKe)) begin
                        AA           =  7.5e10;
                        BB           =  sqrt(NSUB0e + 0.5 * NPCKe) - sqrt(NSUB0e);
                        NSUB         =  sqrt(NSUB0e) + AA * ln(1.0 + 2.0 * LPCKe / LE * (exp(BB / AA) - 1.0));
                        NSUB         =  NSUB * NSUB;
                    end else begin
                        if (LE >= LPCKe) begin
                            NSUB          =  NSUB0e + NPCKe * LPCKe / LE;
                        end else begin // LE < lpck
                            NSUB          =  NSUB0e + NPCKe * (2.0 - LE / LPCKe);
                        end
                    end
                end else begin
                    NSUB          =  NSUB0e;
                end
            end
            NEFF_p       =  NSUB * (1.0 - fol1 * iLE - fol2 * iLE * iLE);
            FACNEFFAC_p  =  facneffaco + facneffacl * iLE + facneffacw * iWE + facneffaclw * iLE * iWE;
            GFACNUD_p    =  gfacnudo + gfacnudl * pow(iLE, gfacnudlexp) + gfacnudw * iWE + gfacnudlw * iLE * iWE;
            VSBNUD_p     =  vsbnudo;
            DVSBNUD_p    =  dvsbnudo;
            VNSUB_p      =  vnsubo;
            NSLP_p       =  nslpo;
            DNSUB_p      =  dnsubo;
            DPHIB_p      =  dphibo + dphibl * pow(iLE, dphiblexp) + dphibw * iWE + dphiblw * iLE * iWE;
            DELVTAC_p    =  delvtaco + delvtacl * pow(iLE, delvtaclexp) + delvtacw * iWE + delvtaclw * iLE * iWE;
            NP_p         =  npo * `MAX(1.0e-6, (1.0 + npl * iLE));
            TOXOV_p      =  toxovo;
            TOXOVD_p     =  toxovdo;
            TOXOVD2_p    =  toxovd2o;
            NOV_p        =  novo;
            NOVD_p       =  novdo;
            NOVD2_p      =  novd2o;

// Interface states parameters

            CT_p         =  (cto + ctl * pow(iLE, ctlexp)) * (1.0 + ctw * iWE) * (1.0 + ctlw * iLE * iWE);
            CTG_p        =  ctgo;
            CTB_p        =  ctbo;
            STCT_p       =  stcto;

// DIBL parameters

            CF_p         =  cfl * pow(iLE, cflexp) * (1.0 + cfw * iWE);
            CFD_p        =  cfdo;
            CFB_p        =  cfbo;

// Subthreshold slope parameters of short channel transistor

            PSCE_p       =  pscel * pow(iLE, pscelexp) * (1.0 + pscew * iWE);
            PSCED_p      =  pscedo;
            PSCEB_p      =  pscebo;

// Mobility parameters

            FBET1e       =  fbet1 * (1.0 + fbet1w * iWE);
            LP1e         =  LP1_i * `MAX(1.0 + lp1w * iWE, 1.0e-03);
            GPE          =  1.0 + FBET1e * LP1e / LE * (1.0 - exp(-LE / LP1e)) + fbet2 * LP2_i / LE * (1.0 - exp(-LE / LP2_i));
            GPE          = `MAX(GPE, 1.0e-15);
            GWE          =  1.0 + betw1 * iWE + betw2 * iWE * ln(1.0 + WE / WBET_i);
            BETN_p       =  uo * WE / (GPE * LE) * GWE;
            STBET_p      =  stbeto + stbetl * iLE + stbetw * iWE + stbetlw * iLE * iWE;
            MUE_p        =  mueo * (1.0 + muew * iWE);
            STMUE_p      =  stmueo;
            THEMU_p      =  themuo;
            STTHEMU_p    =  stthemuo;
            CS_p         =  (cso + csl * pow(iLE, cslexp)) * (1.0 + csw * iWE) * (1.0 + cslw * iLE * iWE);
            STCS_p       =  stcso;
            THECS_p      =  thecso;
            STTHECS_p    =  stthecso;
            XCOR_p       =  xcoro * (1.0 + xcorl * iLE) * (1.0 + xcorw * iWE) * (1.0 + xcorlw * iLE * iWE);
            STXCOR_p     =  stxcoro;
            FETA_p       =  fetao;

// Series resistance

            RS_p         =  rsw1 * iWE * (1.0 + rsw2 * iWE);
            STRS_p       =  strso;
            RSB_p        =  rsbo;
            RSG_p        =  rsgo;

// Velocity saturation

            THESAT_p     =  (thesato + thesatl* GWE / GPE * pow(iLE, thesatlexp)) * (1.0 + thesatw * iWE) * (1.0 + thesatlw * iLE * iWE);
            STTHESAT_p   =  stthesato + stthesatl * iLE + stthesatw * iWE + stthesatlw * iLE * iWE;
            THESATB_p    =  thesatbo;
            THESATG_p    =  thesatgo;

// Saturation voltage

            AR_p         =  aro + ARL_i * pow(iLE, arlexp);

// Channel length modulation

            ALP_p        =  alpl * pow(iLE, alplexp) * (1.0 + alpw * iWE);
            tmpx         =  pow(iLE, alp1lexp);
            ALP1_p       =  alp1l1 * tmpx * (1.0 + alp1w * iWE) / (1.0 + ALP1L2_i * iLE * tmpx);
            tmpx         =  pow(iLE, alp2lexp);
            ALP2_p       =  alp2l1 * tmpx * (1.0 + alp2w * iWE) / (1.0 + ALP2L2_i * iLE * tmpx);
            VP_p         =  vpo;

// Impact ionization

            A1_p         =  a1o * (1.0 + a1l * iLE) * (1.0 + a1w * iWE);
            A2_p         =  a2o;
            STA2_p       =  sta2o;
            A3_p         =  a3o * (1.0 + a3l * iLE) * (1.0 + a3w * iWE);
            A4_p         =  a4o * (1.0 + a4l * iLE) * (1.0 + a4w * iWE);

// Gate current

            GCO_p        =  gcoo;
            IGINV_p      =  iginvlw / (iWE * iLE);
            IGOV_p       =  igovw * LOV_i / (`LEN * iWE);
            IGOVD_p      =  igovdw * lgdov_m / (`LEN * iWE);
            STIG_p       =  stigo;
            GC2_p        =  gc2o;
            GC3_p        =  gc3o;
            CHIB_p       =  chibo;

// GIDL

            AGIDL_p      =  agidlw * LOV_i / (`LEN * iWE);
            AGIDLD_p     =  agidldw * lgdov_m / (`LEN * iWE);
            BGIDL_p      =  bgidlo;
            BGIDLD_p     =  bgidldo;
            STBGIDL_p    =  stbgidlo;
            STBGIDLD_p   =  stbgidldo;
            CGIDL_p      =  cgidlo;
            CGIDLD_p     =  cgidldo;

// Charge model parameters

            COX_p        = `P_EPS0_NIST2002 * EPSROXO_i * WEcv * LEcv / TOXO_i;
            CGOV_p       = `P_EPS0_NIST2002 * EPSROXO_i * WEcv * LOV_i / TOXOVO_i;
            CGOVD_p      = `P_EPS0_NIST2002 * EPSROXO_i * WEcv * lgdovq_m / TOXOVDO_i;
            CGOVD2_p     = `P_EPS0_NIST2002 * EPSROXO_i * WEcv * lgdov2_m / TOXOVD2O_i;
            CGBOV_p      =  cgbovl * Lcv / `LEN;
            CFR_p        =  cfrw * Wcv / `WEN;
            CFRD_p       =  cfrdw * Wcv / `WEN;

// Noise model parameters

            temp0        =  1.0 - 2.0 * lintnoi * iLE / `LEN;
            Lnoi         = `MAX(temp0, 1.0e-3);
            Lred         =  1.0 / pow(Lnoi, alpnoi);
            FNT_p        =  fnto;
            FNTEXC_p     =  fntexcl * BETN_p * BETN_p * iWE * iWE;
            NFA_p        =  Lred * iWE * iLE * nfalw;
            NFB_p        =  Lred * iWE * iLE * nfblw;
            NFC_p        =  Lred * iWE * iLE * nfclw;
            EF_p         =  efo;

// Edge transistors: PSP 103.4

            WE_edge      =  2.0 * wedge + wedgew * WE;
            iWE_edge     = `WEN / WE_edge;
            VFBEDGE_p    =  vfbedgeo;
            STVFBEDGE_p  =  stvfbedgeo + stvfbedgel * iLE + stvfbedgew * iWE + stvfbedgelw * iLE * iWE;
            DPHIBEDGE_p  =  dphibedgeo + dphibedgel * pow(iLE, dphibedgelexp) + dphibedgew * iWE + dphibedgelw * iLE * iWE;
            NEFFEDGE_p   =  NSUBEDGEO_i * (1.0 + nsubedgel * pow(iLE, nsubedgelexp)) * ( 1.0 + nsubedgew * iWE) * ( 1.0 + nsubedgelw * iLE * iWE);
            CTEDGE_p     =  ctedgeo + ctedgel * pow(iLE, ctedgelexp);
            GPE_edge     =  1.0 + fbetedge * LPEDGE_i / LE * (1.0 - exp(-LE / LPEDGE_i));
            GPE_edge     = `MAX(GPE_edge, 1.0e-15);
            BETNEDGE_p   =  uo * WE_edge / (GPE_edge * LE) * (1.0 + betedgew * iWE);
            STBETEDGE_p  =  stbetedgeo + stbetedgel * iLE + stbetedgew * iWE + stbetedgelw * iLE * iWE;
            PSCEEDGE_p   =  psceedgel * pow(iLE, psceedgelexp) * (1.0 + psceedgew * iWE);
            PSCEBEDGE_p  =  pscebedgeo;
            PSCEDEDGE_p  =  pscededgeo;
            CFEDGE_p     =  cfedgel * pow(iLE, cfedgelexp) * (1.0 + cfedgew * iWE);
            CFDEDGE_p    =  cfdedgeo;
            CFBEDGE_p    =  cfbedgeo;
            FNTEDGE_p    =  fntedgeo;
            NFAEDGE_p    =  iWE_edge * iLE * nfaedgelw;
            NFBEDGE_p    =  iWE_edge * iLE * nfbedgelw;
            NFCEDGE_p    =  iWE_edge * iLE * nfcedgelw;
            EFEDGE_p     =  efedgeo;
        end

// Well proximity effect parameters

        KVTHOWE      =  kvthoweo + kvthowel * iLE + kvthowew * iWE + kvthowelw * iLE * iWE;
        KUOWE        =  kuoweo + kuowel * iLE + kuowew * iWE + kuowelw * iLE * iWE;

// Parasitic resistance parameters

        if ((swgeo == 1)) begin
            RGE_p         =  RSHG_i * (`oneThird * W_f / NGCON_i + XGWE) / (NGCON_i * L_slif) + (RINT_i + RVPOLY_i) / (W_f * L_f) + NF_i * rgo;
            RJUNS_p      =  NF_i * rjunso / (max(W_f + dwrjuns, 10.0e-9));
            if (swjunasym) begin
                RJUND_p      =  NF_i * rjundo / (max(W_f + dwrjund, 10.0e-9));
            end else begin
                RJUND_p      =  RJUNS_p;
            end
            RJUNX_p      =  NF_i * rjunxo / (max(W_f + dwrjunx, 10.0e-9));
            RBULK_p      =  NF_i * rbulko / (max(W_f + dwrbulk, 10.0e-9));

// Mechanical stress model

            tmpa         =  0.0;
            tmpb         =  0.0;
            loop         =  0.0;
            if ((SA_i > 0.0) && (SB_i > 0.0) && ((NF_i == 1.0) || ((NF_i > 1.0) && (SD_i > 0.0)))) begin
                while (loop < (NF_i - 0.5)) begin
                    tmpa         =  tmpa + 1.0 / (SA_i + 0.5 * L_i + loop * (SD_i + L_i));
                    tmpb         =  tmpb + 1.0 / (SB_i + 0.5 * L_i + loop * (SD_i + L_i));
                    loop         =  loop + 1.0;
                end
                Invsa        =  tmpa * invNF;
                Invsb        =  tmpb * invNF;
                Invsaref     =  1.0 / (SAREF_i + 0.5 * L_i);
                Invsbref     =  1.0 / (SBREF_i + 0.5 * L_i);
                Lx           = `MAX(L_i + delLPS, 1.0e-9);
                Wx           = `MAX(W_i + delWOD + wlod, 1.0e-9);
                templ        =  1.0 / pow(Lx, LLODKUO_i);
                tempw        =  1.0 / pow(Wx, WLODKUO_i);
                Kstressu0    =  (1.0 + lkuo * templ + wkuo * tempw + pkuo * templ * tempw) * (1.0 + tkuo * (rTa - 1.0));
                rhobeta      =  kuo * (Invsa + Invsb) / Kstressu0;
                rhobetaref   =  kuo * (Invsaref + Invsbref) / Kstressu0;
                templ        =  1.0 / pow(Lx, LLODVTH_i);
                tempw        =  1.0 / pow(Wx, WLODVTH_i);
                Kstressvth0  =  1.0 + lkvtho * templ + wkvtho * tempw + pkvtho * templ * tempw;
                temp0        =  Invsa + Invsb - Invsaref - Invsbref;

//  Parameter adaptations

                BETN_p       =  BETN_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                THESAT_p     =  THESAT_p * (1.0 + rhobeta) * (1.0 + KVSAT_i * rhobetaref) / ((1.0 + rhobetaref) * (1.0  + KVSAT_i * rhobeta));
                VFB_p        =  VFB_p + kvtho * temp0 / Kstressvth0;
                CF_p         =  CF_p + stetao * temp0 / pow(Kstressvth0, LODETAO_i);
                BETNEDGE_p   =  BETNEDGE_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                VFBEDGE_p    =  VFBEDGE_p + kvtho * temp0 / Kstressvth0;
                CFEDGE_p     =  CFEDGE_p + stetao * temp0 / pow(Kstressvth0, LODETAO_i);
            end

// Well proximity effect equations

            if ((SCA_i > 0.0) || (SCB_i > 0.0) || (SCC_i > 0.0) || (SC_i > 0.0)) begin
                if ((SCA_i == 0.0) && (SCB_i == 0.0) && (SCC_i == 0.0)) begin
                    temp0        =  SC_i + W_i;
                    temp00       =  1.0 / SCREF_i;
                    SCA_i        =  SCREF_i * SCREF_i / (SC_i * temp0);
                    SCB_i        =  ((0.1 * SC_i + 0.01 * SCREF_i) * exp(-10.0 * SC_i * temp00) - (0.1 * temp0 + 0.01 * SCREF_i) * exp(-10.0 * temp0 * temp00)) / W_i;
                    SCC_i        =  ((0.05 * SC_i + 0.0025 * SCREF_i) * exp(-20.0 * SC_i * temp00) - (0.05 * temp0 + 0.0025 * SCREF_i) * exp(-20.0 * temp0 * temp00)) / W_i;
                end

// Parameter adaptations

                temp0        =  SCA_i + WEB_i * SCB_i + WEC_i * SCC_i;
                VFB_p        =  VFB_p + KVTHOWE * temp0;
                BETN_p       =  BETN_p * (1.0 + KUOWE * temp0);
                VFBEDGE_p    =  VFBEDGE_p + KVTHOWE * temp0;
                BETNEDGE_p   =  BETNEDGE_p * (1.0 + KUOWE * temp0);
            end
        end

// Internal parameters (including temperature scaling)
// Clipping of the local model parameters

        VFB_i        =  VFB_p;
        STVFB_i      =  STVFB_p;
        ST2VFB_i     =  ST2VFB_p;
        TOX_i        = `MAX(TOX_p, 1.0e-10);
        EPSROX_i     = `MAX(EPSROX_p, 1.0);
        NEFF_i       = `CLAMP(NEFF_p, 1.0e20, 1.0e26);
        FACNEFFAC_i  = `MAX(FACNEFFAC_p, 0.0);
        GFACNUD_i    = `MAX(GFACNUD_p, 0.01);
        VSBNUD_i     = `MAX(VSBNUD_p, 0.0);
        DVSBNUD_i    = `MAX(DVSBNUD_p, 0.1);
        VNSUB_i      =  VNSUB_p;
        NSLP_i       = `MAX(NSLP_p, 1.0e-3);
        DNSUB_i      = `CLAMP(DNSUB_p, 0.0, 1.0);
        DPHIB_i      =  DPHIB_p;
        DELVTAC_i    =  DELVTAC_p;
        NP_i         = `MAX(NP_p, 0.0);
        TOXOV_i      = `MAX(TOXOV_p, 1.0e-10);
        TOXOVD_i     = `MAX(TOXOVD_p, 1.0e-10);
        TOXOVD2_i    = `MAX(TOXOVD2_p, 1.0e-10);
        NOV_i        = `CLAMP(NOV_p, 1.0e20, 1.0e27);
        NOVD_i       = `CLAMP(NOVD_p, 1.0e20, 1.0e27);
        NOVD2_i      = `CLAMP(NOVD2_p, 1.0e20, 1.0e27);
        CT_i         = `MAX(CT_p, 0.0);
        CTG_i        = `MAX(CTG_p, 0.0);
        CTB_i        =  CTB_p;
        STCT_i       =  STCT_p;
        CF_i         = `MAX(CF_p, 0.0);
        CFD_i        = `MAX(CFD_p, 0.0);
        CFB_i        = `CLAMP(CFB_p, 0.0, 1.0);
        PSCE_i       = `MAX(PSCE_p, 0.0);
        PSCEB_i      = `CLAMP(PSCEB_p, 0.0, 1.0);
        PSCED_i      = `MAX(PSCED_p, 0.0);
        BETN_i       = `MAX(BETN_p, 0.0);
        STBET_i      =  STBET_p;
        MUE_i        = `MAX(MUE_p, 0.0);
        STMUE_i      =  STMUE_p;
        THEMU_i      = `MAX(THEMU_p, 0.0);
        STTHEMU_i    =  STTHEMU_p;
        CS_i         = `MAX(CS_p,  0.0);
        STCS_i       =  STCS_p;
        THECS_i      = `MAX(THECS_p, 0.0);
        STTHECS_i    =  STTHECS_p;
        XCOR_i       = `MAX(XCOR_p, 0.0);
        STXCOR_i     =  STXCOR_p;
        FETA_i       = `MAX(FETA_p, 0.0);
        RS_i         = `MAX(RS_p, 0.0);
        STRS_i       =  STRS_p;
        RSB_i        = `CLAMP(RSB_p, -0.5, 1.0);
        RSG_i        = `MAX(RSG_p, -0.5);
        THESAT_i     = `MAX(THESAT_p, 0.0);
        STTHESAT_i   =  STTHESAT_p;
        THESATB_i    = `CLAMP(THESATB_p, -0.5, 1.0);
        THESATG_i    = `MAX(THESATG_p, -0.5);
        AR_i         = `MAX(AR_p, 0.0);
        ALP_i        = `MAX(ALP_p, 0.0);
        ALP1_i       = `MAX(ALP1_p, 0.0);
        ALP2_i       = `MAX(ALP2_p, 0.0);
        VP_i         = `MAX(VP_p, 1.0e-10);
        A1_i         = `MAX(A1_p, 0.0);
        A2_i         = `MAX(A2_p, 0.0);
        STA2_i       =  STA2_p;
        A3_i         = `MAX(A3_p, 0.0);
        A4_i         = `MAX(A4_p, 0.0);
        GCO_i        = `CLAMP(GCO_p, -10.0, 10.0);
        IGINV_i      = `MAX(IGINV_p, 0.0);
        IGOV_i       = `MAX(IGOV_p, 0.0);
        IGOVD_i      = `MAX(IGOVD_p, 0.0);
        STIG_i       =  STIG_p;
        GC2_i        = `CLAMP(GC2_p, 0.0, 10.0);
        GC3_i        = `CLAMP(GC3_p, -10.0, 10.0);
        CHIB_i       = `MAX(CHIB_p, 1.0);
        AGIDL_i      = `MAX(AGIDL_p, 0.0);
        AGIDLD_i     = `MAX(AGIDLD_p, 0.0);
        BGIDL_i      = `MAX(BGIDL_p, 0.0);
        BGIDLD_i     = `MAX(BGIDLD_p, 0.0);
        STBGIDL_i    =  STBGIDL_p;
        STBGIDLD_i   =  STBGIDLD_p;
        CGIDL_i      =  CGIDL_p;
        CGIDLD_i     =  CGIDLD_p;
        COX_i        = `MAX(COX_p, 0.0);
        CGOV_i       = `MAX(CGOV_p, 0.0);
        CGOVD_i      = `MAX(CGOVD_p, 0.0);
        CGOVD2_i     = `MAX(CGOVD2_p, 0.0);
        CGBOV_i      = `MAX(CGBOV_p, 0.0);
        CFR_i        = `MAX(CFR_p, 0.0);
        CFRD_i       = `MAX(CFRD_p, 0.0);
        FNT_i        = `MAX(FNT_p, 0.0);
        FNTEXC_i     = `MAX(FNTEXC_p, 0.0);
        NFA_i        = `MAX(NFA_p, 0.0);
        NFB_i        = `MAX(NFB_p, 0.0);
        NFC_i        = `MAX(NFC_p, 0.0);
        EF_i         = `MAX(EF_p,  0.0);
        VFBEDGE_i    =  VFBEDGE_p;
        STVFBEDGE_i  =  STVFBEDGE_p;
        DPHIBEDGE_i  =  DPHIBEDGE_p;
        NEFFEDGE_i   = `CLAMP(NEFFEDGE_p, 1.0e20, 1.0e26);
        CTEDGE_i     = `MAX(CTEDGE_p, 0.0);
        BETNEDGE_i   = `MAX(BETNEDGE_p, 0.0);
        STBETEDGE_i  =  STBETEDGE_p;
        PSCEEDGE_i   = `MAX(PSCEEDGE_p, 0.0);
        PSCEBEDGE_i  = `CLAMP(PSCEBEDGE_p, 0.0, 1.0);
        PSCEDEDGE_i  = `MAX(PSCEDEDGE_p, 0.0);
        CFEDGE_i     = `MAX(CFEDGE_p, 0.0);
        CFDEDGE_i    = `MAX(CFDEDGE_p, 0.0);
        CFBEDGE_i    = `CLAMP(CFBEDGE_p, 0.0, 1.0);
        FNTEDGE_i    = `MAX(FNTEDGE_p, 0.0);
        NFAEDGE_i    = `MAX(NFAEDGE_p, 0.0);
        NFBEDGE_i    = `MAX(NFBEDGE_p, 0.0);
        NFCEDGE_i    = `MAX(NFCEDGE_p, 0.0);
        EFEDGE_i     = `MAX(EFEDGE_p,  0.0);
        RGE_i         = `MAX(RGE_p, 0.0);
        MULT_i       = `MAX(mult * NF_i, 0.0); // Note: NF_i is set to 1 for local model
        FACTUO_i     = `MAX(factuo, 0.0);
        DELVTO_i     =  delvto;
        FACTUOEDGE_i = `MAX(factuoedge, 0.0);
        DELVTOEDGE_i =  delvtoedge;

// Ignore drain-side values in case of symmetric junctions

        vfbovd_i      =  vfbovd;
        if (swjunasym == 0) begin
            vfbovd_i      =  vfbov;
            TOXOVD_i      =  TOXOV_i;
            NOVD_i        =  NOV_i;
            AGIDLD_i      =  AGIDL_i;
            BGIDLD_i      =  BGIDL_i;
            STBGIDLD_i    =  STBGIDL_i;
            CGIDLD_i      =  CGIDL_i;
            IGOVD_i       =  IGOV_i;
            CGOVD_i       =  CGOV_i;
            CFRD_i        =  CFR_i;
        end

// Local process parameters

        EPSOX        = `P_EPS0_NIST2002 * EPSROX_i;
        CoxPrime     =  EPSOX / TOX_i;
        tox_sq       =  TOX_i * TOX_i;
        Cox_over_q   =  CoxPrime / `P_Q_OLD;
        NEFFAC_i     =  FACNEFFAC_i * NEFF_i;
        NEFFAC_i     = `CLAMP(NEFFAC_i, 1.0e20, 1.0e26);

// QM corrections: initially calculated in PSP103_macrodefs.include (PSP103.3)

        qq           =  0.0;
        if (qmc > 0.0) begin
            qq           =  0.4 * `QMN * qmc * pow(CoxPrime, `twoThirds);
            if ((CHNL_TYPE == `PMOS) && (swptest == 0)) begin
                qq           = `QMP / `QMN * qq;
            end
        end

// Electrical field parameters

        E_eff0       =  1.0e-8 * CoxPrime / EPSSI;
        eta_mu       =  0.5 * FETA_i;
        eta_mu1      =  0.5;
        if ((CHNL_TYPE == `PMOS) && (swptest == 0)) begin
            eta_mu       =  `oneThird * FETA_i;
            eta_mu1      =  `oneThird;
        end

// CLM parameter

        inv_VP       =  1.0 / VP_i;

// Gate overlap

        GOV_s        =  sqrt(2.0 * `P_Q_OLD * NOV_i * EPSSI * inv_phita)  * TOXOV_i / EPSOX;
        GOV_d        =  sqrt(2.0 * `P_Q_OLD * NOVD_i * EPSSI * inv_phita)  * TOXOVD_i / EPSOX;
        GOV2_s       =  GOV_s * GOV_s;
        GOV2_d       =  GOV_d * GOV_d;
        `sp_ovInit(GOV_s, GOV2_s, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s)
        inv_Gf2d     =  1.0 / GOV2_d;
        xid          =  1.0 + GOV_d * `M_SQRT1_2;
        inv_xid      =  1.0 / xid;
        margind      =  1.0e-05 * xid;
        GOV_d2       =  sqrt(2.0 * `P_Q_OLD * NOVD2_i * EPSSI * inv_phita)  * TOXOVD2_i / EPSOX;
        GOV2_d2      =  GOV_d2 * GOV_d2;
        inv_Gf2d2    =  1.0 / GOV2_d2;
        xid2         =  1.0 + GOV_d2 * `M_SQRT1_2;
        inv_xid2     =  1.0 / xid2;
        margind2     =  1.0e-05 * xid2;

// Temperature scaling variables

// Gate to channel leakage parameters

        inv_CHIB     =  1.0 / CHIB_i;
        B_fact       =  4.0 * `oneThird * sqrt(2.0 * `P_Q_OLD * `P_ME_NIST2002 * CHIB_i) / `P_HBAR_NIST2002;
        BCH          =  B_fact * TOX_i;
        BOV          =  B_fact * TOXOV_i;
        BOV_d        =  B_fact * TOXOVD_i;
        GCQ          =  0.0;
        if (GC3_i < 0) begin
            GCQ          =  -0.495 * GC2_i / GC3_i;
        end
        tf_ig        =  pow(rTa, STIG_i);
        IGINV_i      =  IGINV_i * tf_ig;
        IGOV_i       =  IGOV_i * tf_ig;
        IGOVD_i      =  IGOVD_i * tf_ig;

// GIDL parameters

        AGIDLs       =  AGIDL_i * 4.0e-18 / (TOXOV_i * TOXOV_i);
        AGIDLDs      =  AGIDLD_i * 4.0e-18 / (TOXOVD_i * TOXOVD_i);
        B_fact       = `MAX(1.0 + STBGIDL_i * delTa, 0.0);
        BGIDL_T      =  BGIDL_i * B_fact;
        BGIDLs       =  BGIDL_T * TOXOV_i * 5.0e8;
        B_fact       = `MAX(1.0 + STBGIDLD_i * delTa, 0.0);
        BGIDLD_T     =  BGIDLD_i * B_fact;
        BGIDLDs      =  BGIDLD_T * TOXOVD_i * 5.0e8;

// Noise model parameters

        fac_exc      = `P_ME_NIST2002 * 1.0e9 * FNTEXC_i;

// source/bulk and drain/bulk junction diode instance parameters

        if (swjunc) begin
            if (swgeo) begin
                ABSOURCE_i   =  as*aFactor*invNF;
                LSSOURCE_i   = `MAX((ps*lFactor*invNF-WE), 0.0);
                LGSOURCE_i   =  WE;
                ABDRAIN_i    =  ad*aFactor*invNF;
                LSDRAIN_i    = `MAX((pd*lFactor*invNF-WE), 0.0);
                LGDRAIN_i    =  WE;
            end else begin
                ABSOURCE_i   =  as*aFactor*invNF;
                ABDRAIN_i    =  ad*aFactor*invNF;
                if ($param_given(jw) || $param_given(w)) begin
                    LSSOURCE_i   = `MAX((ps*lFactor*invNF-jw*lFactor), 0.0);
                    LGSOURCE_i   =  jw*lFactor;
                    LSDRAIN_i    = `MAX((pd*lFactor*invNF-jw*lFactor), 0.0);
                    LGDRAIN_i    =  jw*lFactor;
                end else begin
                    LSSOURCE_i   = `MAX((ps*lFactor*invNF-jw), 0.0);
                    LGSOURCE_i   =  jw;
                    LSDRAIN_i    = `MAX((pd*lFactor*invNF-jw), 0.0);
                    LGDRAIN_i    =  jw;
                end
            end
            ABDRAINX_i   =  adx*aFactor*invNF;
            LSDRAINX_i   =  pdx*lFactor*invNF;
        end else begin
            ABSOURCE_i   =  0.0;
            LSSOURCE_i   =  0.0;
            LGSOURCE_i   =  0.0;
            ABDRAIN_i    =  0.0;
            LSDRAIN_i    =  0.0;
            LGDRAIN_i    =  0.0;
            ABDRAINX_i   =  0.0;
            LSDRAINX_i   =  0.0;
        end


//
//  source/bulk and drain/bulk junction diode parameter initialization
//

        tRefKj       = `P_CELSIUS0+trj;
        egTrefj      =  eglev == 1 ? egdelta+`egTsividis(tRefKj) : `egSze(tRefKj, phig, alphaeg, betaeg);
        phi_tj       = `P_K_NIST2002*tRefKj/`P_Q_OLD;
        sq2Phitr     =  4.0*phi_tj*phi_tj;
        alphabrj     =  1.0-1.0/frev;
        w0bot        =  pnjVarsC(pbot, vbirbot, `EPS_Sij, `P_Q_OLD, neffbot,
                                 pd1mpbot, vbbtLimbot); // outputs
        w0sti        =  pnjVarsC(psti, vbirsti, `EPS_Sij, `P_Q_OLD, neffsti,
                                 pd1mpsti, vbbtLimsti); // outputs
        w0gat        =  pnjVarsC(pgat, vbirgat, `EPS_Sij, `P_Q_OLD, neffgat,
                                 pd1mpgat, vbbtLimgat); // outputs
        if (swjunasym) begin
            w0bot_d      =  pnjVarsC(pbotd, vbirbotd, `EPS_Sij, `P_Q_OLD, neffbotd,
                                     pd1mpbot_d, vbbtLimbot_d); // outputs
            w0sti_d      =  pnjVarsC(pstid, vbirstid, `EPS_Sij, `P_Q_OLD, neffstid,
                                     pd1mpsti_d, vbbtLimsti_d); // outputs
            w0gat_d      =  pnjVarsC(pgatd, vbirgatd, `EPS_Sij, `P_Q_OLD, neffgatd,
                                     pd1mpgat_d, vbbtLimgat_d); // outputs
            stvbr_d      =  stvbrd;
            stfbbt_d     =  stfbbtd;
        end else begin
            w0bot_d      =  w0bot;
            w0sti_d      =  w0sti;
            w0gat_d      =  w0gat;
            stvbr_d      =  stvbr;
            stfbbt_d     =  stfbbt;
            pd1mpbot_d   =  pd1mpbot;
            pd1mpsti_d   =  pd1mpsti;
            pd1mpgat_d   =  pd1mpgat;
            vbbtLimbot_d =  vbbtLimbot;
            vbbtLimsti_d =  vbbtLimsti;
            vbbtLimgat_d =  vbbtLimgat;
        end
        w0bot_x      =  pnjVarsC(pbotx, vbirbotx, `EPS_Sij, `P_Q_OLD, neffbotx,
                                 pd1mpbot_x, vbbtLimbot_x); // outputs
        w0sti_x      =  pnjVarsC(pstix, vbirstix, `EPS_Sij, `P_Q_OLD, neffstix,
                                 pd1mpsti_x, vbbtLimsti_x); // outputs


//
//  initializeInstance code from JFETIDG code
//

        tdevC    = $temperature+dta-`P_CELSIUS0;
        weff_m   =  (wdrift_m+xw+(nwxw*`WEN/wdrift_m)+fdxwo*(1.0-exp(-wdrift_m/fdrwo)));
        leff_m   =  ldrift_m+(xl+xlw*`WEN/wdrift_m)+rgdovr*`MAXA(lgdov_m-lspread,0.0,aspread*aspread);
        if (lspread>0.0) begin
            leff_m   =  leff_m+dlspread*lspread/(lspread+xspread*`MINA(lgdov_m,lspread,aspread*aspread));
        end
        iw       = `WEN/weff_m;
        il       = `LEN/leff_m;
        phi_t    = `P_K_NIST2010*tiniK/`P_Q_NIST2010;
        trdr     =  tm+(swbgmos*toxb+swtgmos*toxt)*`EPS_SI/`EPS_OX;
        ni       = `niPsp_m3(tiniK, `P_K_NIST2010, `P_Q_NIST2010);
        if (swgeo) begin // global to local geometry mappings
            if ($param_given(dfbo)) begin // parametric calculation
                psirb_i  =  psirbo;
                dfb_i    =  dfbo;
            end else begin                // physical   calculation
                if (swbgmos) begin   // MOS bottom gate
                    gamma    =  sqrt(2.0*`P_Q_NIST2010*`EPS_SI*nc)*toxb/`EPS_OX;
                    psirb_i  =  psirbfac*(0.5*gamma*gamma-2.0*vfbb);
                    dfb_i    =  dfbfac*`M_SQRT2*`EPS_SI*toxb/(`EPS_OX*gamma*trdr);
                end else begin       // pn-junction bottom gate
                    psirb_i  =  psirbfac*2.0*phi_t*ln(nc*nb/(ni*ni));
                    dfb_i    =  dfbfac*sqrt(`EPS_SI*nb/(`P_Q_NIST2010*nc*(nb+nc)))/trdr;
                end
            end
            iw_fac   =  pow(iw, psirbwe);
            il_fac   =  pow(il, psirble);
            psirb_i  =  psirb_i*(1.0+psirbw*iw_fac)*(1.0+psirbl*il_fac)*(1.0+psirblw*iw_fac*il_fac);
            psirb_i  = `MAX(psirb_i, 0.1);
            iw_fac   =  pow(iw, dfbwe);
            il_fac   =  pow(il, dfble);
            dfb_i    =  dfb_i*(1.0+dfbw*iw_fac)*(1.0+dfbl*il_fac)*(1.0+dfblw*iw_fac*il_fac);
            if (dfb_i<1.0e-08) begin
                dfb_i    =  0.0;
            end
            if ($param_given(dfto)) begin // parametric calculation
                psirt_i  =  psirto;
                dft_i    =  dfto;
            end else begin                // physical   calculation
                if (swtgmos) begin   // MOS top gate
                    gamma    =  sqrt(2.0*`P_Q_NIST2010*`EPS_SI*nc)*toxt/`EPS_OX;
                    psirt_i  =  psirtfac*(0.5*gamma*gamma-2.0*vfbt);
                    dft_i    =  dftfac*`M_SQRT2*`EPS_SI*toxt/(`EPS_OX*gamma*trdr);
                end else begin       // pn-junction top gate
                    psirt_i  =  psirtfac*2.0*phi_t*ln(nc*nt/(ni*ni));
                    dft_i    =  dftfac*sqrt(`EPS_SI*nt/(`P_Q_NIST2010*nc*(nt+nc)))/trdr;
                end
            end
            iw_fac   =  pow(iw, psirtwe);
            il_fac   =  pow(il, psirtle);
            psirt_i  =  psirt_i*(1.0+psirtw*iw_fac)*(1.0+psirtl*il_fac)*(1.0+psirtlw*iw_fac*il_fac);
            psirt_i  = `MAX(psirt_i, 0.1);
            iw_fac   =  pow(iw, dftwe);
            il_fac   =  pow(il, dftle);
            dft_i    =  dft_i*(1.0+dftw*iw_fac)*(1.0+dftl*il_fac)*(1.0+dftlw*iw_fac*il_fac);
            if (dft_i<1.0e-08) begin
                dft_i    =  0.0;
            end
            if ($param_given(rshzd)) begin
                gzd      =  1.0/(delr_rsh*rshzd*(leff_m/weff_m));
            end else begin
                if ($param_given(rsh0)) begin
                    if (swdrlin) begin
                        dfac     =  1.0;
                    end else begin
                        dfac     =  1.0-dfb_i*sqrt(psirb_i)-dft_i*sqrt(psirt_i);
                        if (dfac<=0.1) begin
                            $error("ERROR (psphv): calculated depletion factor is <= 0.1, specify rshzd or mu0 instead of rsh0");
                        end
                    end
                    gzd      =  1.0/(delr_rsh*rsh0*(leff_m/weff_m)*dfac);
                end else begin
                    gzd      =  1.0/(delr_rsh*(leff_m/weff_m)/(`P_Q_NIST2010*mu0*nc*trdr));
                end
            end
            il_fac   =  pow(il, diblle);
            diblt_i  =  dibltl*il_fac;
            diblb_i  =  diblbl*il_fac;
            il_fac   =  pow(il, clm1le);
            clm1_i   =  clm1l*il_fac;
            il_fac   =  pow(il, clm2le);
            clm2_i   =  clm2l*il_fac;
            ats_i    =  atso+atsl*il;
            axs_i    =  axso/(1.0+axsl*il);
            iw_fac   =  pow(iw, nspowe);
            il_fac   =  pow(il, nspole);
            nspo_i   =  nspoo*(1.0+nspow*iw_fac)*(1.0+nspol*il_fac)*(1.0+nspolw*iw_fac*il_fac);
            nspo_i   = `CLAMP(nspo_i, 0.1, 5.0);
            if (swbgmos) begin
                alphab_i =  0.0;
            end else begin
                alphab_i =  alphabo+alphabl*pow(il,alphable)+alphabw*pow(iw,alphabwe);
            end
            if (swtgmos) begin
                alphat_i =  0.0;
            end else begin
                alphat_i =  alphato*(1.0+alphatl*il);
            end
            mumii1_i =  max(0.0, mumii1o+mumii1l*pow(il,mumii1le)+mumii1w*pow(iw,mumii1we));
            mumii2_i =  max(0.0, mumii2o+mumii2l*pow(il,mumii2le)+mumii2w*pow(iw,mumii2we));
            gth_i    =  gtho+gthl*lth_m+gthw*wth_m+gtha*a_m2+gthc*(ncs+ncd);
            cth_i    =  ctho+cthl*lth_m+cthw*wth_m+ctha*a_m2+cthc*(ncs+ncd);
            mumt_i   =  mumto*(1.0+mumtl*il)*(1.0+mumtw*iw)*(1.0+mumtlw*il*iw);
            mumb_i   =  mumbo*(1.0+mumbl*il)*(1.0+mumbw*iw)*(1.0+mumblw*il*iw);
            il_fac   =  pow(il, xvsatle);
            xvsat_i  =  xvsato*(1.0+xvsatl*il_fac);
            vcorn_i  =  0.0; // explicitly set here, for no vsat case, to avoid hidden states
            vcrit_i  =  0.0;
            vcrneff  =  0.0;
            dufctr   =  0.0;
            uoff     =  0.0;
            if ((ecrito<1.0e09)&&(!swdrlin)) begin    // Note: temperature variations in vcorn and vcrit
                vcorn_i  =  (leff_m+dxlsat)*min(ecorno,ecrito)*(max(1.0+ecritw*iw, 0.1)); // cancel in dufctr and uoff, so can precompute
                vcrit_i  =  (leff_m+dxlsat)*ecrito*(max(1.0+ecritw*iw, 0.1));
                vcrneff  =  2.0*du*vcrit_i; // intermediate quantity
                vcrneff  =  sqrt(vcorn_i*vcorn_i+vcrneff*vcrneff)-vcrneff;
                dufctr   =  du*vcrneff/vcrit_i;
                uoff     =  sqrt((vcrneff*vcrneff/(vcrit_i*vcrit_i))+4.0*dufctr);
            end
            tc1_i    =  tc1o+tc1w*iw+(tc1l+tc1lw*iw)*il;
            tc2_i    =  tc2o+tc2w*iw+(tc2l+tc2lw*iw)*il;
            tsl_i    =  tslo+tslw*iw+(tsll+tsllw*iw)*il;
            tshl_i   =  tsho+tshw*iw+(tshl+tshlw*iw)*il-tsl_i;
            tsct_i   =  tscto+tsctw*iw+(tsctl+tsctlw*iw)*il;
            tsct_i   = `MAX(tsct_i, -100.0);
            tssmsq_i =  tssmo+tssmw*iw+(tssml+tssmlw*iw)*il;
            tssmsq_i = `MAX(tssmsq_i, 0.0);
            tssmsq_i =  tssmsq_i*tssmsq_i;
            vdi0_i   =  vdi0o + vdi0l*pow(iLE,vdi0le) + vdi0w*iWE + vdi0lw*iLE*iWE;
            vdisl_i  =  vdislopeo + vdislopel*pow(iLE,vdislopele) + vdislopew*iWE + vdislopelw*iLE*iWE;
            vdislg_i =  vdislopgo + vdislopgl*pow(iLE,vdislopgle) + vdislopgw*iWE + vdislopglw*iLE*iWE;
            vdscale_i=  vdscaleo + vdscalel*pow(iLE,vdscalele) + vdscalew*iWE + vdscalelw*iLE*iWE;
            vdscaleb_i= vdscalebo + vdscalebl*pow(iLE,vdscaleble) + vdscalebw*iWE + vdscaleblw*iLE*iWE;
            stvdscale_i=  stvdscaleo + stvdscalel*pow(iLE,stvdscalele) + stvdscalew*iWE + stvdscalelw*iLE*iWE;
            a3cvd_i  =  a3cvdo + a3cvdl*pow(iLE,a3cvdle) + a3cvdw*iWE + a3cvdlw*iLE*iWE;
            sta3cvd_i  =  sta3cvdo + sta3cvdl*pow(iLE,sta3cvdle) + sta3cvdw*iWE + sta3cvdlw*iLE*iWE;
        end else begin   // local geometry model, mostly copy over parameters
            if ($param_given(dfb)) begin // parametric calculation
                psirb_i  =  psirb;
                dfb_i    =  dfb;
            end else begin                // physical   calculation
                if (swbgmos) begin   // MOS bottom gate
                    gamma    =  sqrt(2.0*`P_Q_NIST2010*`EPS_SI*nc)*toxb/`EPS_OX;
                    psirb_i  =  psirbfac*(0.5*gamma*gamma-2.0*vfbb);
                    dfb_i    =  dfbfac*`M_SQRT2*`EPS_SI*toxb/(`EPS_OX*gamma*trdr);
                end else begin       // pn-junction bottom gate
                    psirb_i  =  psirbfac*2.0*phi_t*ln(nc*nb/(ni*ni));
                    dfb_i    =  dfbfac*sqrt(`EPS_SI*nb/(`P_Q_NIST2010*nc*(nb+nc)))/trdr;
                end
            end
            psirb_i  = `MAX(psirb_i, 0.1);
            if (dfb_i<1.0e-08) begin
                dfb_i    =  0.0;
            end
            if ($param_given(dft)) begin // parametric calculation
                psirt_i  =  psirt;
                dft_i    =  dft;
            end else begin                // physical   calculation
                if (swtgmos) begin   // MOS top gate
                    gamma    =  sqrt(2.0*`P_Q_NIST2010*`EPS_SI*nc)*toxt/`EPS_OX;
                    psirt_i  =  psirtfac*(0.5*gamma*gamma-2.0*vfbt);
                    dft_i    =  dftfac*`M_SQRT2*`EPS_SI*toxt/(`EPS_OX*gamma*trdr);
                end else begin       // pn-junction top gate
                    psirt_i  =  psirtfac*2.0*phi_t*ln(nc*nt/(ni*ni));
                    dft_i    =  dftfac*sqrt(`EPS_SI*nt/(`P_Q_NIST2010*nc*(nt+nc)))/trdr;
                end
            end
            psirt_i  = `MAX(psirt_i, 0.1);
            if (dft_i<1.0e-08) begin
                dft_i    =  0.0;
            end
            if ($param_given(rzd)) begin
                gzd      =  1.0/(delr_rsh*rzd);
            end else begin
                if (swdrlin) begin
                    dfac     =  1.0;
                end else begin
                    dfac     =  1.0-dfb_i*sqrt(psirb_i)-dft_i*sqrt(psirt_i);
                    if (dfac<=0.1) begin
                        $error("ERROR (psphv): calculated depletion factor is <= 0.1, specify rzd instead of r0");
                    end
                end
                gzd      =  1.0/(delr_rsh*r0*dfac);
            end
            diblt_i  =  diblt;
            diblb_i  =  diblb;
            clm1_i   =  clm1;
            clm2_i   =  clm2;
            ats_i    =  ats;
            axs_i    =  axs;
            nspo_i   =  nspo;
            if (swbgmos) begin
                alphab_i =  0.0;
            end else begin
                alphab_i =  alphab;
            end
            if (swtgmos) begin
                alphat_i =  0.0;
            end else begin
                alphat_i =  alphat;
            end
            mumii1_i =  max(0.0, mumii1);
            mumii2_i =  max(0.0, mumii2);
            gth_i    =  gth;
            cth_i    =  cth;
            mumt_i   =  mumt;
            mumb_i   =  mumb;
            xvsat_i  =  xvsat;
            vcorn_i  =  0.0; // explicitly set here, for no vsat case, to avoid hidden states
            vcrit_i  =  0.0;
            vcrneff  =  0.0;
            dufctr   =  0.0;
            uoff     =  0.0;
            if ((vcrit<1.0e03)&&(!swdrlin)) begin    // Note: temperature variations in vcorn and vcrit
                vcorn_i  =  min(vcorn,vcrit);                 // cancel in dufctr and uoff, so can precompute
                vcrit_i  =  vcrit;
                vcrneff  =  2.0*du*vcrit_i; // intermediate quantity
                vcrneff  =  sqrt(vcorn_i*vcorn_i+vcrneff*vcrneff)-vcrneff;
                dufctr   =  du*vcrneff/vcrit_i;
                uoff     =  sqrt((vcrneff*vcrneff/(vcrit_i*vcrit_i))+4.0*dufctr);
            end
            tc1_i    =  tc1;
            tc2_i    =  tc2;
            tsl_i    =  tsl;
            tshl_i   =  tsh-tsl_i;
            tsct_i   =  tsct;
            tssmsq_i =  tssm*tssm;
            vdi0_i   =  vdi0;
            vdisl_i  =  vdislope;
            vdislg_i =  vdislopg;
            vdscale_i=  vdscale;
            vdscaleb_i= vdscaleb;
            stvdscale_i=  stvdscale;
            a3cvd_i  =  a3cvd;
            sta3cvd_i  =  sta3cvd;
            weff_m   =  1.0; // for flicker noise calculation
            leff_m   =  1.0; // for flicker noise calculation
        end
        if (gzd>1.0e99) begin
            $error("ERROR (psphv): zero depletion-width conductance is too large");
        end
        diblo    =  pow((diblv), dible);
        clm2o    =  pow(clm2v, clm2e);
        expmvoff =  exp(-voffspo);
        tcrref   =  1.0-tshl_i*`MAXA(tr-tsct_i, 0.0, tssmsq_i);
    end // initial_instance

    begin : evaluateblock

        real sigVds, sigVdr, dphit1, xgct, xsct0, xbct, xsbstar, xsct, dCTG, ct_fact, phit1, inv_phit1, xg_dc, alpha_dc, dps_dc, qim_dc;
        real qim1_dc, H_dc, FdL_dc, Gvsatinv_dc, Ids, Iimpact, mavl, Igdov, Igsov, Igcd, Igcs, eta_p_ac, H0;
        real COX_qm, ijun_s, ijunbot_s, ijunsti_s, ijungat_s, ijun_d, ijunbot_d, ijunsti_d, ijungat_d, qjun_s, qjunbot_s, qjunsti_s;
        real qjungat_s, qjun_d, qjunbot_d, qjunsti_d, qjungat_d, jnoise_s, jnoise_d, Gmob_dc, xitsb_dc, Vdse_dc, Vsbstaredge, Vsbxedge;
        real ijun_x, ijunbot_x, ijunsti_x, qjun_x, qjunbot_x, qjunsti_x, jnoise_x;
        real dphit1edge, phit1edge, inv_phit1edge, Vdspedge, delVgedge, xgedge, xbedge, dxthedge, xnedge_s, qseffedge, xnedge_d;
        real qdseffedge, qdeffedge, qmeffedge, dsqredge, alphabmedge, Idsedge, Sfledge, midedge, sqidedge;
        real Pdiss, phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
        real ntedge;
        real temp, temp1, temp2;

//  --------------------------------------------------------------------------------------------------------------
//  DC bias dependent quantities (calculations for current contribs)
//  --------------------------------------------------------------------------------------------------------------

        begin : evaluateStatic

// Initialize temporary variables

            temp        =  0.0;
            temp1       =  0.0;
            temp2       =  0.0;
            delta_novd  =  0.0;
            delta_novd2 =  0.0;
            xn_ov_d     =  0.0;
            xn_ov_d2    =  0.0;
            Sfl         =  0.0;
            sqid        =  0.0;
            shot_igcsx  =  0.0;
            shot_igcdx  =  0.0;
            shot_igsov  =  0.0;
            shot_igdov  =  0.0;
            shot_iavl   =  0.0;
            jnoisex_s   =  0.0;
            jnoisex_d   =  0.0;
            Sfledge     =  0.0;
            sqidedge    =  0.0;

// Initialization of variables for SHE effect

            TKD          =  TKA + Temp(b_rth);
            `TempInitialize
            `TempScaling
            RJUNS_i      =  RJUNS_p * exp(ln_rTn*strjuns);
            if (swjunasym) begin
                RJUND_i      =  RJUND_p * exp(ln_rTn*strjund);
            end else begin
                RJUND_i      =  RJUNS_i;
            end
            RJUNX_i      =  RJUNX_p * exp(ln_rTn*strjunx);
            RBULK_i      =  RBULK_p * exp(ln_rTn*strbulk);
            a3cvd_t      =  a3cvd_i * exp(ln_rTn*sta3cvd_i);
            QCLM         =  0.0;
            xs_ov        =  0.0;
            xd_ov        =  0.0;
            Vovs         =  0.0;
            Vovd         =  0.0;
            xd2_ov       =  0.0;
            Vovd2        =  0.0;
            Iimpact      =  0.0;
            mavl         =  0.0;

// Voltage affectations

            if (CHNL_TYPE == `NMOS) begin
                Vgs          =  V(b_gsi);
                Vds          =  V(b_dsi);
                Vsb          =  V(b_sbi);
                Vjun_s       =  V(b_bsd);
                Vjun_d       =  V(b_bdd);
                Vjun_x       =  V(b_bxd);
                VdsPrime_ld  =  V(b_ds);
                VgdxPrime    =  V(b_gtd);
                VdxbPrime    = -V(b_gbd);
            end else begin
                Vgs          = -V(b_gsi);
                Vds          = -V(b_dsi);
                Vsb          = -V(b_sbi);
                Vjun_s       = -V(b_bsd);
                Vjun_d       = -V(b_bdd);
                Vjun_x       = -V(b_bxd);
                VdsPrime_ld  = -V(b_ds);
                VgdxPrime    = -V(b_gtd);
                VdxbPrime    =  V(b_gbd);
            end

// Voltages NOT subject to S/D-interchange

            VgsPrime     =  Vgs;
            VsbPrime     =  Vsb;
            VdbPrime     =  Vds + Vsb;
            VgdPrime     =  Vgs - Vds;
            VdsPrime     =  Vds;
            xgs_ov       = -(VgsPrime-vfbov) * inv_phita;
            xgd_ov       = -(VgdPrime-vfbovd_i) * inv_phita;
            xgd2_ov      = -(VgdxPrime-vfbovd2) * inv_phita;

// Source-drain interchange

            sigVds       =  1.0;
            Vds_ii       =  Vds;
            if (swvdimp) begin
                Vds_ii       =  VdsPrime_ld; // 1st quadrant, take Vds of complete transistor for channel impact ionization
            end
            vdsScale     =  1.0;
            if (vdscale_i>1.0) begin
                vdsScale     = `MAXA((vdscale_i+vdscaleb_i*Vsb)*pow(rTn,stvdscale_i), 1.0, 0.001);
            end
            Vds          =  Vds/vdsScale;
            if (Vds < 0.0) begin
                sigVds       = -1.0;
                Vgs          =  Vgs - Vds;
                Vsb          =  Vsb + Vds;
                Vds          = -Vds;
                Vds_ii       =  Vds; // 3rd quadrant, take Vds of intrinsic mos only for channel impact ionization
            end
            Vdb          =  Vds + Vsb;
            Vdsx         =  Vds * Vds / (sqrt(Vds * Vds + 0.01) + 0.1);

// Core's model calculation for DC

            begin : SPcalc_dc

// Local variable declaration

                `SPcalcLocalVarDecl
                real FdL, qim1_1, r1, r2, s2, dL1;

// Conditioning of terminal voltages

                temp         = `MINA(Vdb, Vsb, bphi_dc) + phix_dc;
                Vsbstar_dc   =  Vsb - `MINA(temp, 0, aphi_dc) + phix1_dc;
                Vsbstar_dc_tmp = Vsbstar_dc;

// Adapt Vsb for NUD-effect

                if ((swnud != 0) && (GFACNUD_i != 1.0)) begin
                    Vmb          =  Vsbstar_dc + 0.5 * (Vds - Vdsx);
                    us           =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                    temp         =  2.0 * (us - us1) / us21 - 1.0;
                    usnew        =  us - 0.25 * (1.0 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                    Vmbnew       =  usnew * usnew + (2.0 * sqrt_phib_dc) * usnew;
                    Vsbstar_dc   =  Vmbnew - 0.5 * (Vds - Vdsx);
                end

// Set variables needed in PSP103_SPCalculation.include

                phib         =  phib_dc;
                G_0          =  G_0_dc;
                Vsbstar      =  Vsbstar_dc;
                FdL          =  1.0;

                `include "PSP103_SPCalculation.include"

                if (xg > 0.0) begin
                    qim1_1       =  1.0 / qim1;
                    r1           =  qim * qim1_1;
                    r2           =  phit1 * (alpha * qim1_1);
                    s2           =  ln(1.0 + Vdsx * inv_VP);
                    dL1          =  dL + ALP1_i * (qim1_1 * r1 * s1) + ALP2_i * (qbm * r2 * r2 * s2);
                    FdL          =  (1.0 + dL1 + dL1 * dL1) * GdL;
                end

                Vds          =  Vds*vdsScale;
                Vdse         =  Vdse*vdsScale;
                Vdsat        =  Vdsat*vdsScale;
                dps          =  dps*vdsScale;
                x_ds         =  x_ds*vdsScale;
                Udse         =  Udse*vdsScale;
                Vdb          =  Vds + Vsb;
                Vdsx         =  Vds * Vds / (sqrt(Vds * Vds + 0.01) + 0.1);
                xg_dc        =  xg;
                qeff1_dc     =  qeff1;
                Voxm_dc      =  Voxm;
                alpha_dc     =  alpha;
                dps_dc       =  dps;
                qim_dc       =  qim;
                qim1_dc      =  qim1;
                GdL_dc       =  GdL;
                FdL_dc       =  FdL;
                H_dc         =  H;
                eta_p_dc     =  eta_p;
                Gvsatinv_dc  =  Gvsatinv;
                x_ds_dc      =  x_ds;
                x_m_dc       =  x_m;
                Gf_dc        =  Gf;
                Vdsat_dc     =  Vdsat;
                Udse_dc      =  Udse;
                Gmob_dc      =  Gmob;
                xitsb_dc     =  xitsb;
                Vdse_dc      =  Vdse;
            end // SPcalc_dc

            if (xg_dc <= 0) begin
                Ids          =  0.0;
            end else begin

// Drain-source current

                Ids          =  BET_i * (FdL_dc * qim1_dc * dps_dc * Gvsatinv_dc);
            end

// Surface potential in gate overlap regions

            if (((swigate != 0) && ((IGOV_i > 0.0) || (IGOVD_i > 0.0))) || ((swgidl != 0) && ((AGIDL_i > 0.0) || (AGIDLD_i > 0.0))) || (CGOV_i > 0.0) || (CGOVD_i > 0.0) || (CGOVD2_i > 0.0)) begin
                SP_OV_xg     = 0.5 * (xgs_ov + sqrt(xgs_ov * xgs_ov + SP_OV_eps2_s));
                xs_ov        = -SP_OV_xg - GOV2_s * 0.5 + GOV_s * sqrt(SP_OV_xg + GOV2_s * 0.25 + SP_OV_a_s) + SP_OV_delta1_s;
                Vovs         = -phita * (xgs_ov + xs_ov);
                phib_ov_d    =  Eg + 2.0 * phita * ln(NOVD_i * pow(phibFac, -0.75) * 4.0e-26);
                phib_ov_d    = `MAX(phib_ov_d, 5.0E-2);
                phix_ov_d    =  VdbPrime + phib_ov_d;
                lphi_ov_d    =  0.05 * phib_ov_d;
                aphi_ov_d    =  lphi_ov_d * lphi_ov_d;
                xn_ov_d      = `MAXA(phix_ov_d, lphi_ov_d, aphi_ov_d);
                xn_ov_d      =  xn_ov_d * inv_phita;
                if (xn_ov_d < `se) begin
                    delta_novd   =  exp(-xn_ov_d);
                end else begin
                    delta_novd   =  `ke / `P3(xn_ov_d - `se);
                end
                xd_ov        = -sp_s(xgd_ov, xn_ov_d, delta_novd, GOV_d, GOV2_d, inv_Gf2d, xid, inv_xid, margind, phix_ov_d);
                Vovd         = -phita * (xgd_ov + xd_ov);
                if (CGOVD2_i > 0.0) begin
                    phib_ov_d    =  Eg + 2.0 * phita * ln(NOVD2_i * pow(phibFac, -0.75) * 4.0e-26);
                    phib_ov_d    = `MAX(phib_ov_d, 5.0E-2);
                    phix_ov_d    =  VdxbPrime + phib_ov_d;
                    lphi_ov_d    =  0.05 * phib_ov_d;
                    aphi_ov_d    =  lphi_ov_d * lphi_ov_d;
                    xn_ov_d2     = `MAXA(phix_ov_d, lphi_ov_d, aphi_ov_d);
                    xn_ov_d2     =  xn_ov_d2 * inv_phita;
                    if (xn_ov_d2 < `se) begin
                        delta_novd2  =  exp(-xn_ov_d2);
                    end else begin
                        delta_novd2  =  `ke / `P3(xn_ov_d2 - `se);
                    end
                    xd2_ov       = -sp_s(xgd2_ov, xn_ov_d2, delta_novd2, GOV_d2, GOV2_d2, inv_Gf2d2, xid2, inv_xid2, margind2, phix_ov_d);
                    Vovd2        = -phita * (xgd2_ov + xd2_ov);
                end
            end

// Gate current

            Igsov        =  0.0;
            Igdov        =  0.0;
            Igc          =  0.0;
            Igb          =  0.0;
            Igcs         =  0.0;
            Igcd         =  0.0;
            if (swigate != 0) begin
                if (IGOV_i > 0.0) begin

// Gate-source overlap component of gate current

                    zg           =  sqrt(Vovs * Vovs + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-6);
                    end
                    temp         =  BOV * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        TP = `expl_low(temp);
                    end
                    Fs1          =  3.0 + xs_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgsPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igsov        =  IGOV_i * (TP * Fs);
                end

                if (IGOVD_i > 0.0) begin

// Gate-drain overlap component of gate current

                    zg           =  sqrt(Vovd * Vovd + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-6);
                    end
                    temp         =  BOV_d * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        TP = `expl_low(temp);
                    end
                    Fs1          =  3.0 + xd_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgdPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igdov        =  IGOVD_i * (TP * Fs);
                end

// Gate-channel component of gate current

                if (IGINV_i > 0.0) begin
                    if (xg_dc <= 0.0) begin
                        `Uss(Vds, Vdsat_lim, AR_i, temp)
                        Udse_dc      =  temp * inv_phit1;
                    end
                    temp = `expl_low(x_ds_dc-Udse_dc);
                    Vm           =  Vsbstar_dc + phit1 * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));
                    Dch          =  GCO_i * phit1;
                    arg2mina     =  Voxm_dc + Dch;
                    psi_t        = `MINA(0.0, arg2mina, 0.01);
                    zg           =  sqrt(Voxm_dc * Voxm_dc + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-06);
                    end
                    arg1         =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1);
                    Dsi = `expl(arg1);
                    arg1         = -(Vgs + Vsbstar_dc - Vm) * inv_phit1;
                    temp = `expl(arg1);
                    Dgate        =  Dsi * temp;
                    temp         =  BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0) begin
                        TP           = `P3(temp);
                    end else begin
                        TP = `expl_low(temp);
                    end
                    Igc0         =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

// Source/drain partitioning of gate-channel current

                    if ((xg_dc <= 0.0) || ((GC2_i == 0.0) && (GC3_i == 0.0))) begin
                        igc          =  1.0;
                        igcd_h       =  0.5;
                    end else begin
                        temp         =  GC2_i + 2.0 * GC3_i * zg;
                        u0           =  CHIB_i / (temp * BCH);
                        x            =  0.5 * (dps_dc / u0);
                        u0_div_H     =  u0 / H_dc;
                        Bg           =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                        Ag           =  0.5 - 3.0 * Bg;
                        if (x < 1.0e-3) begin
                            xsq          =  x * x;
                            igc          =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                            igcd_h       =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                        end else begin
                            inv_x        =  1.0 / x;
                            ex = `expl(x);
                            inv_ex       =  1.0 / ex;
                            temp         =  ex - inv_ex;
                            temp2        =  ex + inv_ex;
                            igc          =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                            igcd_h       =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                        end
                    end
                    Sg           =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-6));
                    Igc          =  Igc0 * igc * Sg;
                    Igcd         =  Igc0 * igcd_h * Sg;
                    Igcs         =  Igc - Igcd;
                    Igb          =  Igc0 * igc * (1.0 - Sg);
                end // (iginv >0)
            end // (swigate != 0)

// GIDL/GISL current

            Igidl        =  0.0;
            Igisl        =  0.0;
            if (swgidl != 0) begin

// GIDL current computation

                if ((AGIDLD_i > 0) && (Vovd < 0)) begin
                    Vtovd        =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                    temp         = -BGIDLDs / Vtovd;
                    temp2 = `expl_low(temp);
                    Igidl        = -AGIDLDs * (VdbPrime * Vovd * Vtovd * temp2);
                end

// GISL current computation

                if ((AGIDL_i > 0) && (Vovs < 0)) begin
                    Vtovs        =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-6);
                    temp         = -BGIDLs / Vtovs;
                    temp2 = `expl_low(temp);
                    Igisl        = -AGIDLs * (VsbPrime * Vovs * Vtovs * temp2);
                end
            end // (swgidl != 0)

// Drain current of edge transistors: PSP 103.4

            xgedge       =  0.0;
            qdseffedge   =  0.0;
            qmeffedge    =  0.0;
            dsqredge     =  1.0e-40;
            alphabmedge  =  1.0;
            Idsedge      =  0.0;
            if ((swedge != 0.0) && (BETNEDGE_i > 0)) begin
                temp         = `MINA(Vdb, Vsb, bphiedge) + phixedge;
                Vsbstaredge  =  Vsb - `MINA(temp, 0, aphiedge) + phix1edge;
                Vsbxedge     =  Vsbstaredge + 0.5 * (Vds - Vdsx);
                dphit1edge   =  PSCEEDGE_i * (1 + PSCEDEDGE_i * Vdsx)* (1.0 + PSCEBEDGE_i * Vsbxedge); // SCE on subthreshold slope
                phit1edge    =  phit0edge * (1.0 + dphit1edge);
                inv_phit1edge =  1.0 / phit1edge;
                if (CFDEDGE_i < 0.05) begin
                    Vdspedge     =  Vdsx;
                end else begin
                    Vdspedge     =  2.0 * (sqrt(1.0 + CFDEDGE_i * Vdsx) - 1.0) / CFDEDGE_i;
                end
                delVgedge    =  CFEDGE_i * Vdspedge * (1 + CFBEDGE_i * Vsbxedge); // DIBL effect
                xgedge       =  inv_phit1edge * (Vgs + Vsbstaredge + delVgedge - VFBEDGE_T);
                xbedge       =  inv_phit1edge * phibedge;
                dxthedge     =  2.0 * ln(xbedge / Gfedge + sqrt(xbedge));
                xnedge_s     =  inv_phit1edge * Vsbstaredge;
                `qi_edge(qseffedge,xgedge,xnedge_s)
                xnedge_d     =  inv_phit1edge * (Vdse_dc + Vsbstaredge);
                if ((qseffedge < 1.0e-3)&&(Vdse_dc < 1.0e-6)) begin
                    temp = `expl_low((-xnedge_d + xnedge_s));
                    qdseffedge   =  qseffedge * (temp - 1.0);
                    qdeffedge    =  qdseffedge + qseffedge;
                end else begin
                    `qi_edge(qdeffedge,xgedge,xnedge_d)
                    qdseffedge   =  qdeffedge - qseffedge;
                end
                qmeffedge    =  0.5 * (qdeffedge + qseffedge);
                dsqredge     =  max(xgedge - qmeffedge, 1.0e-40);
                alphabmedge  =  1.0 - 0.5 * Gfedge / sqrt(dsqredge + 0.25 * Gfedge2);
                Idsedge      = -BETEDGE_i * phit1edge * phit1edge * (alphabmedge * qmeffedge  + 1.0) * qdseffedge / Gmob_dc;
            end

// Impact-Ionization

            if ((xg_dc > 0) && (swimpact != 0)) begin
                delVsat      =  Vds_ii - `MAXA((A3_i+a3cvd_t*pow(Vds_ii, a3mvd)), 0, 0.001)*dps_dc;
                if (delVsat > 0) begin
                    temp2        =  A2_T * ((1.0 + A4_i * (sqrt(phib_dc + Vsbstar_dc) - sqrt_phib_dc)) / (delVsat + 1.0e-30));
                    temp = `expl(-temp2);
                    mavl         =  A1_i * (delVsat * temp);
                    Iimpact      =  mavl * (Ids + Idsedge);
                end
            end

// Threshold voltage calculation for .OP

            P_D          =  1.0 + 0.25 * (Gf_dc * kpp);
            facvsb0      =  phib_dc + 2.0 * phit1;
            facvsb       =  Vsbstar_dc + facvsb0;
            vts_i        =  VFB_T + P_D * facvsb - Vsbstar_dc + Gf_dc * sqrt(phit1 * facvsb );
            vth_i        =  vts_i - delVg;

//
//  evaluateStatic code from JFETIDG code
//

            dt_et    =  Temp(b_rth);
            Vdsdr      =  type*V(b_rd);
            Vgbs     =  type*V(b_gbs);
            Vgbd     =  type*V(b_gbd);
            Vgts     =  type*V(b_gts);
            Vgtd     =  type*V(b_gtd);

//
//      Temperature dependent calculations
//

            tdevC    = $temperature+dta+dt_et-`P_CELSIUS0;
            tdevC    = `CLIPB1p0(tdevC, tminclip, tmaxclip);
            tdevK    =  tdevC+`P_CELSIUS0;
            phi_t    = `P_K_NIST2010*tdevK/`P_Q_NIST2010;
            rT       =  tdevK/tiniK;
            dT       =  tdevK-tiniK;
            ni       = `niPsp_m3(tdevK, `P_K_NIST2010, `P_Q_NIST2010);
            if (!swbgmos && ( (swgeo&&!$param_given(dfbo)) || (!swgeo&&!$param_given(dfb)) ) ) begin
                psirb_t  =  2.0*phi_t*ln(nc*nb/(ni*ni))*(1.0+dT*(tc1psirb+dT*tc2psirb));
            end else begin
                psirb_t  =  psirb_i*(1.0+dT*(tc1psirb+dT*tc2psirb));
            end
            psirb_t  = `MAXA(psirb_t, 0.1, 0.01);
            if (!swtgmos && ( (swgeo&&!$param_given(dfto)) || (!swgeo&&!$param_given(dft)) ) ) begin
                psirt_t  =  2.0*phi_t*ln(nc*nt/(ni*ni))*(1.0+dT*(tc1psirt+dT*tc2psirt));
            end else begin
                psirt_t  =  psirt_i*(1.0+dT*(tc1psirt+dT*tc2psirt));
            end
            psirt_t  = `MAXA(psirt_t, 0.1, 0.01);
            tcr      =  tcrref+dT*(tc1_i+tsl_i+dT*tc2_i)+tshl_i*`MAXA(tdevC-tsct_i, 0.0, tssmsq_i);
            tcr      = `CLIPL0p1(tcr, 0.01);
            gf       =  gzd/tcr;
            if (swgeo) begin
                gf_per_w   =  gf/weff_m;
            end else begin
                gf_per_w   =  gf;
            end
            atspo    =  2.2*phi_t;                    // makes Vdsdr variation close to 1.0-exp(-Vdsdr/phi_t) in source pinch-off
            nspofac  =  1.0/(nspo_i*phi_t);
            beta_t   =  pow(rT, xbeta)*beta;
            if (tegth==0.0) begin
                gth_t    = gth_i;
            end else begin                            // model inherently includes effect of dt_et on gth (Paasschens, BCTM 2004)
                gth_t    = gth_i*pow(($temperature+dta)/tiniK, tegth);
            end
            tcvsat   =  0.0; // explicitly set here, for no vsat case, to avoid hidden states
            vcorn_t  =  0.0;
            vcrit_t  =  0.0;
            ivcrit   =  0.0;
            invDv    =  0.0;
            if (vcrit_i>0.0) begin
                tcvsat   =  pow(rT, xvsat_i);
                vcorn_t  =  vcorn_i*tcvsat*tcr;
                vcrit_t  =  vcrit_i*tcvsat*tcr;
                vcrneff  =  2.0*du*vcrit_t; // intermediate quantity
                vcrneff  =  sqrt(vcorn_t*vcorn_t+vcrneff*vcrneff)-vcrneff;
                ivcrit   =  1.0/vcrit_t;
                invDv    =  1.0/(vcrit_t-vcorn_t);
            end
            kfn_t    =  (1+dT*tc1kfn)*kfn;
            kfn_t    = `MAX(kfn_t, 0.0);

//
//      Analog function that calculates current through the JFET body
//

            sigVdr       =  1.0;
            if (Vdsdr < 0.0) begin
                sigVdr       = -1.0;
            end
            Idsdr      =  jfetidgIds(Vdsdr, Vgbs, Vgts,
                              swdrlin, phi_t, psirb_t, dfb_i, psirt_t, dft_i, ats_i, atspo, axs_i, nspofac,
                              gf, grpo, invDv, vcrneff, ivcrit, dufctr, uoff,
                              diblb_i, diblt_i, diblv, dible, diblo,
                              clm1_i, clm1c, clm2_i, clm2v, clm2e, clm2o,
                              expmvoff, moffspo,
                              mumb_i, mumboff, mumbs, mumbe, mumt_i, mumtoff, mumts, mumte,
                              alphab_i, alphat_i, beta_t, mumii1_i, mumii2_i, jhc, mhc, gf_per_w,
                              geff, iiFac, Vsp, Vdsatdr); // these are the outputs
            if (swvdiclmp) begin
                tmpx       = `MAXA(vdi0_i+VdsPrime_ld*vdisl_i+VgsPrime*vdislg_i, vdimin, 0.1);
                Idsdr      =  Idsdr/(1+`expl((VdsPrime-tmpx)/vdismooth));
            end

//
//      Impact ionization currents (note that Idsdr already has source/drain flip applied)
//

            Ipgbs    =  0.0;
            Ipgbd    =  0.0;
            Ipgts    =  0.0;
            Ipgtd    =  0.0;
            if ((alphab_i>0.0)&&(abs(Vdsdr)>0.0)) begin
                if (Vdsdr>0.0) begin
                    Ipgbd    =  Ipgbd-Idsdr*alphab_i*iiFac;
                end else begin
                    Ipgbs    =  Ipgbs+Idsdr*alphab_i*iiFac;
                end
            end
            if ((alphat_i>0.0)&&(abs(Vdsdr)>0.0)) begin
                if (Vdsdr>0.0) begin
                    Ipgtd    =  Ipgtd-Idsdr*alphat_i*iiFac;
                end else begin
                    Ipgts    =  Ipgts+Idsdr*alphat_i*iiFac;
                end
            end

//
//  Self-heating
//

            if ((swet)&&($port_connected(dt)||gth_i>0.0)) begin
                Pdiss    =  (Ids+Idsedge)*Vds+Idsdr*Vdsdr+Ipgbs*Vgbs+Ipgbd*Vgbd+Ipgts*Vgts+Ipgtd*Vgtd;
                if (gth_i>1.0e-6) begin // anything lower means turn it off
                    if (tegth==0.0) begin
                        Irth     =  gth_t*dt_et;
                    end else begin
                        tambC    = $temperature+dta-`P_CELSIUS0;
                        tambC    = `CLIPB1p0(tambC, tminclip, tmaxclip);
                        tambK    =  tambC+`P_CELSIUS0;
                        if (abs(tegth+1.0)>0.1) begin
                            Irth     =  gth_t*tambK*(pow((1.0+dt_et/tambK), (1.0+tegth))-1.0)/(1.0+tegth);
                        end else begin
                            Irth     =  gth_t*dt_et*(1.0+0.5*tegth*dt_et/tambK);
                        end
                    end
                end else begin
                    Irth     =  1.0e06*dt_et;  // avoid problems if connected but gth_i is zero
                end
            end else begin                 // self-heating is turned off
                Pdiss    =  0.0;
                Irth     =  1.0e06*dt_et;  // becomes singular without this
            end

//
//  Polarity flipping
//

            Idsdr    =  type*Idsdr;
            Ipgbs    =  type*Ipgbs;
            Ipgbd    =  type*Ipgbd;
            Ipgts    =  type*Ipgts;
            Ipgtd    =  type*Ipgtd;


//
//  source/bulk and drain/bulk junction diode currents
//

            idsatbot     =  0.0;
            idsatsti     =  0.0;
            idsatgat     =  0.0;
            iIkbot       =  0.0;
            iIksti       =  0.0;
            iIkgat       =  0.0;
            vbibot       =  0.0;
            vbisti       =  0.0;
            vbigat       =  0.0;
            ijun_s       =  0.0;
            ijunbot_s    =  0.0;
            ijunsti_s    =  0.0;
            ijungat_s    =  0.0;
            cjobot       =  0.0;
            cjosti       =  0.0;
            cjogat       =  0.0;
            i4Qdiffbot   =  0.0;
            i4Qdiffsti   =  0.0;
            i4Qdiffgat   =  0.0;
            i4Noisebot   =  0.0;
            i4Noisesti   =  0.0;
            i4Noisegat   =  0.0;

            idsatbot_d   =  0.0;
            idsatsti_d   =  0.0;
            idsatgat_d   =  0.0;
            iIkbot_d     =  0.0;
            iIksti_d     =  0.0;
            iIkgat_d     =  0.0;
            vbibot_d     =  0.0;
            vbisti_d     =  0.0;
            vbigat_d     =  0.0;
            ijun_d       =  0.0;
            ijunbot_d    =  0.0;
            ijunsti_d    =  0.0;
            ijungat_d    =  0.0;
            cjobot_d     =  0.0;
            cjosti_d     =  0.0;
            cjogat_d     =  0.0;
            i4Qdiffbot_d =  0.0;
            i4Qdiffsti_d =  0.0;
            i4Qdiffgat_d =  0.0;
            i4Noisebot_d =  0.0;
            i4Noisesti_d =  0.0;
            i4Noisegat_d =  0.0;

            idsatbot_x   =  0.0;
            idsatsti_x   =  0.0;
            iIkbot_x     =  0.0;
            iIksti_x     =  0.0;
            iIkgat_d     =  0.0;
            vbibot_x     =  0.0;
            vbisti_x     =  0.0;
            ijun_x       =  0.0;
            ijunbot_x    =  0.0;
            ijunsti_x    =  0.0;
            cjobot_x     =  0.0;
            cjosti_x     =  0.0;
            i4Qdiffbot_x =  0.0;
            i4Qdiffsti_x =  0.0;
            i4Noisebot_x =  0.0;
            i4Noisesti_x =  0.0;

            egTdevj      =  eglev == 1 ? egdelta+`egTsividis(tdevK) : `egSze(tdevK, phig, alphaeg, betaeg);
            phi_tj       = `P_K_NIST2002*tdevK/`P_Q_OLD;
            inv2Phit     =  0.5/phi_tj;
            sq2Phit      =  4.0*phi_tj*phi_tj;

//
//  The temperature dependent parameter mappings must be here for self-consistent electrothermal modeling
//

            if (ABSOURCE_i > 0.0) begin
                vLin         =  pnjVarsT(ABSOURCE_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrbot, nkbot, xikbot,
                                     cjorbot, vbirbot, pbot, idsatrbot, nbot, xisbot, imax, csrhrbot, ctatrbot, mefftatbot, cbbtrbot, fbbtrbot, stfbbt,
                                     vbrrbot, alphabrj, pbrbot, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkbot, vbibot, cjobot, idsatbot, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                         // outputs
                ijunbot_s    =  pnjI(Vjun_s, idsatbot, invnPhit, vLin, iIkbot, nkbot,
                                     csrh, vbibot, vbibot, pbot, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0bot,
                                     ctat, aTAT, bTATfctr, pd1mpbot, cbbt, fbbt, vbirbot, vbbtLimbot,
                                     vbrLim, invVbr, pbrbot, fbrLim, fbrDer,
                                     i4Qdiffbot, i4Noisebot); // additional outputs
            end
            if (LSSOURCE_i > 0.0) begin
                vLin         =  pnjVarsT(LSSOURCE_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrsti, nksti, xiksti,
                                     cjorsti, vbirsti, psti, idsatrsti, nsti, xissti, imax, csrhrsti, ctatrsti, mefftatsti, cbbtrsti, fbbtrsti, stfbbt,
                                     vbrrsti, alphabrj, pbrsti, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIksti, vbisti, cjosti, idsatsti, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                         // outputs
                ijunsti_s    =  pnjI(Vjun_s, idsatsti, invnPhit, vLin, iIksti, nksti,
                                     csrh, vbisti, vbisti, psti, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0sti,
                                     ctat, aTAT, bTATfctr, pd1mpsti, cbbt, fbbt, vbirsti, vbbtLimsti,
                                     vbrLim, invVbr, pbrsti, fbrLim, fbrDer,
                                     i4Qdiffsti, i4Noisesti); // additional outputs
            end
            if (LGSOURCE_i > 0.0) begin
                vLin         =  pnjVarsT(LGSOURCE_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrgat, nkgat, xikgat,
                                     cjorgat, vbirgat, pgat, idsatrgat, ngat, xisgat, imax, csrhrgat, ctatrgat, mefftatgat, cbbtrgat, fbbtrgat, stfbbt,
                                     vbrrgat, alphabrj, pbrgat, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkgat, vbigat, cjogat, idsatgat, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                         // outputs
                ijungat_s    =  pnjI(Vjun_s, idsatgat, invnPhit, vLin, iIkgat, nkgat,
                                     csrh, vbigat, vbigat, pgat, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0gat,
                                     ctat, aTAT, bTATfctr, pd1mpgat, cbbt, fbbt, vbirgat, vbbtLimgat,
                                     vbrLim, invVbr, pbrgat, fbrLim, fbrDer,
                                     i4Qdiffgat, i4Noisegat); // additional outputs
            end
            ijun_s = ijunbot_s+ijunsti_s+ijungat_s;

            if (ABDRAIN_i > 0.0) begin
                if (swjunasym) begin
                    vLin         =  pnjVarsT(ABDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrbotd, nkbotd, xikbotd,
                                     cjorbotd, vbirbotd, pbotd, idsatrbotd, nbotd, xisbotd, imax, csrhrbotd, ctatrbotd, mefftatbotd, cbbtrbotd, fbbtrbotd, stfbbt_d,
                                     vbrrbotd, alphabrj, pbrbotd, stvbr_d, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkbot_d, vbibot_d, cjobot_d, idsatbot_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijunbot_d    =  pnjI(Vjun_d, idsatbot_d, invnPhit, vLin, iIkbot_d, nkbotd,
                                     csrh, vbibot_d, vbibot_d, pbotd, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0bot_d,
                                     ctat, aTAT, bTATfctr, pd1mpbot_d, cbbt, fbbt, vbirbotd, vbbtLimbot_d,
                                     vbrLim, invVbr, pbrbotd, fbrLim, fbrDer,
                                     i4Qdiffbot_d, i4Noisebot_d); // additional outputs
                end else begin
                    vLin         =  pnjVarsT(ABDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrbot, nkbot, xikbot,
                                     cjorbot, vbirbot, pbot, idsatrbot, nbot, xisbot, imax, csrhrbot, ctatrbot, mefftatbot, cbbtrbot, fbbtrbot, stfbbt,
                                     vbrrbot, alphabrj, pbrbot, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkbot_d, vbibot_d, cjobot_d, idsatbot_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijunbot_d    =  pnjI(Vjun_d, idsatbot_d, invnPhit, vLin, iIkbot_d, nkbot,
                                     csrh, vbibot_d, vbibot_d, pbot, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0bot,
                                     ctat, aTAT, bTATfctr, pd1mpbot, cbbt, fbbt, vbirbot, vbbtLimbot,
                                     vbrLim, invVbr, pbrbot, fbrLim, fbrDer,
                                     i4Qdiffbot_d, i4Noisebot_d); // additional outputs
                end
            end
            if (LSDRAIN_i > 0.0) begin
                if (swjunasym) begin
                    vLin         =  pnjVarsT(LSDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrstid, nkstid, xikstid,
                                     cjorstid, vbirstid, pstid, idsatrstid, nstid, xisstid, imax, csrhrstid, ctatrstid, mefftatstid, cbbtrstid, fbbtrstid, stfbbt_d,
                                     vbrrstid, alphabrj, pbrstid, stvbr_d, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIksti_d, vbisti_d, cjosti_d, idsatsti_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijunsti_d    =  pnjI(Vjun_d, idsatsti_d, invnPhit, vLin, iIksti_d, nkstid,
                                     csrh, vbisti_d, vbisti_d, pstid, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0sti_d,
                                     ctat, aTAT, bTATfctr, pd1mpsti_d, cbbt, fbbt, vbirstid, vbbtLimsti_d,
                                     vbrLim, invVbr, pbrstid, fbrLim, fbrDer,
                                     i4Qdiffsti_d, i4Noisesti_d); // additional outputs
                end else begin
                    vLin         =  pnjVarsT(LSDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrsti, nksti, xiksti,
                                     cjorsti, vbirsti, psti, idsatrsti, nsti, xissti, imax, csrhrsti, ctatrsti, mefftatsti, cbbtrsti, fbbtrsti, stfbbt,
                                     vbrrsti, alphabrj, pbrsti, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIksti_d, vbisti_d, cjosti_d, idsatsti_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijunsti_d    =  pnjI(Vjun_d, idsatsti_d, invnPhit, vLin, iIksti_d, nksti,
                                     csrh, vbisti_d, vbisti_d, psti, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0sti,
                                     ctat, aTAT, bTATfctr, pd1mpsti, cbbt, fbbt, vbirsti, vbbtLimsti,
                                     vbrLim, invVbr, pbrsti, fbrLim, fbrDer,
                                     i4Qdiffsti_d, i4Noisesti_d); // additional outputs
                end
            end
            if (LGDRAIN_i > 0.0) begin
                if (swjunasym) begin
                    vLin         =  pnjVarsT(LGDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrgatd, nkgatd, xikgatd,
                                     cjorgatd, vbirgatd, pgatd, idsatrgatd, ngatd, xisgatd, imax, csrhrgatd, ctatrgatd, mefftatgatd, cbbtrgatd, fbbtrgatd, stfbbt_d,
                                     vbrrgatd, alphabrj, pbrgatd, stvbr_d, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkgat_d, vbigat_d, cjogat_d, idsatgat_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijungat_d    =  pnjI(Vjun_d, idsatgat_d, invnPhit, vLin, iIkgat_d, nkgatd,
                                     csrh, vbigat_d, vbigat_d, pgatd, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0gat_d,
                                     ctat, aTAT, bTATfctr, pd1mpgat_d, cbbt, fbbt, vbirgatd, vbbtLimgat_d,
                                     vbrLim, invVbr, pbrgatd, fbrLim, fbrDer,
                                     i4Qdiffgat_d, i4Noisegat_d); // additional outputs
                end else begin
                    vLin         =  pnjVarsT(LGDRAIN_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrgat, nkgat, xikgat,
                                     cjorgat, vbirgat, pgat, idsatrgat, ngat, xisgat, imax, csrhrgat, ctatrgat, mefftatgat, cbbtrgat, fbbtrgat, stfbbt,
                                     vbrrgat, alphabrj, pbrgat, stvbr, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkgat_d, vbigat_d, cjogat_d, idsatgat_d, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                    ijungat_d    =  pnjI(Vjun_d, idsatgat_d, invnPhit, vLin, iIkgat_d, nkgat,
                                     csrh, vbigat_d, vbigat_d, pgat, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0gat,
                                     ctat, aTAT, bTATfctr, pd1mpgat, cbbt, fbbt, vbirgat, vbbtLimgat,
                                     vbrLim, invVbr, pbrgat, fbrLim, fbrDer,
                                     i4Qdiffgat_d, i4Noisegat_d); // additional outputs
                end
            end
            ijun_d = ijunbot_d+ijunsti_d+ijungat_d;

            if (ABDRAINX_i > 0.0) begin
                vLin         =  pnjVarsT(ABDRAINX_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrbotx, nkbotx, xikbotx,
                                     cjorbotx, vbirbotx, pbotx, idsatrbotx, nbotx, xisbotx, imax, csrhrbotx, ctatrbotx, mefftatbotx, cbbtrbotx, fbbtrbotx, stfbbt_d,
                                     vbrrbotx, alphabrj, pbrbotx, stvbr_d, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIkbot_x, vbibot_x, cjobot_x, idsatbot_x, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                ijunbot_x    =  pnjI(Vjun_x, idsatbot_x, invnPhit, vLin, iIkbot_x, nkbotx,
                                     csrh, vbibot_x, vbibot_x, pbotx, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0bot_x,
                                     ctat, aTAT, bTATfctr, pd1mpbot_x, cbbt, fbbt, vbirbotx, vbbtLimbot_x,
                                     vbrLim, invVbr, pbrbotx, fbrLim, fbrDer,
                                     i4Qdiffbot_x, i4Noisebot_x); // additional outputs
            end
            if (LSDRAINX_i > 0.0) begin
                vLin         =  pnjVarsT(LSDRAINX_i, phi_tj, rT, dT, inv2Phit, egTdevj, egTrefj, ikrstix, nkstix, xikstix,
                                     cjorstix, vbirstix, pstix, idsatrstix, nstix, xisstix, imax, csrhrstix, ctatrstix, mefftatstix, cbbtrstix, fbbtrstix, stfbbt_d,
                                     vbrrstix, alphabrj, pbrstix, stvbr_d, `P_ME_NIST2002, `P_Q_OLD, `P_HBAR_NIST2002,
                                     invnPhit, iIksti_x, vbisti_x, cjosti_x, idsatsti_x, csrh, ctat, aTAT, bTATfctr, // outputs
                                     cbbt, fbbt, invVbr, vbrLim, fbrLim, fbrDer);                               // outputs
                ijunsti_x    =  pnjI(Vjun_x, idsatsti_x, invnPhit, vLin, iIksti_x, nkstix,
                                     csrh, vbisti_x, vbisti_x, pstix, phi_tj, inv2Phit, sq2Phit, sq2Phitr, w0sti_x,
                                     ctat, aTAT, bTATfctr, pd1mpsti_x, cbbt, fbbt, vbirstix, vbbtLimsti_x,
                                     vbrLim, invVbr, pbrstix, fbrLim, fbrDer,
                                     i4Qdiffsti_x, i4Noisesti_x); // additional outputs
            end
            ijun_x = ijunbot_x+ijunsti_x;

        end // evaluateStatic

//  --------------------------------------------------------------------------------------------------------------
//  AC bias dependent quantities (calculations for charge contribs)
//  --------------------------------------------------------------------------------------------------------------

        begin : evaluateDynamic

// Core's model calculation for AC

            begin : SPcalc_ac

// Local variable declaration

                `SPcalcLocalVarDecl

// SP calculations

                if ((swnud == 1) || (swdelvtac != 0) || (vdscale_i>1.0)) begin
                    if ((swdelvtac != 0) || (vdscale>1.0)) begin

// Conditioning of terminal voltages

                        temp         = `MINA(Vdb, Vsb, bphi_ac) + phix_ac;
                        Vsbstar_ac   =  Vsb - `MINA(temp, 0.0, aphi_ac) + phix1_ac;
                        Vsbstar      =  Vsbstar_ac;
                        phib         =  phib_ac;
                        G_0          =  G_0_ac;
                    end else begin
                        Vsbstar      =  Vsbstar_dc_tmp;
                        phib         =  phib_dc;
                        G_0          =  G_0_dc;
                    end

                    `include "PSP103_SPCalculation.include"

                    xg_ac        =  xg;
                    qeff1_ac     =  qeff1;
                    Voxm_ac      =  Voxm;
                    alpha_ac     =  alpha;
                    dps_ac       =  dps;
                    qim_ac       =  qim;
                    GdL_ac       =  GdL;
                    H_ac         =  H;
                    eta_p_ac     =  eta_p;
                end else begin
                    xg_ac        =  xg_dc;
                    qeff1_ac     =  qeff1_dc;
                    Voxm_ac      =  Voxm_dc;
                    alpha_ac     =  alpha_dc;
                    dps_ac       =  dps_dc;
                    qim_ac       =  qim_dc;
                    GdL_ac       =  GdL_dc;
                    H_ac         =  H_dc;
                    eta_p_ac     =  eta_p_dc;
                end
            end // SPcalc_ac

// Quantum mechanical corrections

            Vgb          =  Vgs + Vsb;
            COX_qm       =  COX_i;
            if (qq > 0.0) begin
                COX_qm       =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
            end

// Intrinsic charge model

            if (xg_ac <= 0.0) begin
                QG           =  Voxm_ac;
                QI           =  0.0;
                QD           =  0.0;
                QB           =  QG;
            end else begin
                Fj           =  0.5 * (dps_ac / H_ac);
                Fj2          =  Fj * Fj;
                QCLM         =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                QG           =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                temp         =  alpha_ac * dps_ac * `oneSixth;
                QI           =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                QD           =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                QB           =  QG - QI;
            end
            Qg           =  QG * COX_qm;
            Qd           = -QD * COX_qm;
            Qb           = -QB * COX_qm;

// Extrinsic charge model

            Qgs_ov       =  CGOV_i * Vovs;
            Qgd_ov       =  CGOVD_i * Vovd;
            Qgd2_ov      =  CGOVD2_i * Vovd2;
            Qgd_ov_b     =  0.0;
            Qgd2_ov_b    =  0.0;
            Qgb_ov       =  CGBOV_i * Vgb;

            if (xgd_ov > 0.0) begin
                if (CGOVD_i > 0.0) begin
                    xd_ov      = -xd_ov;
                    if (xd_ov < 1.0e-5) begin
                        Dovd       = `oneSixth * (delta_novd * xd_ov * (1.0 + 1.75 * xd_ov));   // actually Dovd/(xd_ov*xd_ov)
                        Povd       =  0.5 * (1.0 - `oneThird * (xd_ov * (1.0 - 0.25 * xd_ov))); // actually Povd/(xd_ov*xd_ov)
                        sqrtPovd   =  sqrt(Povd);                                               // actually sqrtPovd/xd_ov
                        Qgd_ov_b   = -CGOVD_i * phita * GOV_d * xd_ov * Dovd / (sqrt(Povd + Dovd) + sqrtPovd);
                    end else begin
                        xi0ovd     =  xd_ov * xd_ov / (2.0 + xd_ov * xd_ov);
                        if (xd_ov < `se05) begin
                            Eovd       =  exp(-xd_ov);
                            temp       =  delta_novd / Eovd;
                        end else if (xd_ov > (xn_ov_d - `se05)) begin
                            temp       =  exp(xd_ov - xn_ov_d);
                            Eovd       =  delta_novd / temp;
                        end else begin
                            temp       = `ke05 / `P3(xn_ov_d - xd_ov - `se05);
                            Eovd       = `ke05 / `P3(xd_ov - `se05);
                        end
                        Dovd       =  temp - delta_novd * (xd_ov + 1.0 + xi0ovd);
                        Povd       =  xd_ov - 1.0 + Eovd;
                        sqrtPovd   =  sqrt(Povd);
                        Qgd_ov_b   = -CGOVD_i * phita * GOV2_d * Dovd / (-Vovd * inv_phita + GOV_d * sqrtPovd);
                    end
                end
            end
            if (xgd2_ov > 0.0) begin
                if (CGOVD2_i > 0.0) begin
                    xd2_ov     = -xd2_ov;
                    if (xd2_ov < 1.0e-5) begin
                        Dovd       = `oneSixth * (delta_novd2 * xd2_ov * (1.0 + 1.75 * xd2_ov));  // actually Dovd/(xd2_ov*xd2_ov)
                        Povd       =  0.5 * (1.0 - `oneThird * (xd2_ov * (1.0 - 0.25 * xd2_ov))); // actually Povd/(xd2_ov*xd2_ov)
                        sqrtPovd   =  sqrt(Povd);                                                 // actually sqrtPovd/xd2_ov
                        Qgd2_ov_b  = -CGOVD_i * phita * GOV_d * xd2_ov * Dovd / (sqrt(Povd + Dovd) + sqrtPovd);
                    end else begin
                        xi0ovd     =  xd2_ov * xd2_ov / (2.0 + xd2_ov * xd2_ov);
                        if (xd2_ov < `se05) begin
                            Eovd       =  exp(-xd2_ov);
                            temp       =  delta_novd2 / Eovd;
                        end else if (xd2_ov > (xn_ov_d2 - `se05)) begin
                            temp       =  exp(xd2_ov - xn_ov_d2);
                            Eovd       =  delta_novd2 / temp;
                        end else begin
                            temp       = `ke05 / `P3(xn_ov_d2 - xd2_ov - `se05);
                            Eovd       = `ke05 / `P3(xd2_ov - `se05);
                        end
                        Dovd       =  temp - delta_novd2 * (xd2_ov + 1.0 + xi0ovd);
                        Povd       =  xd2_ov - 1.0 + Eovd;
                        sqrtPovd   =  sqrt(Povd);
                        Qgd2_ov_b  = -CGOVD2_i * phita * GOV2_d * Dovd / (-Vovd * inv_phita + GOV_d * sqrtPovd);
                    end
                end
            end
            Qgd_ov_d   =  Qgd_ov - Qgd_ov_b;
            Qgd2_ov_d  =  Qgd2_ov - Qgd2_ov_b;

// Outer fringe charge

            Qfgs         =  CFR_i * VgsPrime;
            Qfgd         =  CFRD_i * VgdPrime;

//
//  Self-heating
//

            Qcth         =  dt_et*cth_i;


//
//  source/bulk and drain/bulk junction diode depletion charges
//

            qjun_s       =  0.0;
            qjunbot_s    =  0.0;
            qjunsti_s    =  0.0;
            qjungat_s    =  0.0;
            qjun_d       =  0.0;
            qjunbot_d    =  0.0;
            qjunsti_d    =  0.0;
            qjungat_d    =  0.0;
            qjun_x       =  0.0;
            qjunbot_x    =  0.0;
            qjunsti_x    =  0.0;

            if ((ABSOURCE_i>0.0)&&(cjorbot>0.0)) begin
                qjunbot_s    =  cjobot*qj(Vjun_s, vbibot, pbot, fc, aj);
            end
            if ((LSSOURCE_i>0.0)&&(cjorsti>0.0)) begin
                qjunsti_s    =  cjosti*qj(Vjun_s, vbisti, psti, fc, aj);
            end
            if ((LGSOURCE_i>0.0)&&(cjorgat>0.0)) begin
                qjungat_s    =  cjogat*qj(Vjun_s, vbigat, pgat, fc, aj);
            end
            if (swjunasym) begin
                if ((ABDRAIN_i>0.0)&&(cjorbotd>0.0)) begin
                    qjunbot_d    =  cjobot_d*qj(Vjun_d, vbibot_d, pbotd, fc, aj);
                end
                if ((LSDRAIN_i>0.0)&&(cjorstid>0.0)) begin
                    qjunsti_d    =  cjosti_d*qj(Vjun_d, vbisti_d, pstid, fc, aj);
                end
                if ((LGDRAIN_i>0.0)&&(cjorgatd>0.0)) begin
                    qjungat_d    =  cjogat_d*qj(Vjun_d, vbigat_d, pgatd, fc, aj);
                end
            end else begin // note that _d parameters are set from source parameters
                if ((ABDRAIN_i>0.0)&&(cjorbot>0.0)) begin
                    qjunbot_d    =  cjobot_d*qj(Vjun_d, vbibot_d, pbot, fc, aj);
                end
                if ((LSDRAIN_i>0.0)&&(cjorsti>0.0)) begin
                    qjunsti_d    =  cjosti_d*qj(Vjun_d, vbisti_d, psti, fc, aj);
                end
                if ((LGDRAIN_i>0.0)&&(cjorgat>0.0)) begin
                    qjungat_d    =  cjogat_d*qj(Vjun_d, vbigat_d, pgat, fc, aj);
                end
            end
            if ((ABDRAINX_i>0.0)&&(cjorbotx>0.0)) begin
                qjunbot_x    =  cjobot_x*qj(Vjun_x, vbibot_x, pbotx, fc, aj);
            end
            if ((LSDRAINX_i>0.0)&&(cjorstix>0.0)) begin
                qjunsti_x    =  cjosti_x*qj(Vjun_x, vbisti_x, pstix, fc, aj);
            end

            qjun_s        =  qjunbot_s + qjunsti_s + qjungat_s;
            qjun_d        =  qjunbot_d + qjunsti_d + qjungat_d;
            qjun_x        =  qjunbot_x + qjunsti_x;

`ifdef diodeReverseRecovery
            qDiffEqs      =  ttbot*i4Qdiffbot + ttsti*i4Qdiffsti + ttgat*i4Qdiffgat;
            if (swjunasym) begin
                qDiffEqd     =  ttbotd*i4Qdiffbot_d + ttstid*i4Qdiffsti_d + ttgatd*i4Qdiffgat_d;
            end else begin
                qDiffEqd     =  ttbot*i4Qdiffbot_d + ttsti*i4Qdiffsti_d + ttgat*i4Qdiffgat_d;
            end
            qDiffEqx     =  ttbotx*i4Qdiffbot_x + ttstix*i4Qdiffsti_x;
            qDiffs       =  V(b_qrrs);
            qDiffd       =  V(b_qrrd);
            qDiffx       =  V(b_qrrx);
`else
            qDiffs       =  ttbot*i4Qdiffbot + ttsti*i4Qdiffsti + ttgat*i4Qdiffgat;
            if (swjunasym) begin
                qDiffd       =  ttbotd*i4Qdiffbot_d + ttstid*i4Qdiffsti_d + ttgatd*i4Qdiffgat_d;
            end else begin
                qDiffd       =  ttbot*i4Qdiffbot_d + ttsti*i4Qdiffsti_d + ttgat*i4Qdiffgat_d;
            end
            qDiffx       =  ttbotx*i4Qdiffbot_x + ttstix*i4Qdiffsti_x;
`endif

        end // evaluateDynamic

//  --------------------------------------------------------------------------------------------------------------
//  Current contribs
//  --------------------------------------------------------------------------------------------------------------

        begin : loadStatic

// Convert back for NMOS-PMOS and Source-Drain interchange

            if (sigVds > 0.0) begin
                I(b_dbi)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(b_dsi)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(b_gsi)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(b_gdi)    <+  CHNL_TYPE * MULT_i * Igcd;
            end else begin
                I(b_sbi)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(b_dsi)    <+ -CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(b_gdi)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(b_gsi)    <+  CHNL_TYPE * MULT_i * Igcd;
            end
            I(b_gbi)    <+  CHNL_TYPE * MULT_i * Igb;
            I(b_gsi)    <+  CHNL_TYPE * MULT_i * Igsov;
            I(b_gdi)    <+  CHNL_TYPE * MULT_i * Igdov;
            I(b_sbi)    <+  CHNL_TYPE * MULT_i * Igisl;
            I(b_dbi)    <+  CHNL_TYPE * MULT_i * Igidl;
            I(b_bsd)    <+  CHNL_TYPE * MULT_i * ijun_s;
            I(b_bdd)    <+  CHNL_TYPE * MULT_i * ijun_d;
            I(b_bxd)    <+  CHNL_TYPE * MULT_i * ijun_x;

            I(b_rd)     <+  Idsdr * MULT_i;
            I(b_gbs)    <+  Ipgbs * MULT_i;
            I(b_gbd)    <+  Ipgbd * MULT_i;
            I(b_gts)    <+  Ipgts * MULT_i;
            I(b_gtd)    <+  Ipgtd * MULT_i;

            `collapsibleR(b_rg , RGE_i  , RGE_i  , TKD, rthresh, mMod, 0, swnoise, `P_K_NIST2002, "rgate thermal noise")
            `collapsibleR(b_rjs, RJUNS_i, RJUNS_p, TKD, rthresh, mMod, 0, swnoise, `P_K_NIST2002, "rjuns thermal noise")
            `collapsibleR(b_rjd, RJUND_i, RJUND_p, TKD, rthresh, mMod, 0, swnoise, `P_K_NIST2002, "rjund thermal noise")
            `collapsibleR(b_rjx, RJUNX_i, RJUNX_p, TKD, rthresh, mMod, 0, swnoise, `P_K_NIST2002, "rjunx thermal noise")
            `collapsibleR(b_rb,  RBULK_i, RBULK_p, TKD, rthresh, mMod, 0, swnoise, `P_K_NIST2002, "rbulk thermal noise")

            I(b_dsi)    <+ `SIMPARGMIN * V(b_dsi);

            Pwr(b_rth)  <+ -Pdiss * MULT_i;
            Pwr(b_rth)  <+  Irth * MULT_i;

`ifdef diodeReverseRecovery
            if (trrs > 0.0) begin
                I(b_qrrs)   <+  qDiffs * `QSCALE;
                I(b_qrrs)   <+ -qDiffEqs;
            end else begin
                V(b_qrrs)   <+  0.0;
            end
            if ((swjunasym && trrd > 0.0) || ((!swjunasym) && trrs > 0.0)) begin
                I(b_qrrd)   <+  qDiffd * `QSCALE;
                I(b_qrrd)   <+ -qDiffEqd;
            end else begin
                V(b_qrrd)   <+  0.0;
            end
            if (trrx > 0.0) begin
                I(b_qrrx)   <+  qDiffx * `QSCALE;
                I(b_qrrx)   <+ -qDiffEqx;
            end else begin
                V(b_qrrx)   <+  0.0;
            end
`endif

        end // loadStatic

        begin : loadDynamic

// Local variable

            real temp;

// Intrinsic MOSFET charges

            Qs           =  -(Qg + Qb + Qd);

// Total outerFringe + overlap for gate-source and gate-drain.

            Qfgs         =  Qfgs + Qgs_ov;
            Qfgd         =  Qfgd + Qgd_ov_d;
            Qgb_ov       =  Qgb_ov + Qgd_ov_b;


// Convert back (undo S-D interchange)

            if (sigVds < 0.0) begin
                temp         =  Qd;    // Qd <--> Qs
                Qd           =  Qs;
                Qs           =  temp;
            end

            I(b_gsi)    <+  ddt(CHNL_TYPE * MULT_i * Qg);
            I(b_sbi)    <+  ddt(CHNL_TYPE * MULT_i *-Qb);
            I(b_dsi)    <+  ddt(CHNL_TYPE * MULT_i * Qd);
            I(b_gsi)    <+  ddt(CHNL_TYPE * MULT_i * Qfgs);
            I(b_gtd)    <+  ddt(CHNL_TYPE * MULT_i * Qgd2_ov_d);
            I(b_gtb)    <+  ddt(CHNL_TYPE * MULT_i * Qgd2_ov_b);
            I(b_gdi)    <+  ddt(CHNL_TYPE * MULT_i * Qfgd);
            I(b_gbi)    <+  ddt(CHNL_TYPE * MULT_i * Qgb_ov);
            I(b_bsd)    <+  ddt(CHNL_TYPE * MULT_i * qjun_s);
            I(b_bdd)    <+  ddt(CHNL_TYPE * MULT_i * qjun_d);
            I(b_bxd)    <+  ddt(CHNL_TYPE * MULT_i * qjun_x);
`ifdef diodeReverseRecovery
            if (trrs > 0.0) begin
                I(b_qrrs)   <+  ddt(trrs * qDiffs * `QSCALE);
                I(b_bsd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffs * `QSCALE);
            end else begin
                I(b_bsd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffEqs);
            end
            if ((swjunasym && trrd > 0.0) || ((!swjunasym) && trrs > 0.0)) begin
                if (swjunasym && trrd > 0.0) begin
                    I(b_qrrd)   <+  ddt(trrd * qDiffd * `QSCALE);
                end else begin
                    I(b_qrrd)   <+  ddt(trrs * qDiffd * `QSCALE);
                end
                I(b_bdd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffd * `QSCALE);
            end else begin
                I(b_bdd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffEqd);
            end
            if (trrx > 0.0) begin
                I(b_qrrx)   <+  ddt(trrx * qDiffx * `QSCALE);
                I(b_bxd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffx * `QSCALE);
            end else begin
                I(b_bxd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffEqx);
            end
`else
            I(b_bsd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffs);
            I(b_bdd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffd);
            I(b_bxd)    <+  ddt(CHNL_TYPE * MULT_i * qDiffx);
`endif

            Pwr(b_rth)  <+  ddt(Qcth) * MULT_i;

        end // loadDynamic

//  --------------------------------------------------------------------------------------------------------------
//  Noise
//  --------------------------------------------------------------------------------------------------------------

        begin : noise
            if (swnoise) begin

// Noise variable calculation

                Sfl          =  0.0;
                Sidexc       =  0.0;
                mid          =  0.0;
                sqid         =  0.0;
                Sfledge      =  0.0;
                midedge      =  0.0;
                sqidedge     =  0.0;

// Channel noise contributions

                if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin

// Flicker noise

                    N1           =  Cox_over_q * alpha_dc * phit;
                    Nm1          =  Cox_over_q * qim1_dc;
                    Delta_N1     =  Cox_over_q * alpha_dc * dps_dc;
                    Sfl          =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                    Sfl          =  Sfl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                    Sfl          =  Sfl_prefac * Ids * Gvsatinv_dc * Sfl / N1;
                    Sfl          = `MAX(Sfl, 0.0);

// Thermal channel noise

                    H0           =  qim1_dc / alpha_dc;
                    t1           =  qim_dc / qim1_dc;
                    sqt2         =  0.5 * `oneSixth * (dps_dc / H0);
                    t2           =  sqt2 * sqt2;
                    r            =  H0 / H_dc - 1.0;
                    lc           = `MAX(1.0 - 12.0 * (r * t2), 1.0e-20);
                    lcinv2       =  1.0 / (lc * lc);
                    g_ideal      =  BET_i * (FdL_dc * qim1_dc * Gvsatinv_dc);
                    mid          =  t1 + 12.0 * t2 - 24.0 * ((1.0 + t1) * t2 * r);
                    mid          = `MAX(mid, 1.0e-40);
                    mid          =  g_ideal * lcinv2 * mid;
                    if (FNTEXC_i > 0.0) begin

// recalculate Gvsat, excluding Gmob-effect

                        temp2_exc    =  qim_dc * xitsb_dc;
                        wsat_exc     =  100.0 * (temp2_exc / (100.0 + temp2_exc));
                        if (THESATG_i < 0) begin
                            temp_exc     = 1.0 / (1.0 - THESATG_i * wsat_exc);
                        end else begin
                            temp_exc     = 1.0 + THESATG_i * wsat_exc;
                        end
                        thesat1_exc  =  THESAT_T * (temp_exc / Gmob_dc);
                        zsat_exc     =  thesat1_exc * thesat1_exc * dps_dc * dps_dc;
                        if ((CHNL_TYPE == `PMOS) && (swptest == 0)) begin
                            zsat_exc     =  zsat_exc / (1.0 + thesat1_exc * dps_dc);
                        end
                        Gvsat_exc    =  0.5 * (Gmob_dc * (1.0 + sqrt(1.0 + 2.0 * zsat_exc)));
                        gfac         =  Gmob_dc / (Gvsat_exc * lc);
                        Sidexc       =  fac_exc * Ids * Vdse_dc * gfac * gfac;
                        mid          =  mid + Sidexc / nt0;
                    end
                    sqid         =  sqrt(nt * mid);

                end

// Noise of gate leakage currents

                shot_igcsx   =  2.0 * `P_Q_OLD * abs(Igcs);
                shot_igcdx   =  2.0 * `P_Q_OLD * abs(Igcd);
                shot_igsov   =  2.0 * `P_Q_OLD * abs(Igsov);
                shot_igdov   =  2.0 * `P_Q_OLD * abs(Igdov);

// Noise of impact ionization currents

                shot_iavl    =  2.0 * `P_Q_OLD * ((mavl + 1) * abs(Iimpact));

// Noise of junctions

                jnoisex_s    =  2.0 * `P_Q_OLD * abs(ijun_s);
                jnoisex_d    =  2.0 * `P_Q_OLD * abs(ijun_d);
                jnoise_x     =  2.0 * `P_Q_OLD * abs(ijun_x);
                if (sigVds > 0.0) begin
                    shot_igs     =  shot_igcsx + shot_igsov;
                    shot_igd     =  shot_igcdx + shot_igdov;
                    jnoise_s     =  jnoisex_s;
                    jnoise_d     =  jnoisex_d + shot_iavl;
                end else begin
                    shot_igs     =  shot_igcdx + shot_igsov;
                    shot_igd     =  shot_igcsx + shot_igdov;
                    jnoise_s     =  jnoisex_s + shot_iavl;
                    jnoise_d     =  jnoisex_d;
                end

// Noise of edge transistors: PSP 103.4

                if ((swedge != 0.0) && (BETNEDGE_i > 0) && (xgedge > 0)) begin

// Flicker noise of edge transistor

                    temp1        =  4.0 * dsqredge / Gfedge2;
                    anoisedge    =  sqrt(temp1 + 1.0) / (sqrt(temp1 + 1.1) - 1.0);
                    temp1        =  Cox_over_q * phit;
                    N1edge       =  temp1 * anoisedge;
                    Nm1edge      =  temp1 * (qmeffedge + anoisedge);
                    Delta_N1edge = -temp1 * anoisedge * alphabmedge * qdseffedge;
                    Sfledge      =  (NFAEDGE_i - (NFBEDGE_i - NFCEDGE_i * N1edge) * N1edge) * ln((Nm1edge + 0.5 * Delta_N1edge) / (Nm1edge - 0.5 * Delta_N1edge));
                    Sfledge      =  Sfledge + (NFBEDGE_i + NFCEDGE_i * (Nm1edge - 2.0 * N1edge)) * Delta_N1edge;
                    Sfledge      =  Sfl_prefac_edge * Idsedge * Gvsatinv_dc * Sfledge / N1edge;
                    Sfledge      = `MAX(Sfledge, 0.0);

// Thermal channel noise of edge transistor

                    H0edge       =  phit * (qmeffedge + anoisedge) / anoisedge;
                    t1edge       =  phit1 / phit * qmeffedge / (qmeffedge + anoisedge);
                    sqt2edge     = -0.5 * `oneSixth * phit * alphabmedge * qdseffedge / H0edge;
                    t2edge       =  sqt2edge * sqt2edge;
                    redge        =  0.0;
                    temp1        =  alpha_dc * H_dc;
                    if (temp1 > 1.0e-10) begin
                        redge        =  anoisedge * H0edge / temp1 - 1.0;
                    end
                    lcedge       = `MAX(1.0 - 12.0 * (redge * t2edge), 1.0e-20);
                    lcinv2edge   =  1.0 / (lcedge * lcedge);
                    g_idealedge  =  BETEDGE_i * phit * (qmeffedge + anoisedge) * FdL_dc * Gvsatinv_dc;
                    midedge      =  t1edge + 12.0 * t2edge - 24.0 * ((1.0 + t1edge) * t2edge * redge);
                    midedge      = `MAX(midedge, 1.0e-40);
                    midedge      =  g_idealedge * lcinv2edge * midedge;
                    sqidedge     =  sqrt(ntedge * midedge);
                end

// Noise contributions

                I(b_dsi)     <+  white_noise(MULT_i * sqid * sqid, "idid");
                I(b_dsi)     <+  flicker_noise(MULT_i * sigVds * Sfl, EF_i, "flicker");
                I(b_gsi)     <+  white_noise(MULT_i * shot_igs, "igs");
                I(b_gdi)     <+  white_noise(MULT_i * shot_igd, "igd");
                I(b_bsd)     <+  white_noise(MULT_i * jnoise_s, "ibs");
                I(b_bdd)     <+  white_noise(MULT_i * jnoise_d, "ibd");
                I(b_bxd)     <+  white_noise(MULT_i * jnoise_x, "ibdx");
                I(b_dsi)     <+  flicker_noise(MULT_i * sigVds * Sfledge, EFEDGE_i, "flicker");
                I(b_dsi)     <+  white_noise(MULT_i * sqidedge * sqidedge, "ididedge");
                I(b_rd)      <+  white_noise(MULT_i * 4.0 * `P_K_NIST2002 * tdevK * geff, "drift region thermal noise");
                I(b_rd)      <+  flicker_noise(MULT_i * sigVdr*kfn_t*pow((abs(Idsdr/(weff_m))), afn)*weff_m/leff_m, bfn, "drift region flicker");
                I(b_gbs)     <+  white_noise(MULT_i * 2.0 * `P_Q_OLD * abs(Ipgbs), "drift region body-intrinsic drain shot noise");
                I(b_gbd)     <+  white_noise(MULT_i * 2.0 * `P_Q_OLD * abs(Ipgbd), "drift region body-extrinsic drain shot noise");
                I(b_gts)     <+  white_noise(MULT_i * 2.0 * `P_Q_OLD * abs(Ipgts), "drift region gate-intrinsic drain shot noise");
                I(b_gtd)     <+  white_noise(MULT_i * 2.0 * `P_Q_OLD * abs(Ipgtd), "drift region gate-extrinsic drain shot noise");

            end
        end // noise

//  --------------------------------------------------------------------------------------------------------------
//  Operating point info
//  --------------------------------------------------------------------------------------------------------------

        begin : OPinfo

// Auxiliary variables

            id_op        =  Ids + Idsedge + Iimpact - Igcd;
            is           = -Ids - Idsedge - Igcs;
            ig           =  Igcs + Igcd + Igsov + Igdov + Igb;
            ib           = -Iimpact - Igb - Igidl - Igisl;

//  Actual operation point output variables

            sdint        =  sigVds;
            ctype        =  CHNL_TYPE;
            if (sigVds < 0.0) begin
                ise          =  MULT_i * (is - Igdov + Igidl - ijun_d);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igsov + Igisl - ijun_s);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igisl - ijun_s);
                isb          =  MULT_i * (Igidl - ijun_d);
                igs          =  MULT_i * (Igcs + Igdov);
                igd          =  MULT_i * (Igcd + Igsov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igidl;
                igidl        =  MULT_i * Igisl;
                ijsbot       =  MULT_i * ijunbot_d;
                ijsgat       =  MULT_i * ijungat_d;
                ijssti       =  MULT_i * ijunsti_d;
                ijdbot       =  MULT_i * ijunbot_s;
                ijdgat       =  MULT_i * ijungat_s;
                ijdsti       =  MULT_i * ijunsti_s;
                idsatsbot    =  MULT_i * idsatbot;
                idsatssti    =  MULT_i * idsatsti;
                idsatsgat    =  MULT_i * idsatgat;
                idsatsbotd   =  MULT_i * idsatbot_d;
                idsatsstid   =  MULT_i * idsatsti_d;
                idsatsgatd   =  MULT_i * idsatgat_d;
                ijs          =  MULT_i * ijun_d;
                ijd          =  MULT_i * ijun_s;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igisl - Igcd - Igsov - ijun_s; // Total drain-current
                gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(gi));
                gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(bi));
                gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(s));
                gjs          =  MULT_i * ddx(ijun_d, V(jd));
                gjd          =  MULT_i * ddx(ijun_s, V(js));
                css          =  CHNL_TYPE * MULT_i * ddx(Qd, V(di));
                csg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(gi));
                csb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(bi));
                csd          =  css - csg - csb;
                cgs          = -CHNL_TYPE * MULT_i * ddx(Qg, V(di));
                cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(gi));
                cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(bi));
                cgd          =  cgg - cgs - cgb;
                cds          = -CHNL_TYPE * MULT_i * ddx(Qs, V(di));
                cdg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(gi));
                cdb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(bi));
                cdd          =  cdg + cds + cdb;
                cbs          = -CHNL_TYPE * MULT_i * ddx(Qb, V(di));
                cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(gi));
                cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(bi));
                cbd          =  cbb - cbs - cbg;
                cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(gi));
                cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(gi));
                cjsbot       = -MULT_i * CHNL_TYPE * ddx(qjunbot_d, V(di));
                cjsgat       = -MULT_i * CHNL_TYPE * ddx(qjungat_d, V(di));
                cjssti       = -MULT_i * CHNL_TYPE * ddx(qjunsti_d, V(di));
                cjs          =  cjsbot + cjsgat + cjssti;
                cjdbot       = -MULT_i * CHNL_TYPE * ddx(qjunbot_s, V(s));
                cjdgat       = -MULT_i * CHNL_TYPE * ddx(qjungat_s, V(s));
                cjdsti       = -MULT_i * CHNL_TYPE * ddx(qjunsti_s, V(s));
                cjd          =  cjdbot + cjdgat + cjdsti;
            end else begin
                ise          =  MULT_i * (is - Igsov + Igisl - ijun_s);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igdov + Igidl - ijun_d);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igidl - ijun_d);
                isb          =  MULT_i * (Igisl - ijun_s);
                igs          =  MULT_i * (Igcs + Igsov);
                igd          =  MULT_i * (Igcd + Igdov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igisl;
                igidl        =  MULT_i * Igidl;
                ijsbot       =  MULT_i * ijunbot_s;
                ijsgat       =  MULT_i * ijungat_s;
                ijssti       =  MULT_i * ijunsti_s;
                ijdbot       =  MULT_i * ijunbot_d;
                ijdgat       =  MULT_i * ijungat_d;
                ijdsti       =  MULT_i * ijunsti_d;
                idsatsbot    =  MULT_i * idsatbot;
                idsatssti    =  MULT_i * idsatsti;
                idsatsgat    =  MULT_i * idsatgat;
                idsatsbotd   =  MULT_i * idsatbot_d;
                idsatsstid   =  MULT_i * idsatsti_d;
                idsatsgatd   =  MULT_i * idsatgat_d;
                ijs          =  MULT_i * ijun_s;
                ijd          =  MULT_i * ijun_d;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igidl - Igcd - Igdov - ijun_d; // Total drain-current
                gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(gi));
                gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(bi));
                gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(di));
                gjs          = -MULT_i * ddx(ijun_s, V(s));
                gjd          = -MULT_i * ddx(ijun_d, V(di));
                cdd          =  CHNL_TYPE * MULT_i * ddx(Qd, V(di));
                cdg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(gi));
                cdb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(bi));
                cds          =  cdd - cdg - cdb;
                cgd          = -CHNL_TYPE * MULT_i * ddx(Qg, V(di));
                cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(gi));
                cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(bi));
                cgs          =  cgg - cgd - cgb;
                csd          = -CHNL_TYPE * MULT_i * ddx(Qs, V(di));
                csg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(gi));
                csb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(bi));
                css          =  csg + csd + csb;
                cbd          = -CHNL_TYPE * MULT_i * ddx(Qb, V(di));
                cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(gi));
                cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(bi));
                cbs          =  cbb - cbd - cbg;
                cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(gi));
                cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(gi));
                cjsbot       = -MULT_i * CHNL_TYPE * ddx(qjunbot_s, V(s));
                cjsgat       = -MULT_i * CHNL_TYPE * ddx(qjungat_s, V(s));
                cjssti       = -MULT_i * CHNL_TYPE * ddx(qjunsti_s, V(s));
                cjs          =  cjsbot + cjsgat + cjssti;
                cjdbot       = -MULT_i * CHNL_TYPE * ddx(qjunbot_d, V(di));
                cjdgat       = -MULT_i * CHNL_TYPE * ddx(qjungat_d, V(di));
                cjdsti       = -MULT_i * CHNL_TYPE * ddx(qjunsti_d, V(di));
                cjd          =  cjdbot + cjdgat + cjdsti;
            end
            weff         =  WE;
            leff         =  LE;
            if (abs(gds) < 1.0e-18) begin
                u            =  0.0;
                rout         =  0.0;
                vearly       =  0.0;
            end else begin
                u            =  gm / gds;
                rout         =  1.0 / gds;
                vearly       =  ide / gds;
            end
            if (abs(vgt) < 1.0e-12) begin
                beff         =  0.0;
            end else begin
                beff         =  2.0 * abs(ide) / (vgt * vgt);
            end
            if (abs(cgg + cgsol + cgdol) < 1.0e-30) begin
                fug          =  0.0;
            end else begin
                fug          =  gm / (2.0 * `M_PI * (cgg + cgsol + cgdol));
            end
            rg           =  RGE_i / MULT_i;
            sfl          =  MULT_i * Sfl;
            if (abs(gm) < 1.0e-18) begin
                sqrtsff      =  0.0;
                sqrtsfw      =  0.0;
            end else begin
                sqrtsff      =  sqrt(MULT_i * Sfl / 1000.0) / gm;
                sqrtsfw      =  sqrt(MULT_i) * sqid / gm;
            end
            sid          =  MULT_i * sqid * sqid;
            fknee        =  0.0;
            if (sid > 0.0) begin
                fknee        =  sfl / sid;
            end
            siavl        =  MULT_i * shot_iavl;
            if (sigVds < 0.0) begin
                sigs         =  MULT_i * (shot_igcsx + shot_igdov);
                sigd         =  MULT_i * (shot_igcdx + shot_igsov);
                ssi          =  MULT_i * jnoisex_d;
                sdi          =  MULT_i * jnoisex_s;
            end else begin
                sigs         =  MULT_i * (shot_igcsx + shot_igsov);
                sigd         =  MULT_i * (shot_igcdx + shot_igdov);
                ssi          =  MULT_i * jnoisex_s;
                sdi          =  MULT_i * jnoisex_d;
            end
            sfledge      =  MULT_i * Sfledge;
            sidedge      =  MULT_i * sqidedge;

            lp_vfb       =  VFB_T;
            lp_stvfb     =  STVFB_i;
            lp_st2vfb    =  ST2VFB_i;
            lp_tox       =  TOX_i;
            lp_epsrox    =  EPSROX_i;
            lp_neff      =  NEFF_i;
            lp_facneffac =  FACNEFFAC_i;
            lp_gfacnud   =  GFACNUD_i;
            lp_vsbnud    =  VSBNUD_i;
            lp_dvsbnud   =  DVSBNUD_i;
            lp_vnsub     =  VNSUB_i;
            lp_nslp      =  NSLP_i;
            lp_dnsub     =  DNSUB_i;
            lp_dphib     =  DPHIB_i;
            lp_delvtac   =  DELVTAC_i;
            lp_np        =  NP_i;
            lp_toxov     =  TOXOV_i;
            lp_toxovd    =  TOXOVD_i;
            lp_nov       =  NOV_i;
            lp_novd      =  NOVD_i;
            lp_toxovd2   =  TOXOVD2_i;
            lp_novd2     =  NOVD2_i;
            lp_cgovd2    =  CGOVD2_i;
            lp_ct        =  CT_T;
            lp_ctg       =  CTG_T;
            lp_ctb       =  CTB_i;
            lp_stct      =  STCT_i;
            lp_cf        =  CF_i;
            lp_cfd       =  CFD_i;
            lp_cfb       =  CFB_i;
            lp_psce      =  PSCE_i;
            lp_psceb     =  PSCEB_i;
            lp_psced     =  PSCED_i;
            lp_betn      =  BETN_T;
            lp_stbet     =  STBET_i;
            lp_mue       =  MUE_T;
            lp_stmue     =  STMUE_i;
            lp_themu     =  THEMU_T;
            lp_stthemu   =  STTHEMU_i;
            lp_cs        =  CS_T;
            lp_stcs      =  STCS_i;
            lp_thecs     =  THECS_T;
            lp_stthecs   =  STTHECS_i;
            lp_xcor      =  XCOR_T;
            lp_stxcor    =  STXCOR_i;
            lp_feta      =  FETA_i;
            lp_rs        =  RS_T;
            lp_strs      =  STRS_i;
            lp_rsb       =  RSB_i;
            lp_rsg       =  RSG_i;
            lp_thesat    =  THESAT_T;
            lp_stthesat  =  STTHESAT_i;
            lp_thesatb   =  THESATB_i;
            lp_thesatg   =  THESATG_i;
            lp_ar        =  AR_i;
            lp_alp       =  ALP_i;
            lp_alp1      =  ALP1_i;
            lp_alp2      =  ALP2_i;
            lp_vp        =  VP_i;
            lp_a1        =  A1_i;
            lp_a2        =  A2_T;
            lp_sta2      =  STA2_i;
            lp_a3        =  A3_i;
            lp_a4        =  A4_i;
            lp_gco       =  GCO_i;
            lp_iginv     =  IGINV_i;
            lp_igov      =  IGOV_i;
            lp_igovd     =  IGOVD_i;
            lp_stig      =  STIG_i;
            lp_gc2       =  GC2_i;
            lp_gc3       =  GC3_i;
            lp_chib      =  CHIB_i;
            lp_agidl     =  AGIDL_i;
            lp_agidld    =  AGIDLD_i;
            lp_bgidl     =  BGIDL_T;
            lp_bgidld    =  BGIDLD_T;
            lp_stbgidl   =  STBGIDL_i;
            lp_stbgidld  =  STBGIDLD_i;
            lp_cgidl     =  CGIDL_i;
            lp_cgidld    =  CGIDLD_i;
            lp_cox       =  COX_i;
            lp_cgov      =  CGOV_i;
            lp_cgovd     =  CGOVD_i;
            lp_cgbov     =  CGBOV_i;
            lp_cfr       =  CFR_i;
            lp_cfrd      =  CFRD_i;
            lp_fnt       =  FNT_i;
            lp_fntexc    =  FNTEXC_i;
            lp_nfa       =  NFA_i;
            lp_nfb       =  NFB_i;
            lp_nfc       =  NFC_i;
            lp_ef        =  EF_i;
            lp_vfbedge   =  VFBEDGE_T;
            lp_stvfbedge =  STVFBEDGE_i;
            lp_dphibedge =  DPHIBEDGE_i;
            lp_neffedge  =  NEFFEDGE_i;
            lp_ctedge    =  CTEDGE_i;
            lp_betnedge  =  BETNEDGE_T;
            lp_stbetedge =  STBETEDGE_i;
            lp_psceedge  =  PSCEEDGE_i;
            lp_pscebedge =  PSCEBEDGE_i;
            lp_pscededge =  PSCEDEDGE_i;
            lp_cfedge    =  CFEDGE_i;
            lp_cfdedge   =  CFDEDGE_i;
            lp_cfbedge   =  CFBEDGE_i;
            lp_fntedge   =  FNTEDGE_i;
            lp_nfaedge   =  NFAEDGE_i;
            lp_nfbedge   =  NFBEDGE_i;
            lp_nfcedge   =  NFCEDGE_i;
            lp_efedge    =  EFEDGE_i;
            lp_rg        =  RGE_i;
            lp_rjund     =  RJUND_i;
            pdiss        =  MULT_i * Pdiss;
            dtsh         =  TKD - TKA;
            tk           =  TKD;
            cjosbot      =  MULT_i * cjobot;
            cjossti      =  MULT_i * cjosti;
            cjosgat      =  MULT_i * cjogat;
            vbisbot      =  vbibot;
            vbissti      =  vbisti;
            vbisgat      =  vbigat;
            cjosbotd     =  MULT_i * cjobot_d;
            cjosstid     =  MULT_i * cjosti_d;
            cjosgatd     =  MULT_i * cjogat_d;
            vbisbotd     =  vbibot_d;
            vbisstid     =  vbisti_d;
            vbisgatd     =  vbigat_d;

        end // OPinfo

    end // evaluateblock

end // analog

endmodule
