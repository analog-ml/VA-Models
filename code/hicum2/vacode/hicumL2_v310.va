//   ***********************************************************************
//   *  HICUM/L2 version 3.1.0 (Verilog-A)                                 *
//   *  Official CMC Release                                    29.05.2024 *
//   *                                                                     *
//   *  Copyright 1993-2024 Michael Schroter                               *
//   ***********************************************************************
//   ***********************************************************************

// Empty macros defining namespaces
`define INSTANCE
`define NOISE
`define ATTR(txt)

// Comment next line, if calculation of operating point values shall be omitted
`define CALC_OP
// Uncomment next line to reduce calculation of OP values to DC case only
//`define OP_STATIC

`define Cexp_lim        80.0
`define Dexp_lim        80.0
`define DFa_fj          1.921812
`define Gmin            $simparam("gmin",0)
`define l_itmax         100
`define LN_EXP_LIMIT    11.0
`define RTOLC           1.0e-5
`define TMAX            326.85
`define TMIN            -200.0
`define VPT_thresh      1.0e2
// math and physical constants
`define M_PI        3.14159265358979323846
`define P_CELSIUS0  273.15
//`define P_HP        6.6260755e-34  //"old" SPICE
`define P_KB        1.3806226e-23  //"old" SPICE
//`define P_K         P_KB
`define P_QEL       1.6021918e-19  //"old" SPICE
//`define P_Q         P_QEL


//  OPP   operating point parameter, includes units and description for printing
//  OPM   operating point parameter, multiply value by $mfactor (eg: currents, charges)
//  OPD   operating point parameter, divide value by $mfactor (eg: resistances)
`define OPP(nam,uni,des) (* units=uni, desc=des *)                           real nam;
`define OPM(nam,uni,des) (* units=uni, desc=des, multiplicity="multiply" *)  real nam;
`define OPD(nam,uni,des) (* units=uni, desc=des, multiplicity="divide"   *)  real nam;

//  Macros for the model/instance parameters
//  BPIxx    instance & model parameter integer
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     ||
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound = 0, open upper bound = inf
//     oz    open   lower bound = 0, open upper bound = inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch (integer only, values  0 = false  and  1 = true)
//     ty    switch (integer only, values -1 = p-type and +1 = n-type)

`define BPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from[lwr:upr];

`define MPRnb(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter real    nam=def;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from[lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from(lwr:upr);
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from[lwr:upr);
`define MPRoz(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter real    nam=def from(0.0:inf);
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from(lwr:upr];
`define MPRcz(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter real    nam=def from[0.0:inf);
`define MPIsw(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter integer nam=def from[0  : 1];
`define MPIty(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter integer nam=def from[-1 : 1] exclude 0;
`define MPIcz(nam,def,uni,        des) (*units=uni,                  desc=des*) parameter real    nam=def from[0  :inf);
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                  desc=des*) parameter real    nam=def from[lwr:upr];

`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from[lwr:upr];
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from(lwr:upr];
`define IPRcz(nam,def,uni,        des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from[0.0:inf);
`define IPIsw(nam,def,uni,        des) (*units=uni,type = "instance",desc=des*) parameter integer nam=def from[0  : 1];
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from(lwr:upr);
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from[lwr:upr);
`define IPRoz(nam,def,uni,        des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def from(0.0:inf);
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni,type = "instance",desc=des*) parameter integer nam=def from[lwr:upr];
`define IPRnb(nam,def,uni,        des) (*units=uni,type = "instance",desc=des*) parameter real    nam=def;
`define IPIty(nam,def,uni,        des) (*units=uni,type = "instance",desc=des*) parameter integer nam=def from[-1: 1] exclude 0;

//`include "constants.h"
`include "discipline.h"

//////////////Explicit Capacitance and Charge Expressions///////////////

// DEPLETION CHARGE CALCULATION (no punch-through, BE junction)
// Hyperbolic smoothing used
// INPUT:
//  cj0  : zero-bias depletion capacitance
//  vd   : built-in voltage
//  z    : exponent coefficient
//  aj   : ratio of peak Cj at high forward bias to cj0
//  Vj   : voltage across junction
// IMPLICIT INPUT:
//  VT   : thermal voltage
//  OVT  : inverse thermal voltage
// OUTPUT:
//  Qj   : depletion charge
//  Cj   : depletion capacitance
`define QJMODF(cj0,vd,z,aj,Vj, Cj,Qj) \
    if (cj0 > 0.0) begin \
        DFV_f    = vd*(1.0-exp(-ln(aj)/z)); \
        DFx      = (DFV_f-Vj)*OVT; \
        DFs_q    = sqrt(DFx*DFx+`DFa_fj); \
        DFs_q2   = (DFx+DFs_q)*0.5; \
        DFv_j    = DFV_f-VT*DFs_q2; \
        DFdvj_dv = DFs_q2/DFs_q; \
        DFb      = ln(1.0-DFv_j/vd); \
        DFc_j1   = exp(-z*DFb)*DFdvj_dv; \
        Cj       = cj0*(DFc_j1+aj*(1.0-DFdvj_dv)); \
        DFq_j1   = vd*(1.0-exp(DFb*(1.0-z)))/(1.0-z); \
        Qj       = cj0*(DFq_j1+aj*(Vj-DFv_j)); \
    end else begin \
        Cj      = 0.0; \
        Qj      = 0.0; \
    end


// DEPLETION CHARGE CALCULATION CONSIDERING PUNCH THROUGH (BC, CS junctions only)
// smoothing of reverse bias region (punch-through) and limiting to Cj,max at high forward bias
// INPUT:
//  cj0  : zero-bias depletion capacitance
//  vd   : built-in voltage
//  z    : exponent coefficient
//  aj   : ratio of peak Cj at high forward bias to cj0
//  v_pt : punch-through voltage
//  Vj   : voltage across junction
// IMPLICIT INPUT:
//  VT   : thermal voltage
//  OVT  : inverse thermal voltage
// OUTPUT:
//  Qj   : depletion Charge
//  Cj   : depletion capacitance
`define QJMOD(cj0,vd,z,aj,v_pt,Vj, Cj,Qj) \
    if (cj0 > 0.0) begin \
        Dz_r    = z/4.0; \
        Dv_p    = v_pt-vd; \
        DV_f    = vd*(1.0-exp(-ln(aj)/z)); \
        DC_max  = aj*cj0; \
        DC_c    = cj0*exp((Dz_r-z)*ln(v_pt/vd)); \
        Dv_e    = (DV_f-Vj)*OVT; \
        if (Dv_e < `Cexp_lim) begin \
            De      = exp(Dv_e); \
            De_1    = De/(1.0+De); \
            Dv_j1   = DV_f-VT*ln(1.0+De); \
        end else begin \
            De_1    = 1.0; \
            Dv_j1   = Vj; \
        end \
        Da      = 0.1*Dv_p+4.0*VT; \
        Dv_r    = (Dv_p+Dv_j1)/Da; \
        if (Dv_r < `Cexp_lim) begin \
            De      = exp(Dv_r); \
            De_2    = De/(1.0+De); \
            Dv_j2   = -Dv_p+Da*(ln(1.0+De)-exp(-(Dv_p+DV_f)/Da)); \
        end else begin \
            De_2    = 1.0; \
            Dv_j2   = Dv_j1; \
        end \
        Dv_j4   = Vj-Dv_j1; \
        DCln1   = ln(1.0-Dv_j1/vd); \
        DCln2   = ln(1.0-Dv_j2/vd); \
        Dz1     = 1.0-z; \
        Dzr1    = 1.0-Dz_r; \
        DC_j1   = cj0*exp(DCln2*(-z))*De_1*De_2; \
        DC_j2   = DC_c*exp(DCln1*(-Dz_r))*(1.0-De_2); \
        DC_j3   = DC_max*(1.0-De_1); \
        Cj      = DC_j1+DC_j2+DC_j3; \
        DQ_j1   = cj0*(1.0-exp(DCln2*Dz1))/Dz1; \
        DQ_j2   = DC_c*(1.0-exp(DCln1*Dzr1))/Dzr1; \
        DQ_j3   = DC_c*(1.0-exp(DCln2*Dzr1))/Dzr1; \
        Qj      = (DQ_j1+DQ_j2-DQ_j3)*vd+DC_max*Dv_j4; \
    end else begin \
        Cj      = 0.0; \
        Qj      = 0.0; \
    end


// DEPLETION CHARGE & CAPACITANCE CALCULATION SELECTOR (BC, CS junctions only)
// Dependent on junction punch-through voltage
// INPUT:
//  cj0     : zero-bias capacitance
//  vd      : built-in voltage
//  z       : exponent coefficient
//  aj      : ratio of max to zero-bias capacitance
//  v_pt    : punch-through voltage (do not use ICK parameter vpt)
//  Vj      : voltage across junction
// OUTPUT:
//  Qj      : depletion charge
//  Cj      : depletion capacitance
`define HICJQ(cj0,vd,z,aj,v_pt,Vj, Cj,Qj) \
    if (v_pt < `VPT_thresh) begin \
        `QJMOD(cj0,vd,z,aj,v_pt,Vj, Cj,Qj) \
    end else begin \
        `QJMODF(cj0,vd,z,aj,Vj, Cj,Qj) \
    end


// Macros NEEDED FOR COLLECTOR MINORITY CHARGE FORMULATION
// INPUT:
//  zb          : latb,l
//  inv_zb      : 1.0/latb,l
//  zl_6        : latl,b/6.0 (auxiliary variable)
//  w           : normalized injection width
//  dw_ditf     : derivative of normalized injection width
// OUTPUT:
//  FCf_CS      : current spreading function (CSF) for normalized charge
//  FCdfCS_ditf : derivative of CSF with respect to injection width
`define HICFCI(zb, inv_zb, zl_6, w, FCf_CS, FCdfCS_dw) \
    FCIwzb_p1 = 1.0+zb*w; \
    FCIlnw_bl = ln(FCIwzb_p1); \
    FCIa = zl_6*inv_zb; \
    FCf_CS = FCIlnw_bl*(0.5-FCIa)*inv_zb+(FCIa+zl_6*w)*w; \
    FCdfCS_dw = (0.5-FCIa)/FCIwzb_p1+FCIa+w*zl_6*2;

// COLLECTOR CURRENT SPREADING CALCULATION
// collector minority charge incl. 2D/3D current spreading (TED 10/96)
// INPUT:
//  FFT_pcS         : dependent on fthc and thcs (parameters)
// IMPLICIT INPUT:
//  ahc, latl, latb : model parameters
//  VT              : thermal voltage
//  OVT             : inverse thermal voltage
//  itf             : forward transport current component (itf)
//  ick             : critical current
// OUTPUT:
//  Q_fC            : collector hole charge modified by CCS effect
//  T_fC            : collector storage time modified by CCS effect
`define HICQFC(FFT_pcS, Q_fC,T_fC) \
    FCick       = 1.0-FFw; \
    FCdick_ditf = (FCick-1.0)*(1.0-FFic)/(sqrt(FFic*FFic+ahc)*itf); /* derivative if ick(vces) */ \
    if (abs(lat_delta) > 0.001) begin /* rectangular emitter */ \
        FCk = exp((FCick-1.0)*ln_lat); \
        if (latmin < 0.01) begin   /* 2D case (long emitter) */ \
            FCw         = (1.0-FCk)/(FCk*latmax); \
            FClatw_p1   = 1.0+latmax*FCw; \
            FCf_ci      = 2*(latmax*FCw*(0.5+0.25*latmax*FCw)-0.5*ln(FClatw_p1))/latmax/latmax; \
            FCdw_ditf   = -ln_lat*FCdick_ditf/(FCk*latmax); \
            FCdfc_ditf  = (1.0+FClatw_p1)*FCw*FCdw_ditf/(FClatw_p1); \
        end else begin            /* general aspect ratio */ \
            FCkdelta    = latl-FCk*latb; \
            FCw         = (FCk-1.0)/FCkdelta; \
            `HICFCI(latl, inv_latl,latb_6,FCw,FCf_CSl,FCdfCSl_dw) \
            `HICFCI(latb, inv_latb,latl_6,FCw,FCf_CSb,FCdfCSb_dw) \
            FCf_ci      = (FCf_CSl-FCf_CSb)/lat_delta; \
            FCdw_ditf   = (-2.0*lat_delta)/(FCkdelta*FCkdelta)*FCk*ln_lat*FCdick_ditf; \
            FCdfc_ditf  = (FCdfCSl_dw-FCdfCSb_dw)*FCdw_ditf/lat_delta; \
        end \
    end else begin               /* square emitter */ \
        FCw           = (1.0-FCick)/(1.0+FCick*latb); \
        FClatbw       = 1.0+latb*FCw; \
        FCf_ci        = FCw*FCw*(1.0+latb_6*2.0*FCw)/FClatbw; \
        FCdw_ditf     = -FCdick_ditf*FClatbw/(1.0+FCick*latb); \
        FCdfc_ditf    = FCw*(1.0+1.0/(FClatbw*FClatbw))*FCdw_ditf; \
    end \
    FCt  = FFT_pcS*FFvc_exp*FCf_ci; \
    Q_fC = FCt*itf; \
    T_fC = FCt+Q_fC*(FFdVc_ditf*OVT+FCdfc_ditf/FCf_ci);

// TRANSIT-TIME AND STORED MINORITY CHARGE
// IMPLICIT INPUT:
//  itf     : forward transport current
//  ick     : critical current
//  tef0, gtfe, fthc, thcs, ahc, latl, latb   : model parameters
//  VT      : thermal voltage
//  OVT     : inverse thermal voltage
// IMPLICIT OUTPUT:
//  Tf      : actual transit time
//  Qf      : actual minority charge / transient analysis
//  T_fT    : weighted transit time
//  Q_fT    : weighted minority charge / ICCR (transfer current)
//  Q_bf    : excess base charge
`define HICQFF \
    Tf = T_f0; \
    Qf = T_f0*itf; \
    if (flcomp >= 310) begin \
        T_fT = hf0_t*t0_t; \
        Q_fT = T_fT*itf; \
    end else begin \
        /*Q_fT = Qf; T_fT = Tf; */ \
        Q_fT = hf0_t*Qf; \
        T_fT = hf0_t*Tf; \
    end \
    Q_bf = 0.0; \
    /*if (itf >= `RTOLC*ick) begin */ \
    if (itf >= 1.0e-6*ick) begin \
        FFitf_ick = itf/ick; \
        FFdTef  = tef0_t*exp(gtfe*ln(FFitf_ick)); \
        FFdQef  = FFdTef*itf/(1.0+gtfe); \
        if (icbar < 0.05*(vlim/rci0)) begin \
            FFdVc = 0.0; \
            FFdVc_ditf = 0.0; \
        end else begin \
            FFib    = (itf-ick)/icbar; \
            if (FFib < -1.0e10) begin \
                FFib = -1.0e10; \
            end \
            FFfcbar = sqrt(FFib*FFib+acbar); \
            FFdVc = vcbar*exp(-2.0/(FFib+FFfcbar)); \
            FFdVc_ditf = 2.0*FFdVc/(icbar*FFfcbar*(FFib+FFfcbar)); \
        end \
        FFdQbfb = (1.0-fthc)*thcs_t*itf*(exp(FFdVc*OVT)-1); \
        FFdTbfb = FFdQbfb/itf+(1.0-fthc)*thcs_t*itf*exp(FFdVc*OVT)*OVT*FFdVc_ditf; \
        FFic    = 1.0-1.0/FFitf_ick; \
        FFw     = (FFic+sqrt(FFic*FFic+ahc))/(1.0+sqrt(1.0+ahc)); \
        FFvc_exp = exp((FFdVc-vcbar)*OVT); \
        FFdQfhc = thcs_t*itf*FFw*FFw*FFvc_exp; \
        FFdTfhc = FFdQfhc*(1.0/itf*(1.0+2.0/(FFitf_ick*sqrt(FFic*FFic+ahc)))+OVT*FFdVc_ditf); \
        if ((latb < 0.01) && (latl < 0.01) && (FFw*latb < 5.0e-3) && (FFw*latl < 5.0e-3)) begin \
            FFdQcfc = fthc*FFdQfhc; \
            FFdTcfc = fthc*FFdTfhc; \
        end else begin \
            `HICQFC(fthc*thcs_t, FFdQcfc,FFdTcfc) \
        end \
        FFdQbfc = (1.0-fthc)*FFdQfhc; \
        FFdTbfc = (1.0-fthc)*FFdTfhc; \
        Q_bf    = FFdQbfb+FFdQbfc; \
        if (flcomp >= 310) begin \
            Qf   = Qf+Q_bf+FFdQef+FFdQcfc; \
            Tf   = Tf+(FFdTbfb+FFdTbfc)+FFdTef+FFdTcfc; \
            Q_fT = Q_fT+Q_bf+hfe_t*FFdQef+hfc_t*FFdQcfc; \
            T_fT = T_fT+(FFdTbfb+FFdTbfc)+hfe_t*FFdTef+hfc_t*FFdTcfc; \
        end else begin \
            Q_fT = hf0_t*Qf+Q_bf+hfe_t*FFdQef+hfc_t*FFdQcfc; \
            Qf   = Qf+Q_bf+FFdQef+FFdQcfc; \
            T_fT = hf0_t*Tf+(FFdTbfb+FFdTbfc)+hfe_t*FFdTef+hfc_t*FFdTcfc; \
            Tf   = Tf+(FFdTbfb+FFdTbfc)+FFdTef+FFdTcfc; \
        end \
    end


// IDEAL DIODE (WITHOUT CAPACITANCE):
// conductance calculation not required
// INPUT:
//  is_tnom, is_t : saturation currents (model parameter (Tnom, Tdev))
//  m             : ideality factor
//  Vb            : internal diode voltage
// IMPLICIT INPUT:
//  VT            : thermal voltage
// OUTPUT:
//  id            : diode current
`define HICDIO(is_tnom,is_t,m,Vb, id) \
    if (is_tnom > 0.0) begin \
        DIO_y = Vb/(m*VT); \
        if (DIO_y > `Dexp_lim) begin \
            DIO_le = (1.0 + (DIO_y - `Dexp_lim)); \
            DIO_y  = `Dexp_lim; \
        end else begin \
            DIO_le = 1.0; \
        end \
        id = is_t*(DIO_le*limexp(DIO_y)-1.0); \
    end else begin \
        id = 0.0; \
    end

// TEMPERATURE UPDATE OF JUNCTION CAPACITANCE RELATED PARAMETERS
// INPUT:
//  mostly model parameters
//  cj0      : zero bias junction capacitance
//  vd       : junction built-in potential
//  z        : grading co-efficient
//  aj       : ratio of maximum to zero-bias value of capacitance
//  vgeff    : band-gap voltage
// IMPLICIT INPUT:
//  VT       : thermal voltage
//  OVT      : inverse thermal voltage
//  VTnom,qtt0,ln_qtt0,mg : other model variables
//  OVTnom   : inverse thermal voltage at nominal temperature
// OUTPUT:
//  cj0_t    : temperature update of "cj0"
//  vd_t     : temperature update of "vd"
//  aj_t     : temperature update of "aj"

`define TMPHICJ(cj0,vd,z,aj,vgeff, cj0_t,vd_t,aj_t) \
    if (cj0 > 0.0) begin \
        vdj_t0 = 2.0*VTnom*ln(exp(vd*0.5*OVTnom)-exp(-0.5*vd*OVTnom)); \
        vdj_t  = vdj_t0*qtt0+vgeff*(1.0-qtt0)-mg*VT*ln_qtt0; \
        vd_t   = vdj_t+2.0*VT*ln(0.5*(1.0+sqrt(1.0+4.0*exp(-vdj_t*OVT)))); \
        cj0_t  = cj0*exp(z*ln(vd/vd_t)); \
        aj_t   = abs(aj); \
        if (aj > 0.0) begin \
            aj_t   = aj*vd_t/vd; \
        end \
    end else begin \
        cj0_t  = cj0; \
        vd_t   = vd; \
        aj_t   = aj; \
    end

// TEMPERATURE UPDATE OF THE DEVICE
// IMPLICIT INPUT:
//  all model parameters, which need temperature scaling
// OUTPUT:
//  temperature scaled model parameters
`define TMPUPDATE(dT_sh) \
    Tdev    = Tamb+dt+dT_sh; \
    /* Limit temperature to avoid FPEs in equations*/ \
    if (Tdev < `TMIN + `P_CELSIUS0) begin \
        Tdev = `TMIN + `P_CELSIUS0; \
    end else begin \
        if (Tdev > `TMAX + `P_CELSIUS0) begin \
            Tdev = `TMAX + `P_CELSIUS0; \
        end \
    end \
    VT      = KB2Q*Tdev; \
    OVT     = 1.0/VT; \
    dTdev   = Tdev-Tnom; \
    qtt0    = Tdev/Tnom; \
    ln_qtt0 = ln(qtt0); \
    k1      = f1vg*Tdev*ln(Tdev); \
    k2      = f2vg*Tdev; \
    vgb_t   = vgb+k1+k2; \
    vge_t   = vge+k1+k2; \
    vgbe_t  = (vgb_t+vge_t)/2.0; \
    /*Internal BE junction capacitance*/ \
    `TMPHICJ(cjei0,vdei,zei,ajei,vgbe0, cjei0_t,vdei_t,ajei_t) \
    /*Internal BE diode saturation currents*/ \
    ibeis_t  = ibeis*exp(zetabet*ln_qtt0+vge*OVT*(qtt0-1.0)); \
    ireis_t  = ireis*exp(mg/mrei*ln_qtt0+vgbe0/(mrei*VT)*(qtt0-1.0)); \
    /*Internal BC junction capacitance*/ \
    `TMPHICJ(cjci0,vdci,zci,ajci,vgbc0, cjci0_t,vdci_t,ajci_t) \
    if (flcomp <= 300) begin \
        ajci_t=2.4; \
    end \
    /*Internal BC diode saturation currents*/ \
    ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc*OVT*(qtt0-1)); \
    /*Zero bias hole charge*/ \
    qp0_t   = qp0*(2.0-exp(zei*ln(vdei_t/vdei))); \
    /*GICCR prefactor*/ \
    c10_t   = c10*exp(zetact*ln_qtt0+vgb*OVT*(qtt0-1)); \
    /* GICCR weight factors*/ \
    ahjei_t = ahjei*exp(zetahjei*ln_qtt0); \
    if (flcomp <= 300 && abs(hjei0-1.0) < 1e-5) begin /* left for backward compatibility only)*/ \
        hjei0_t = hjei*exp(dvgbe*OVT*(exp(zetavgbe*ln_qtt0)-1.0)); \
    end else begin \
        hjei0_t = hjei0*exp(dvgbe*OVT*(exp(zetavgbe*ln_qtt0)-1.0)); \
    end \
    hf0_t   = hf0*exp(dvgbe*OVT*(qtt0-1.0)); \
    hfe_t   = hfe*exp((vgb-vge)*OVT*(qtt0-1.0)); \
    hfc_t   = hfc*exp((vgb-vgc)*OVT*(qtt0-1.0)); \
    /*Voltage separating ohmic and saturation velocity regime*/ \
    vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0); \
    /* Low-field internal collector resistance*/ \
    rci0_t  = rci0*exp(zetaci*ln_qtt0); \
    Orci0_t = 1.0/rci0_t; \
    /* Critical current voltage*/ \
    if (vdck > 0.0) begin \
        /*Internal critical BC voltage */ \
        vdck_t = vdck*(1.0-aldck*dTdev); \
        vces_t = vces; \
    end else begin \
        /*Internal CE saturation voltage*/ \
        vces_t = vces*(1.0+alces*dTdev); \
        vdck_t = vdck; \
    end \
    /*Low-current forward transit time*/ \
    t0_t   = t0*(1.0+alt0*dTdev+kt0*dTdev*dTdev); \
    /*Neutral emitter storage time*/ \
    tef0_t = tef0; \
    /*Saturation time constant at high current densities*/ \
    thcs_t = thcs*exp((zetaci-1)*ln_qtt0); \
    /*Avalanche current factors*/ \
    if (use_aval == 1) begin \
        favl_t = favl*exp(alfav*dTdev); \
        qavl_t = qavl*exp(alqav*dTdev); \
    end else begin \
        favl_t = favl; \
        qavl_t = qavl; \
    end \
    /*Zero bias internal base resistance*/ \
    rbi0_t = rbi0*exp(zetarbi*ln_qtt0); \
    /*Peripheral BE junction capacitance*/ \
    `TMPHICJ(cjep0,vdep,zep,ajep,vgbe0, cjep0_t,vdep_t,ajep_t) \
    /*Peripheral BE diode saturation currents*/ \
    ibeps_t = ibeps*exp(zetabet*ln_qtt0+vge*OVT*(qtt0-1.0)); \
    ireps_t = ireps*exp(mg/mrep*ln_qtt0+vgbe0/(mrep*VT)*(qtt0-1.0)); \
    /*BtBT current factors*/ \
    if (ibets > 0.0 && (Vbpei < V_btbmax || Vbiei < V_btbmax)) begin \
        ab = 1.0; \
        aa = 1.0; \
        a_eg=vgbe_tnom/vgbe_t; \
        if (tunode == 1 && cjep0 > 0.0 && vdep > 0.0) begin \
            ab = (cjep0_t/cjep0)*sqrt(a_eg)*vdep_t*vdep_t/(vdep*vdep); \
            aa = (vdep/vdep_t)*(cjep0/cjep0_t)*pow(a_eg,-1.5); \
        end else if (tunode == 0 && cjei0 > 0.0 && vdei > 0.0) begin \
            ab = (cjei0_t/cjei0)*sqrt(a_eg)*vdei_t*vdei_t/(vdei*vdei); \
            aa = (vdei/vdei_t)*(cjei0/cjei0_t)*pow(a_eg,-1.5); \
        end \
        ibets_t = ibets*ab; \
        abet_t  = abet*aa; \
    end else begin \
        ibets_t = 0.0; \
        abet_t  = 1.0; \
    end \
    /*TAT current prefactor*/ \
    ibetat0_t=ibetat0*exp(-(vdei_t-vdei)/vbetat); \
    /*Temperature mapping for BtBT current is done inside HICTUN*/ \
    `TMPHICJ(1.0,vdcx,zcx,ajcx,vgbc0, cratio_t,vdcx_t,ajcx_t) \
    if (flcomp <= 300) begin \
        ajcx_t=2.4; \
    end \
    cjcx01_t=cratio_t*cjcx01; \
    cjcx02_t=cratio_t*cjcx02; \
    /*External BC diode saturation current*/ \
    ibcxs_t = ibcxs*exp(zetabcxt*ln_qtt0+vgc*OVT*(qtt0-1.0)); \
    /*Capacitance of CS junction*/ \
    if (flcomp <= 300) begin \
        `TMPHICJ(cjs0,vds,zs,-2.4,vgsc0, cjs0_t,vds_t,ajs_t) \
        a_jsp=2.4; \
    end else begin \
        `TMPHICJ(cjs0,vds,zs,-ajs,vgsc0, cjs0_t,vds_t,ajs_t) \
        a_jsp=ajs; \
    end \
    /*Saturation current of CS diode*/ \
    iscs_t  = iscs*exp(zetasct*ln_qtt0+vgs*OVT*(qtt0-1.0)); \
    /*Saturation transfer current for substrate transistor*/ \
    itss_t  = itss*exp(zetasct*ln_qtt0+vgc*OVT*(qtt0-1.0)); \
    /*Forward transit time in substrate transistor*/ \
    tsf_t   = tsf*exp((zetacx-1.0)*ln_qtt0); \
    /*Peripheral SC capacitance: thermal update only required for vdsp > 0 (junction cap)*/ \
    if (vdsp > 0.0) begin \
        `TMPHICJ(cscp0,vdsp,zsp,-a_jsp,vgsc0, cscp0_t,vdsp_t,ajsp_t) \
    end else begin \
        /* Save computional effort otherwise, avoid uninitialized variables*/ \
        cscp0_t = cscp0; \
        vdsp_t  = vdsp; \
        ajsp_t = a_jsp; \
    end \
    /*External series resistances*/ \
    rcx_t = rcx*exp(zetarcx*ln_qtt0); \
    rbx_t = rbx*exp(zetarbx*ln_qtt0); \
    re_t  = re*exp(zetare*ln_qtt0); \
    /* thermal resistance        */ \
    rth_t = rth*exp(zetarth*ln_qtt0)*(1.0+alrth*dTdev);

`ifdef __XYCE__
module hicumL2_va (c,b,e,s,tnode);
`else
module hicumL2va (c,b,e,s,tnode);
`endif

//Node definitions

inout           c,b,e,s,tnode;
electrical      c,b,e,s,ci,ei,bp,bi,si;
electrical      xf1,xf2;
electrical      xf;  //RC nw
electrical      tnode;
electrical      n1,n2;

//Branch definitions
branch          (b,bp)          br_bbp_i;
branch          (b,bp)          br_bbp_v;
branch          (ci,c)          br_cic_i;
branch          (ci,c)          br_cic_v;
branch          (ei,e)          br_eie_i;
branch          (ei,e)          br_eie_v;
branch          (bp,bi)         br_bpbi_i;
branch          (bp,bi)         br_bpbi_v;
branch          (si,s)          br_sis_i;
branch          (si,s)          br_sis_v;
branch          (bi,ei)         br_biei;
branch          (bi,ci)         br_bici;
branch          (ci,bi)         br_cibi;
branch          (ci,ei)         br_ciei;
branch          (ei,ci)         br_eici;
branch          (bp,e)          br_bpe;
branch          (b,e)           br_be;
branch          (bp,ei)         br_bpei;
branch          (bp,ci)         br_bpci;
branch          (b,ci)          br_bci;
branch          (si,ci)         br_sici;
branch          (s,c)           br_sc;   // External SC branch required for CSCp
branch          (bp,si)         br_bpsi;
branch          (tnode )        br_sht;

//Excess phase network for ITF
branch  (xf1 )  br_bxf1;
branch  (xf1 )  br_cxf1;
branch  (xf2 )  br_bxf2;
branch  (xf2 )  br_cxf2;

//Excess phase network for QF
branch  (xf )  br_bxf;  //for RC nw
branch  (xf )  br_cxf;  //for RC nw
branch  (n1 )  b_n1;
branch  (n2 )  b_n2;

// -- ###########################################################
// -- ###########     Parameter initialization  ################
// -- ###########################################################

//Backwards compatibility
`MPIcz( flcomp   ,310         ,""        ,            "Flag for compatibility with v300 model version")

//Transfer current
`MPRcc( c10      ,2.0E-30     ,"A^2s"    ,0    ,1    ,"GICCR constant")
`MPRoc( qp0      ,2.0E-14     ,"C"       ,0    ,1    ,"Zero-bias hole charge")
`MPRcz( hf0      ,1.0         ,""        ,            "Weight factor for the low current minority charge")
`MPRcz( hfe      ,1.0         ,""        ,            "Emitter minority charge weighting factor in HBTs")
`MPRcz( hfc      ,1.0         ,""        ,            "Collector minority charge weighting factor in HBTs")
`MPRcc( hjei0    ,1.0         ,""        ,0    ,100  ,"BE depletion charge weighting factor in HBTs at VBE=0")
`MPRcc( hjei     ,1.0         ,""        ,0    ,100  ,"BE depletion charge weighting factor in HBTs - old!")
`MPRcc( ahjei    ,0.0         ,""        ,0    ,100  ,"Parameter describing the slope of hjei(VBE)")
`MPRoc( rhjei    ,1.0         ,""        ,0    ,10   ,"Smoothing parameter for hjei(VBE) at high voltage")
`MPRcc( hjci     ,1.0         ,""        ,0    ,100  ,"BC depletion charge weighting factor in HBTs")
`MPRoc( mcf      ,1.0         ,""        ,0    ,10   ,"Non-ideality transfer current factor for III-V HBTs")

//Base-Emitter diode currents
`MPRcc( ibeis    ,1.0E-18     ,"A"       ,0    ,1    ,"Internal BE saturation current")
`MPRoc( mbei     ,1.0         ,""        ,0    ,10   ,"Internal BE current ideality factor")
`MPRcc( ireis    ,0.0         ,"A"       ,0    ,1    ,"Internal BE recombination saturation current")
`MPRoc( mrei     ,2.0         ,""        ,0    ,10   ,"Internal BE recombination current ideality factor")
`MPRcc( ibeps    ,0.0         ,"A"       ,0    ,1    ,"Peripheral BE saturation current")
`MPRoc( mbep     ,1.0         ,""        ,0    ,10   ,"Peripheral BE current ideality factor")
`MPRcc( ireps    ,0.0         ,"A"       ,0    ,1    ,"Peripheral BE recombination saturation current")
`MPRoc( mrep     ,2.0         ,""        ,0    ,10   ,"Peripheral BE recombination current ideality factor")

//Transit time for excess recombination current at b-c barrier
`MPRcz( tbhrec   ,0.0         ,"s"       ,            "Base current recombination time constant at BC barrier for high forward injection")

//Base-collector diode currents
`MPRcc( ibcis    ,1.0E-16     ,"A"       ,0    ,1.0  ,"Internal BC saturation current")
`MPRoc( mbci     ,1.0         ,""        ,0    ,10   ,"Internal BC current ideality factor")
`MPRcc( ibcxs    ,0.0         ,"A"       ,0    ,1.0  ,"External BC saturation current")
`MPRoc( mbcx     ,1.0         ,""        ,0    ,10   ,"External BC current ideality factor")

//Base-emitter tunneling current components
`MPRcc( ibets    ,0.0         ,"A"       ,0    ,50   ,"BE band-to-band tunneling (BtBT) saturation current")
`MPRcz( abet     ,40          ,""        ,            "Exponent factor for BE BtBT current")
`MPIsw( tunode   ,1           ,""        ,            "Specifies base node connection for BE BtBT current (1=Bp, 0=Bi)")
`MPRcc( ibetat0  ,0.0         ,"A"       ,0    ,50   ,"BE trap-assisted tunneling current prefactor")
`MPRoc( vbetat   ,1.0         ,"V"       ,0    ,10   ,"Voltage in BE TAT current exponent")

//Base-collector avalanche current
`MPRcz( favl     ,0.0         ,"1/V"     ,            "Avalanche current factor")
`MPRcz( qavl     ,0.0         ,"C"       ,            "Exponent factor for avalanche current")
`MPRcc( kavl     ,0.0         ,""        ,0    ,3    ,"Flag/factor for turning strong avalanche on")
`MPRcc( hcavl    ,0.0         ,""        ,0    ,10   ,"Factor for current dependent avalanche effect")
`MPRcc( hvdavl   ,0.0         ,""        ,0    ,10   ,"Ilim dependence for spatially varying collector doping")

//Depletion capacitances
`MPRcz( cjei0    ,1.0E-20     ,"F"       ,            "Internal BE zero-bias depletion capacitance")
`MPRoc( vdei     ,0.9         ,"V"       ,0    ,10   ,"Internal BE built-in potential")
`MPRoo( zei      ,0.5         ,""        ,0    ,1    ,"Internal BE grading coefficient")
`MPRco( ajei     ,2.5         ,""        ,1    ,inf  ,"Ratio of maximum to zero-bias value of internal BE capacitance")
`MPRcz( cjep0    ,1.0E-20     ,"F"       ,            "Peripheral BE zero-bias depletion capacitance")
`MPRoc( vdep     ,0.9         ,"V"       ,0    ,10   ,"Peripheral BE built-in potential")
`MPRoo( zep      ,0.5         ,""        ,0    ,1    ,"Peripheral BE grading coefficient")
`MPRco( ajep     ,2.5         ,""        ,1    ,inf  ,"Ratio of maximum to zero-bias value of peripheral BE capacitance")
`MPRcz( cjci0    ,1.0E-20     ,"F"       ,            "Internal BC zero-bias depletion capacitance")
`MPRoc( vdci     ,0.7         ,"V"       ,0    ,10   ,"Internal BC built-in potential")
`MPRoo( zci      ,0.4         ,""        ,0    ,1    ,"Internal BC grading coefficient")
`MPRco( ajci     ,2.4         ,""        ,1    ,inf  ,"Ratio of maximum to zero-bias value of internal BC capacitance")
`MPRoc( vptci    ,100         ,"V"       ,0    ,100  ,"Internal BC punch-through voltage")
`MPRcz( cjcx0    ,1.0E-20     ,"F"       ,            "External BC zero-bias depletion capacitance")
`MPRoc( vdcx     ,0.7         ,"V"       ,0    ,10   ,"External BC built-in potential")
`MPRoo( zcx      ,0.4         ,""        ,0    ,1    ,"External BC grading coefficient")
`MPRco( ajcx     ,2.4         ,""        ,1    ,inf  ,"Ratio of maximum to zero-bias value of external BC capacitance")
`MPRoc( vptcx    ,100         ,"V"       ,0    ,100  ,"External BC punch-through voltage")
`MPRcz( cjs0     ,0.0         ,"F"       ,            "CS zero-bias depletion capacitance")
`MPRoc( vds      ,0.6         ,"V"       ,0    ,10   ,"CS built-in potential")
`MPRoo( zs       ,0.5         ,""        ,0    ,1    ,"CS grading coefficient")
`MPRco( ajs      ,2.4         ,""        ,1    ,inf  ,"Ratio of maximum to zero-bias value of CS depletion capacitance")
`MPRoc( vpts     ,100         ,"V"       ,0    ,100  ,"CS punch-through voltage")
`MPRcz( cscp0    ,0.0         ,"F"       ,            "Perimeter SC zero-bias depletion capacitance")
`MPRcc( vdsp     ,0.6         ,"V"       ,0    ,10   ,"Perimeter SC built-in potential")
`MPRoo( zsp      ,0.5         ,""        ,0    ,1    ,"Perimeter SC grading coefficient")
`MPRoc( vptsp    ,100         ,"V"       ,0    ,100  ,"Perimeter SC punch-through voltage")

//Diffusion capacitances
`MPRcz( t0       ,0.0         ,"s"       ,            "Low current forward transit time at VBC=0V")
`MPRoo( dt0h     ,0.0         ,"s"       ,-inf ,inf  ,"Time constant for base and BC space charge layer width modulation")
`MPRoo( tbvl     ,0.0         ,"s"       ,-inf ,inf  ,"Time constant for modeling carrier jam at low VCE")
`MPRcz( tef0     ,0.0         ,"s"       ,            "Neutral emitter storage time")
`MPRoc( gtfe     ,1.0         ,""        ,0    ,10   ,"Exponent factor for current dependence of neutral emitter storage time")
`MPRcz( thcs     ,0.0         ,"s"       ,            "Saturation time constant at high current densities")
`MPRoc( ahc      ,0.1         ,""        ,0    ,50   ,"Smoothing factor for current dependence of base and collector transit time")
`MPRcc( fthc     ,0.0         ,""        ,0    ,1    ,"Partitioning factor for base and collector portion")
`MPRoz( rci0     ,150         ,"Ohm"     ,            "Internal collector resistance at low electric field")
`MPRoc( vlim     ,0.5         ,"V"       ,0    ,10   ,"Voltage separating ohmic and saturation velocity regime")
`MPRoz( vpt      ,100.0       ,"V"       ,            "Collector punch-through voltage")
`MPRoc( delck    ,2.0         ,""        ,0    ,10   ,"critical current parameter according to velocity-field relation")
`MPRcc( vces     ,0.1         ,"V"       ,0    ,1    ,"Internal CE saturation voltage")
`MPRcc( vdck     ,0.0         ,"V"       ,0    ,1.2  ,"Build-In BC voltage including voltage drop in B and epi-b.l.")
`MPRcz( avcsm    ,1.921812    ,""        ,            "Smoothing parameter for effective collector voltage")
`MPRoc( aick     ,1e-3        ,""        ,0    ,10   ,"Smoothing term for ICK")
`MPRcc( vcbar    ,0.0         ,"V"       ,0    ,1    ,"Barrier voltage")
`MPRcc( icbar    ,0.0         ,"A"       ,0    ,1    ,"Normalization parameter")
`MPRoc( acbar    ,0.01        ,""        ,0    ,10   ,"Smoothing parameter for barrier voltage")
`MPRcz( tr       ,0.0         ,"s"       ,            "Storage time for inverse operation")

//Vertical non-quasi-static effects
`MPIsw( flnqs    ,0           ,""        ,            "Flag for turning on and off of vertical NQS effect")
`MPRcc( alqf     ,0.167       ,""        ,0    ,1    ,"Factor for additional delay time of minority charge")
`MPRcc( alit     ,0.333       ,""        ,0    ,1    ,"Factor for additional delay time of transfer current")

//Series resistances
`MPRcz( rbi0     ,0.0         ,"Ohm"     ,            "Zero bias internal base resistance")
`MPRcz( rbx      ,0.0         ,"Ohm"     ,            "External base series resistance")
`MPRcz( fgeo     ,0.6557      ,""        ,            "Factor for geometry dependence of emitter current crowding")
`MPRcc( fdqr0    ,0.0         ,""        ,-0.5 ,100  ,"Correction factor for modulation by BE and BC space charge layer")
`MPRcc( fcrbi    ,0.0         ,""        ,0    ,1    ,"Ratio of HF shunt to total internal capacitance (lateral NQS effect)")
`MPRcc( fqi      ,1.0         ,""        ,0    ,1    ,"Ratio of internal to total minority charge")
`MPRcz( re       ,0.0         ,"Ohm"     ,            "Emitter series resistance")
`MPRcz( rcx      ,0.0         ,"Ohm"     ,            "External collector series resistance")

//Substrate transistor
`MPRcc( itss     ,0.0         ,"A"       ,0    ,1.0  ,"Substrate transistor transfer saturation current")
`MPRoc( msf      ,1.0         ,""        ,0    ,10   ,"Forward ideality factor of substrate transfer current")
`MPRcc( iscs     ,0.0         ,"A"       ,0    ,1.0  ,"CS diode saturation current")
`MPRoc( msc      ,1.0         ,""        ,0    ,10   ,"Ideality factor of CS diode current")
`MPRcz( tsf      ,0.0         ,"s"       ,            "Transit time for forward operation of substrate transistor")

//Intra-device substrate coupling
`MPRcz( rsu      ,0.0         ,"Ohm"     ,            "Substrate series resistance")
`MPRcz( csu      ,0.0         ,"F"       ,            "Substrate shunt capacitance")

//Isolation capacitances
`MPRcz( cbepar   ,0.0         ,"F"       ,            "Total parasitic BE capacitance")
`MPRcc( fbepar   ,1.0         ,""        ,0    ,1    ,"Partitioning factor of parasitic BE cap")
`MPRcz( cbcpar   ,0.0         ,"F"       ,            "Total parasitic BC capacitance")
`MPRcc( fbcpar   ,0.0         ,""        ,0    ,1    ,"Partitioning factor of parasitic BC cap")

//Noise
`MPIsw( flcono   ,0           ,""        ,            "Flag for turning on and off of correlated noise implementation")
`MPRcz( kf       ,0.0         ,""        ,            "Flicker noise coefficient")
`MPRoc( af       ,2.0         ,""        ,0    ,10   ,"Flicker noise exponent factor")
`MPIcc( cfbe     ,-1          ,""        ,-2   ,-1   ,"Flag for determining where to tag the flicker noise source")
`MPRcz( kfre     ,0.0         ,""        ,            "Emitter resistance flicker noise coefficient")
`MPRoc( afre     ,2.0         ,""        ,0    ,10   ,"Emitter resistance flicker noise exponent factor")

//Lateral geometry scaling (at high current densities)
`MPRcz( latb     ,0.0         ,""        ,            "Scaling factor for collector minority charge in direction of emitter width")
`MPRcz( latl     ,0.0         ,""        ,            "Scaling factor for collector minority charge in direction of emitter length")

//Temperature dependence
`MPRoc( vgb      ,1.17        ,"V"       ,0    ,10   ,"Bandgap voltage extrapolated to 0 K")
`MPRoc( vge      ,1.17        ,"V"       ,0    ,10   ,"Effective emitter bandgap voltage")
`MPRoc( vgc      ,1.17        ,"V"       ,0    ,10   ,"Effective collector bandgap voltage")
`MPRoc( vgs      ,1.17        ,"V"       ,0    ,10   ,"Effective substrate bandgap voltage")
`MPRnb( f1vg     ,-1.02377e-4 ,""        ,            "Coefficient K1 in T-dependent band-gap equation")
`MPRnb( f2vg     ,4.3215e-4   ,""        ,            "Coefficient K2 in T-dependent band-gap equation")
`MPRcc( zetact   ,3.0         ,""        ,-10  ,10   ,"Exponent coefficient in transfer current temperature dependence")
`MPRcc( zetabet  ,3.5         ,""        ,-10  ,10   ,"Exponent coefficient in BE junction current temperature dependence")
`MPRcc( dvgbe    ,0           ,"V"       ,-10  ,10   ,"Bandgap difference between B and BE junction used for hjEi0 and hf0")
`MPRcc( zetahjei ,1           ,""        ,-10  ,10   ,"Temperature coefficient for ahjei")
`MPRcc( zetavgbe ,1           ,""        ,-10  ,10   ,"Temperature coefficient for hjei0")
`MPRnb( alt0     ,0.0         ,"1/K"     ,            "First order relative TC of parameter T0")
`MPRnb( kt0      ,0.0         ,""        ,            "Second order relative TC of parameter T0")
`MPRcc( zetaci   ,0.0         ,""        ,-10  ,10   ,"Temperature exponent for rci0")
`MPRnb( alvs     ,0.0         ,"1/K"     ,            "Relative TC of saturation drift velocity")
`MPRnb( alces    ,0.0         ,"1/K"     ,            "Relative TC of vces")
`MPRnb( aldck    ,0.0         ,"1/K"     ,            "Relative TC of vdck")
`MPRcc( zetarbi  ,0.0         ,""        ,-10  ,10   ,"Temperature exponent of internal base resistance")
`MPRcc( zetarbx  ,0.0         ,""        ,-10  ,10   ,"Temperature exponent of external base resistance")
`MPRcc( zetarcx  ,0.0         ,""        ,-10  ,10   ,"Temperature exponent of external collector resistance")
`MPRcc( zetare   ,0.0         ,""        ,-10  ,10   ,"Temperature exponent of emitter resistance")
`MPRcc( zetacx   ,1.0         ,""        ,-10  ,10   ,"Temperature exponent of mobility in substrate transistor transit time")
`MPRnb( alfav    ,0.0         ,"1/K"     ,            "Relative TC for FAVL")
`MPRnb( alqav    ,0.0         ,"1/K"     ,            "Relative TC for QAVL")

//Self-heating
`BPIcc( flsh     ,0           ,""        ,0    ,2    ,"Flag for turning on and off self-heating effect")
`MPRcz( rth      ,0.0         ,"K/W"     ,            "Thermal resistance")
`MPRcc( zetarth  ,0.0         ,""        ,-10  ,10   ,"Temperature coefficient for Rth")
`MPRcc( alrth    ,0.0         ,"1/K"     ,-10  ,10   ,"First order relative TC of parameter Rth")
`MPRcz( cth      ,0.0         ,"J/K"     ,            "Thermal capacitance")

//Circuit simulator specific parameters
`MPRnb( tnom     ,27.0        ,"C"       ,            "Temperature at which parameters are specified")
`IPRnb( dt       ,0.0         ,"K"       ,            "Temperature change w.r.t. chip temperature for particular transistor")
`MPIty( type     ,1           ,""        ,            "For transistor type NPN(+1) or PNP (-1)")
// minr as defined by CMC guidelines
`MPRcz( minr, $simparam("minr", 1.0e-3), "Ohm",       "minimum branch resistance")

aliasparam dtemp = dt; //HSpice, SmartSpice, Eldo
aliasparam Trise = dt; //ADS

//======================== Transistor model formulation ===================
//
//Declaration of variables

//Temperature related variables
real KB2Q, VT300, VT, OVT, VTnom, OVTnom, Tnom, Tamb, Tdev, qtt0, ln_qtt0, dTdev;
real c10_t, qp0_t,  hjei0_t, ahjei_t, hf0_t, hfe_t, hfc_t;
real ibeis_t, ibeps_t, ireis_t, ireps_t,  cjei0_t, vdei_t, ajei_t,  cjep0_t, vdep_t, ajep_t;
real ibcis_t,  cjci0_t, vdci_t, ajci_t;
real ibcxs_t,  cjcx01_t, cjcx02_t, vdcx_t, ajcx_t, qjcx0_t_x, qjcx0_t_p, cratio_t;
real itss_t, iscs_t,  cjs0_t, vds_t, ajs_t,  cscp0_t, vdsp_t, ajsp_t,  tsf_t;
real rci0_t, Orci0_t, vlim_t, avs, vces_t, vdck_t,  t0_t, thcs_t, tef0_t;
real qavl_t, favl_t,  ibets_t, abet_t, ibetat0_t;
real rbi0_t, rbi, rbx_t, rcx_t, re_t;
real k1, k2, vge_t, vgb_t, vgbe_t;
real zetabci, zetabcxt, zetasct, vgb_tnom, vge_tnom, vgbe_tnom, mg, vgbe0, vgbc0, vgsc0;

//real var_out;  //for test only

// Macro variables
real DIO_y,DIO_le;                                                               //HICDIO
real FFfcbar,FFitf_ick,FFdQef,FFdTef,FFdQbfb,FFdTbfb,FFdQfhc,FFdTfhc,FFdQbfc;    //HICQFF
real FFdTbfc,FFdQcfc,FFdTcfc,FFib,FFic,FFw,FFvc_exp,FFdVc,FFdVc_ditf;            //HICQFF
real Dz_r,Dv_p,DV_f,DC_max,DC_c,Da,Dv_e,De,De_1,Dv_j1,Dv_r,De_2,Dv_j2,Dv_j4;     //QJMOD
real DQ_j1,DQ_j2,DQ_j3,DCln1,DCln2,Dz1,Dzr1,DC_j1,DC_j2,DC_j3;                   //QJMOD
real DFV_f,DFv_j,DFb,DFq_j1,DFx,DFs_q,DFs_q2,DFdvj_dv,DFc_j1;                    //QJMODF
real FCick,FCdick_ditf,FClatw_p1,FCw,FCdw_ditf,FCk,FCkdelta,FClatbw;             //HICQFC
real FCf_ci,FCdfc_ditf,FCf_CSb,FCf_CSl,FCdfCSb_dw,FCdfCSl_dw,FCt;                //HICQFC
real FCIwzb_p1,FCIlnw_bl,FCIa;  // HICFCI
real a_eg, ab, aa;              //HICTUN_T
real a_jsp,vdj_t0,vdj_t;        //tmphicj

//Charges, capacitances and currents
real cbcpar1, cbcpar2, cbepar1, cbepar2, Otbhrec;
real cjcx01, cjcx02;
real Qjci, Qjei, Qjep;
real Qdei, Qdci, qrbi;
real it, ibei, irei, ibci, ibep, irep, ibh_rec;
real ibebtb, ibetat;
real ijbcx, ijsc, Qjs, Qscp, iT_sub, Qdsu;

//Base resistance and self-heating power
real pterm, rth_t;

// Branch voltages
real Vbiei, Vbici, Vciei, Vbpei, Vbpci, Vbci, Vsici, Vsc;

//Model evaluation
real Cjci,Cjei,Cjep,CjCx_x,CjCx_p,Cjs,Cscp;
real itf,itr,Tf;
real Cdei,Cdci,Crbi,  V_btbmax;
integer l_it;
real inv_latb,inv_latl,latb_6,latl_6,latmin,latmax,ln_lat,lat_delta; // HICFCI
real gmin;

//vertical NQS effect
integer use_nqs;
real Ixf, Qxf, Ixf1, Ixf2, Qxf1, Qxf2, Itxf, Qdeix;

// Avalanche current
integer use_aval;
real iavl;

`ifdef CALC_OP
    `OPP( VBE    , "V"   , "External BE voltage"                               )
    `OPP( VBC    , "V"   , "External BC voltage"                               )
    `OPP( VCE    , "V"   , "External CE voltage"                               )
    `OPP( VSC    , "V"   , "External SC voltage"                               )
`ifndef __XYCE__
    `OPM( IB     , "A"   , "Base terminal current"                             )
    `OPM( IC     , "A"   , "Collector terminal current"                        )
    `OPM( IS     , "A"   , "Substrate terminal current"                        )
    `OPM( IAVL   , "A"   , "Avalanche current"                                 )
    `OPP( BETADC, ""    , "Common emitter forward current gain"                )
`endif
    `OPD( RPI   , "Ohm" , "Total base-emitter (input) resistance"              )
    `OPM( GMi   , "A/V" , "Intrinsic transconductance"                         )
    `OPD( RMU   , "Ohm" , "Total feedback resistance"                          )
    `OPD( ROi   , "Ohm" , "Intrinsic output resistance"                        )
    `OPM( CPIi  , "F"   , "Total intrinsic BE capacitance"                     )
    `OPM( CMUi  , "F"   , "Total intrinsic BC capacitance"                     )
    `OPP( BETAAC, ""    , "Intrinsic small signal low-frequency current gain"  )
    `OPP( AVi   , ""    , "Intrinsic small signal low-frequency voltage gain"  )

    `OPM( CPIx   , "F"   , "external BE capacitance"                           )
    `OPM( CMUx   , "F"   , "external BC capacitance"                           )
    `OPM( CCS    , "F"   , "total CS substrate coupling capacitance"           )
    `OPD( R_SU   , "Ohm" , "CS substrate coupling resistance"                  )
    `OPM( C_SU   , "F"   , "CS substrate coupling capacitance"                 )

    `OPD( R_Cx   , "Ohm",  "External (saturated) collector series resistance"  )
    `OPD( R_E    , "Ohm",  "Emitter series resistance"                         )
    `OPD( R_Bi   , "Ohm",  "Internal base resistance"                          )
    `OPD( R_B    , "Ohm",  "Total base resistance"                             )

    //`OPP( T_F   , "s"   , "Forward transit time"                             )
    `OPP( F_T    , "Hz"  , "Transit frequency"                                 )

    `OPD( R_TH   , "K/W" , "Thermal resistance"                                )
    `OPM( C_TH   , "J/K" , "Thermal capacitance"                               )
    `OPP( TK     , "K"   , "Actual device temperature"                         )
    `OPP( DTSH   , "K"   , "Temperature increase due to self-heating"          )
    // for test: define var here and assign in output block
    //`OPP( VAR_TST   , " "   , "internal variable for code tests     "        )
`endif

//end of variables

analog begin

    // Branch Voltages of the Model
    Vbiei = type*V(br_biei);
    Vbici = type*V(br_bici);
    Vciei = Vbiei-Vbici;
    Vbpei = type*V(br_bpei);
    Vbpci = type*V(br_bpci);
    Vbci  = type*V(br_bci);
    Vsici = type*V(br_sici);
    Vsc   = type*V(br_sc);

    `INSTANCE begin : Model_initialization
        // local variables
        real k10,k20,C_1;

        gmin = `Gmin;

        Tnom      = tnom+`P_CELSIUS0;
        Tamb      = $temperature;
        KB2Q      =`P_KB/`P_QEL;
        VT300     = KB2Q*300.0;
        VTnom     = KB2Q*Tnom;
        OVTnom    = 1.0/VTnom;
        k10       = f1vg*Tnom*ln(Tnom);
        k20       = f2vg*Tnom;
        avs       = alvs*Tnom;
        vgb_tnom  = vgb+k10+k20;
        vge_tnom  = vge+k10+k20;
        vgbe_tnom = (vgb_tnom+vge_tnom)/2.0;
        vgbe0     = (vgb+vge)/2.0;
        vgbc0     = (vgb+vgc)/2.0;
        vgsc0     = (vgs+vgc)/2.0;
        mg        = 3.0-f1vg/KB2Q;
        zetabci   = mg+1.0-zetaci;
        zetabcxt  = mg+1.0-zetacx;
        zetasct   = mg-1.5;

        //BC depletion capacitance splitting across base region (presently at Tnom)
        //Capacitances at peripheral and external base node
        C_1 = (1.0-fbcpar)*(cjcx0+cbcpar);
        if (C_1 >= cbcpar) begin
            cbcpar1 = cbcpar;
            cbcpar2 = 0.0;
            cjcx01  = C_1-cbcpar;
            cjcx02  = cjcx0-cjcx01;
        end else begin
            cbcpar1 = C_1;
            cbcpar2 = cbcpar-cbcpar1;
            cjcx01  = 0.0;
            cjcx02  = cjcx0;
        end

        //Parasitic BE capacitance partitioning
        cbepar2 = fbepar*cbepar;
        cbepar1 = cbepar-cbepar2;

        //Base current recombination time constant at b-c barrier
        if (tbhrec != 0.0) begin
            Otbhrec = 1.0/tbhrec;
        end else begin
            Otbhrec = 0.0;
        end

        //BtB tunneling current evaluation range
        if (flcomp <= 300) begin
            V_btbmax = 0.0;
        end else begin
            V_btbmax = 0.7;
        end

        // Turn on/off avalanche calculation depending of parameters
        iavl = 0.0; // Set iavl to zero in this case here, this avoids any calculations later
        if ((favl > 0.0) && (cjci0 > 0.0)) begin
            use_aval = 1;
        end else begin
            use_aval = 0;
        end

        // check whether vertical NQS effect calculation is possible
        use_nqs = flnqs;
        if (flnqs != 0) begin
            if ((alit == 0.0 && alqf == 0.0) || t0 == 0.0) begin
                use_nqs = 0;
            end
        end

        // Calculate some constants used by HICFCI macro to avoid unrequired calculations during
        // GICCR iteration
        if ((latb >= 0.01) || (latl >= 0.01)) begin
            lat_delta = 0.5*(latb-latl);
            if (latl < latb) begin
                latmin = latl; // typical case with width > length
                latmax = latb;
            end else begin
                latmin = latb; // length > width
                latmax = latl;
            end
            //Since inv_latb,l are only needed for HICFCI and HICFCI is only called
            //for the general case, prevent division by zero here:
            if (latmin < 0.01) begin /* 2D case (long emitter) */
                inv_latb = 1.0e9;
                inv_latl = 1.0e9;
                latb_6 = 1.7e8; // 1e9/6.0 = 1.66666666e8
                latl_6 = 1.7e8;
                ln_lat = ln(1.0+latmax);
            end else begin   /* general aspect ratio */
                inv_latb = 1.0/latb;
                inv_latl = 1.0/latl;
                latb_6 = latb/6.0;
                latl_6 = latl/6.0;
                ln_lat = ln((1.0+latb)/(1.0+latl));
            end
        end else begin /* CCS is turned off */
            lat_delta = 00;
            inv_latb = 1.0e9;
            inv_latl = 1.0e9;
            latb_6 = 1.7e8; // 1e9/6.0 = 1.66666666e8
            latl_6 = 1.7e8;
            latmin = latl;  // unused if CCS is turned off
            latmax = latb;
            ln_lat = 0.0;
        end

        // Temperature and resulting parameter drift
        // if (flsh == 0 || rth <= minr) begin : Thermal_update_without_self_heating
        `TMPUPDATE(0)
        //end // of Thermal_update_without_self_heating

    end // of Model_initialization


    if (flsh !=0 && rth >= minr && rth > 0.0) begin : Thermal_update_with_self_heating
        `TMPUPDATE(V(br_sht))
    end  //of Thermal_update_with_self_heating


    begin : Model_evaluation
        // GICCR weight factors current transit times and charges
        real hjei_tb, b_q, Q_pT, d_Q;
        real i_0f, i_0r, Q0_pT, Q_bpt, Q_bf, Qf, Qr;
        real T_f0,Q_fT,T_fT;

        // transit time
        real Cci2Cci0;
        real ick, vc;

        // -----------------   Intrinsic transistor  ----------------------
        //Internal base currents across b-e junction
        `HICDIO(ibeis,ibeis_t,mbei,Vbiei, ibei)
        `HICDIO(ireis,ireis_t,mrei,Vbiei, irei)

        //HICCR: begin
        //Initialization

        //Transfer current related variables, minority charges and transit times
        i_0f = c10_t * limexp(Vbiei*OVT/mcf);
        i_0r = c10_t * limexp(Vbici*OVT);

        //Internal BE and BC depletion capacitance and charge
        `QJMODF(cjei0_t,vdei_t,zei,ajei_t,Vbiei, Cjei,Qjei)
        `HICJQ(cjci0_t,vdci_t,zci,ajci_t,vptci,Vbici, Cjci,Qjci)

        // GICCR weight factor for BE depletion charge  (MS0918)
        if (ahjei > 0.0) begin : HICHJEI
            real hje_rVT, hje_vr, hje_vju, hje_u;
            hje_rVT= rhjei*VT;
            hje_vr = (vdei_t-Vbiei)/hje_rVT;
            hje_vju= vdei_t-hje_rVT*(hje_vr+sqrt(hje_vr*hje_vr+`DFa_fj))*0.5;
            hje_u  = ahjei_t*(1.0-exp(zei*ln(1.0-hje_vju/vdei_t)));
            if (abs(hje_u) > 0.001) begin
                hjei_tb = hjei0_t*(exp(hje_u)-1.0)/hje_u;
            end else begin
                hjei_tb = hjei0_t*(1+hje_u*0.5);
            end
        end else begin
            hjei_tb = hjei0_t;
        end

        //Hole charge at low bias
        Q0_pT = qp0_t + hjei_tb*Qjei + hjci*Qjci;
        Q_bpt = 0.05*qp0_t;
        b_q   = Q0_pT/Q_bpt-1.0;
        Q0_pT = Q_bpt*(1.0+(b_q +sqrt(b_q*b_q+`DFa_fj))*0.5);

        //Transit time calculation at low current density
        begin : CJMODF
            real cV_f,cv_e,cs_q,cs_q2,cv_j,cdvj_dv;
            cV_f  = vdci_t*(1.0-exp(-ln(2.4)/zci));
            cv_e  = (cV_f-Vbici)*OVT;
            cs_q  = sqrt(cv_e*cv_e+`DFa_fj);
            cs_q2 = (cv_e+cs_q)*0.5;
            cv_j  = cV_f-VT*cs_q2;
            cdvj_dv = cs_q2/cs_q;
            Cci2Cci0 = exp(-zci*ln(1.0-cv_j/vdci_t))*cdvj_dv + 2.4*(1.0-cdvj_dv);
        end
        T_f0 = t0_t+dt0h*(1.0/Cci2Cci0-1.0)+tbvl*(Cci2Cci0-1.0);

        //Effective collector voltage
        if (vdck > 0.0) begin
            vc = vdck_t-Vbici;
        end else begin
            vc = Vciei-vces_t;
        end

        //Critical current for onset of high-current effects (MS0918: 1.98.. => `DFa_fj)
        begin : HICICK
            real r_v, vceff, Vc2Vlim, ICK_ohm, FF_ick, ICK_low, vick_VPT;
            if (flcomp <= 300) begin
                r_v   = (vc-VT)*OVT;
                vceff = VT+VT*((r_v+sqrt(r_v*r_v +`DFa_fj))*0.5);
            end else begin  // new ICK >v300
                r_v   = vc/VT300;
                vceff = VT300*((r_v+sqrt(r_v*r_v + avcsm))*0.5);
            end
            Vc2Vlim = vceff/vlim_t;
            ICK_ohm = vceff*Orci0_t;
            FF_ick  = exp(ln(1.0+exp(delck*ln(Vc2Vlim)))/delck);
            ICK_low = ICK_ohm/FF_ick;
            vick_VPT= (vceff-vlim_t)/vpt;
            ick     = ICK_low*(1.0+0.5*(vick_VPT+sqrt(vick_VPT*vick_VPT+aick)));
        end

        //Initial formulation of forward and reverse component of transfer current
        Q_pT = Q0_pT;
        if (T_f0 > 0.0 || tr > 0.0) begin : HICQP0
            real A;
            A = 0.5*Q0_pT;
            if (flcomp <= 300) begin
                Q_pT = A+sqrt(A*A+T_f0*i_0f+tr*i_0r);
            end else begin
                Q_pT = A+sqrt(A*A+hf0_t*t0_t*i_0f+tr*i_0r);
            end
        end
        itf = i_0f/Q_pT;
        itr = i_0r/Q_pT;

        //Initial formulation of forward transit time, diffusion, GICCR and excess b-c charge
        //Q_bf = 0.0;
        //Tf = T_f0;
        //Qf = T_f0*itf;
        `HICQFF

        //Initial formulation of reverse diffusion charge
        Qr = tr*itr;

        //Preparation for iteration to get total hole charge and related variables
        l_it = 0;
        //if (Q_fT > `RTOLC*Q_pT) begin : HICQPT  // ==> use from v400 on
        if (flcomp >= 310 && Q_fT > `RTOLC*Q_pT || flcomp <= 300 && Qf > `RTOLC*Q_pT) begin : HICQPT
            real d_Q_max;
            //Iteration for Q_pT is required for final transfer current solution
            Qf   = sqrt(T_f0*itf*Q_fT);
            Q_pT = Q0_pT+Qf+Qr;
            d_Q  = Q_pT;
            while (abs(d_Q) >= `RTOLC*abs(Q_pT) && l_it <= `l_itmax) begin
                itf = i_0f/Q_pT;
                itr = i_0r/Q_pT;
                //Tf = T_f0;
                //Qf = T_f0*itf;
                `HICQFF
                Qr = tr*itr;
                d_Q = -(Q_pT-(Q0_pT+Q_fT+Qr))/(1.0+(T_fT*itf+Qr)/Q_pT);
                //Limit maximum change of Q_pT
                d_Q_max = abs(0.3*Q_pT);
                if (abs(d_Q) > d_Q_max) begin
                    if (d_Q >= 0.0) begin
                        d_Q = d_Q_max;
                    end else begin
                        d_Q = -d_Q_max;
                    end
                end
                Q_pT = Q_pT+d_Q;
                l_it = l_it+1;
            end //while

            itf = i_0f/Q_pT;
            itr = i_0r/Q_pT;

            //Final transit times, charges and transport current components
            //Tf = T_f0;
            //Qf = T_f0*itf;
            `HICQFF
            Qr = tr*itr;

        end //if

        // net quasi-static transfer current and mobile charges
        it = itf-itr;
        //Diffusion charges for further use
        Qdei = Qf;
        Qdci = Qr;

        //High-frequency emitter current crowding (lateral NQS) => only valid for small-signal op
        Cdei = T_f0*itf*OVT;
        Cdci = tr*itr*OVT;
        Crbi = fcrbi*(Cjei+Cjci+Cdei+Cdci);
        qrbi = Crbi*V(br_bpbi_v);
        // qrbi = fcrbi*(Qjei+Qjci+Qdei+Qdci);

        //HICCR: end

        //Internal base current across BC junction
        `HICDIO(ibcis,ibcis_t,mbci,Vbici,ibci)

        //Avalanche current
        if (use_aval == 1) begin : HICAVL
            real Vci_bc, v_q, v_q0, av, avl, fc_av;
            Vci_bc = vdci_t-Vbici;
            if (Vci_bc > 0.0) begin
                if (hcavl > 0.0) begin : HICAVLCURRENT
                    // factor for current dependent avalanche current model
                    real Ilim_avl, c_r, sm_avl; //cm_avl,
                    sm_avl = 0.1;
                    //cm_avl = 1.0;
                    //c_r    = cm_avl*Cjci/cjci0_t;
                    c_r    = Cjci/cjci0_t;
                    Ilim_avl = hcavl*vlim_t*Orci0_t + hvdavl*itf;
                    fc_av = sqrt(sm_avl*ln(exp(c_r/sm_avl)-2.0+2.0*cosh((1-itf/Ilim_avl)/sm_avl)));
                end else begin
                    fc_av = 1.0;
                end
                v_q  = qavl_t/Cjci;
                v_q0 = qavl_t/cjci0_t;
                if (Vci_bc > v_q0) begin
                    av  = favl_t*exp(-v_q/(v_q0*fc_av));
                    avl = av*(v_q0+(1.0+v_q/v_q0)*(Vci_bc-v_q0));
                end else begin
                    avl = favl_t*Vci_bc*exp(-v_q/(Vci_bc*fc_av));
                end
                // kavl turns on/off strong avalanche model extension
                if (kavl > 0.0) begin : HICAVLSTRONG
                    real de_nom, sq_smth, h_l;
                    de_nom = 1.0-kavl*avl;
                    // smoothing to avoid de_nom <= 0
                    sq_smth = sqrt(de_nom*de_nom+0.0001);
                    h_l  = 0.5*(de_nom+sq_smth);
                    iavl = itf*avl/h_l;
                end else begin
                    iavl = itf*avl;  // weak avalanche model
                end
            end else begin
                iavl = 0.0;
            end
            // Note: iavl = 0.0 has already been set in initialization block for use_aval == 0
        end

        //Excess base current from recombination at the BC barrier
        ibh_rec = Q_bf*Otbhrec;

        //Internal base resistance
        if (rbi0_t > 0.0) begin : HICRBI
            real Qz_nom, f_QR, ETA, Qz0, fQz;
            // conductivity modulation, hyperbolic smoothing avoids division by zero
            // To avoid convergence problem  used
            f_QR = (1.0+fdqr0)*qp0_t;
            Qz0  = Qjei+Qjci+Qf;
            Qz_nom = 1.0+Qz0/f_QR;
            fQz = 0.5*(Qz_nom+sqrt(Qz_nom*Qz_nom+0.01));
            rbi = rbi0_t/fQz;
            // Consideration of emitter current crowding
            if (ibei > 0.0) begin
                ETA = rbi*ibei*fgeo*OVT;
                if (ETA < 1.0e-6) begin
                    rbi = rbi*(1.0-0.5*ETA);
                end else begin
                    rbi = rbi*ln(1.0+ETA)/ETA;
                end
            end
            // impact of peripheral charge
            if (Qf > 0.0) begin
                rbi = rbi*(Qjei+Qf*fqi)/(Qjei+Qf);
            end
        end else begin
            rbi = 0.0;
        end // HICRBI

        //Base currents across peripheral BE junction
        `HICDIO(ibeps,ibeps_t,mbep,Vbpei,ibep)
        `HICDIO(ireps,ireps_t,mrep,Vbpei,irep)

        //Peripheral b-e junction capacitance and charge
        `QJMODF(cjep0_t,vdep_t,zep,ajep_t,Vbpei, Cjep,Qjep)

        //BtBT current
        if (ibets > 0.0 && (Vbpei < V_btbmax || Vbiei < V_btbmax)) begin : HICTUN
            real pocce, czz;
            if (tunode == 1 && cjep0_t > 0.0 && vdep_t > 0.0) begin
                pocce = exp((1.0-1.0/zep)*ln(Cjep/cjep0_t));
                czz   = -(Vbpei/vdep_t)*ibets_t*pocce;
                ibebtb = czz*exp(-abet_t/pocce);
            end else if (tunode == 0 && cjei0_t > 0.0 && vdei_t > 0.0) begin
                pocce = exp((1.0-1.0/zei)*ln(Cjei/cjei0_t));
                czz   = -(Vbiei/vdei_t)*ibets_t*pocce;
                ibebtb = czz*exp(-abet_t/pocce);
            end else begin
                ibebtb = 0.0;
            end
        end else begin
            ibebtb = 0.0;
        end

        //TAT current
        ibetat=ibetat0_t*(exp(Vbiei/vbetat)-1.0);

        //Depletion capacitance and charge of peripheral BC junction (bp,ci)
        `HICJQ(cjcx02_t,vdcx_t,zcx,ajcx_t,vptcx,Vbpci, CjCx_p,qjcx0_t_p)

        //Base current across peripheral BC junction (bp,ci)
        `HICDIO(ibcxs,ibcxs_t,mbcx,Vbpci, ijbcx)

        //Depletion capacitance and charge of external BC junction (b,ci)
        `HICJQ(cjcx01_t,vdcx_t,zcx,ajcx_t,vptcx,Vbci, CjCx_x,qjcx0_t_x)

        //Substrate-collector depletion capacitance and charge (si,ci)
        `HICJQ(cjs0_t,vds_t,zs,ajs_t,vpts,Vsici, Cjs,Qjs)
        //Peripheral (trench/depletion) CS capacitance and charge (s,c)
        if (vdsp > 0.0) begin  //depletion capacitance
            `HICJQ(cscp0_t,vdsp_t,zsp,ajsp_t,vptsp,Vsc, Cscp,Qscp)
        end else begin
            //bias, temperature independent (trench) capacitance and charge
            Cscp = cscp0;
            Qscp = cscp0*Vsc;
        end

        //Parasitic substrate transistor transfer current and diffusion charge
        if (itss > 0.0) begin : Sub_Transistor
            real msfvt,its_f,its_r;
            msfvt = msf*VT;
            its_f = limexp(Vbpci/msfvt);
            its_r = limexp(Vsici/msfvt);
            iT_sub = itss_t*(its_f-its_r);
            if (tsf > 0.0) begin
                Qdsu = tsf_t*itss_t*its_f;
            end else begin
                Qdsu = 0.0;
            end
        end else begin
            iT_sub = 0.0;
            Qdsu = 0.0;
        end  // Sub_Transistor

        //Diode current of SC junction (si,ci)
        `HICDIO(iscs,iscs_t,msc,Vsici, ijsc)

        //Self-heating calculation
        if (rth >= minr && rth > 0.0) begin
            if (flsh == 1) begin
                pterm = Vciei*it + (vdci_t-Vbici)*iavl;
            end else if (flsh == 2) begin
                pterm = Vciei*it + (vdci_t-Vbici)*iavl + ibei*Vbiei + ibci*Vbici + ibep*Vbpei + ijbcx*Vbpci + ijsc*Vsici;
                if (rbi >= minr && rbi > 0.0) begin
                    pterm = pterm + V(br_bpbi_i)*V(br_bpbi_i)/rbi;
                end
                if (re_t >= minr && re_t > 0.0) begin
                    pterm = pterm + V(br_eie_i)*V(br_eie_i)/re_t;
                end
                if (rcx_t >= minr && rcx_t > 0.0) begin
                    pterm = pterm + V(br_cic_i)*V(br_cic_i)/rcx_t;
                end
                if (rbx_t >= minr && rbx_t > 0.0) begin
                    pterm = pterm + V(br_bbp_i)*V(br_bbp_i)/rbx_t;
                end
            end else begin
                pterm = 0.0;
            end
        end

        // Vertical NQS effects (excess delay/phase calculation)
        begin : HIC_VNQS
            real Vxf, Vxf1, Vxf2, fact;

            Itxf  = itf;
            Qdeix = Qdei;
            if (use_nqs != 0) begin
                Vxf1  = V(br_bxf1); // transfer current (second-order Bessel)
                Vxf2  = V(br_bxf2);
                Ixf1  =  (Vxf2-itf)/Tf*t0;
                Ixf2  =  (Vxf2-Vxf1)/Tf*t0;
                Qxf1  =  alit*Vxf1*t0;
                Qxf2  =  alit*Vxf2/3.0*t0;
                Itxf  =  Vxf2;
                Vxf   = V(br_bxf);  // mobile charge (single-pole RC network)
                fact  = t0/Tf;
                Ixf   = (Vxf - Qdei)*fact;
                Qxf   = alqf*Vxf*t0;
                Qdeix = Vxf;
            end else begin
                Ixf1  =  V(br_bxf1);
                Ixf2  =  V(br_bxf2);
                Qxf1  =  0.0;
                Qxf2  =  0.0;
                Ixf   = V(br_bxf);
                Qxf   = 0.0;
            end
        end

    end  //of Model_evaluation

    begin : Load_sources
        //real I_crbi, I_cth, I_csu;  ==> leftover from earlier formulation
        // internal transistor
        I(br_biei) <+ type*(ibei+irei+ibetat+ibh_rec) + gmin*V(br_biei);
        I(br_biei) <+ ddt(type*(Qdeix+Qjei));
        I(br_bici) <+ type*(ibci-iavl) + gmin*V(br_bici);
        I(br_bici) <+ ddt(type*(Qdci+Qjci));
        I(br_ciei) <+ type*Itxf;
        I(br_eici) <+ type*itr;
        if (rbi0 >= minr && rbi0 > 0.0) begin
            I(br_bpbi_i) <+ V(br_bpbi_i)/rbi;
            if (fcrbi > 0.0) begin
                I(br_bpbi_i) <+ ddt(qrbi);
            end
        end else begin
            V(br_bpbi_v) <+ 0.0;
        end
        if (tunode == 1) begin
            I(br_bpei) <+ -type*ibebtb;
        end else begin
            I(br_biei) <+ -type*ibebtb;
        end

        // perimeter elements
        I(br_bpei) <+ type*(ibep+irep);
        I(br_bpei) <+ ddt(type*Qjep);
        I(br_bpci) <+ type*ijbcx;
        I(br_bpci) <+ ddt(type*(qjcx0_t_p+Qdsu));
        I(br_bpci) <+ ddt(cbcpar2*V(br_bpci));
        I(br_bci)  <+ ddt(type*qjcx0_t_x);
        I(br_bci)  <+ ddt(cbcpar1*V(br_bci));

        // external elements
        if (rbx >= minr && rbx > 0.0) begin
            I(br_bbp_i) <+ V(br_bbp_i)/rbx_t;
        end else begin
            V(br_bbp_v) <+ 0.0;
        end
        if (re >= minr && re > 0.0) begin
            I(br_eie_i) <+ V(br_eie_i)/re_t;
        end else begin
            V(br_eie_v) <+ 0.0;
        end
        if (rcx >= minr && rcx > 0.0) begin
            I(br_cic_i) <+ V(br_cic_i)/rcx_t;
        end else begin
            V(br_cic_v) <+ 0.0;
        end
        I(br_bpe)  <+ ddt(cbepar2*V(br_bpe));
        I(br_be)   <+ ddt(cbepar1*V(br_be));

        // substrate transistor
        I(br_bpsi) <+ type*iT_sub;
        I(br_sici) <+ type*ijsc;
        if (flcomp >= 310) begin
            I(br_sici) <+ gmin*V(br_sici);
        end
        I(br_sici) <+ ddt(type*Qjs);
        I(br_sc)   <+ ddt(type*Qscp);
        if (rsu >= minr && rsu > 0.0) begin
            I(br_sis_i) <+ V(br_sis_i)/rsu;
            if (csu > 0.0) begin
                I(br_sis_i) <+ ddt(csu*V(br_sis_i));
            end
        end else begin
            V(br_sis_v) <+ 0.0;
        end

        // self heating adjunct network
        // For simulators having no problem with V(br_sht) <+ 0.0 with external thermal
        // node, following code may be used.
        // Note that external thermal node should remain accessible even without self-heating.
        if (flsh >= 1 && rth >= minr && rth > 0.0) begin
            I(br_sht) <+ V(br_sht)/rth_t-pterm;
            if (cth > 0.0) begin
                I(br_sht) <+ ddt(cth*V(br_sht));
            end
        end else begin
            V(br_sht) <+ 0.0;
        end

        // vertical NQS effect adjunct network
        I(br_bxf1) <+ Ixf1;
        I(br_cxf1) <+ ddt(Qxf1);
        I(br_bxf2) <+ Ixf2;
        I(br_cxf2) <+ ddt(Qxf2);
        I(br_bxf)  <+ Ixf;       //for RC nw
        I(br_cxf)  <+ ddt(Qxf);  //for RC nw

    end //of Load_sources


    `NOISE begin : Noise_sources
        // local variables
        real fourkt,twoq,flicker_Pwr;
        real i_re;

        //Thermal noise
        fourkt  = 4.0 * `P_KB * Tdev;
        if (rbx >= minr && rbx > 0.0) begin
            I(br_bbp_i) <+ white_noise(fourkt/rbx_t, "rbx");
        end
        if (rbi0 >= minr && rbi0 > 0.0) begin
            I(br_bpbi_i) <+ white_noise(fourkt/rbi, "rbi");
        end
        if (rcx >= minr && rcx > 0.0) begin
            I(br_cic_i) <+ white_noise(fourkt/rcx_t, "rcx");
        end
        if (re >= minr && re > 0.0) begin
            I(br_eie_i)  <+ white_noise(fourkt/re_t, "re");
        end
        if (rsu >= minr && rsu > 0.0) begin
            I(br_sis_i) <+ white_noise(fourkt/rsu, "rsu");
        end

        //Flicker noise : Fully correlated between the perimeter and internal base-node
        flicker_Pwr = kf*pow(abs(ibei+ibep),af);
        if (cfbe == -1) begin
            I(br_biei) <+ flicker_noise(flicker_Pwr,1.0, "flicker");
        end else begin
            I(br_bpei) <+ flicker_noise(flicker_Pwr,1.0, "flicker");
        end
        if (re >= minr && re > 0.0) begin
            i_re = V(br_eie_i)/re_t;
            flicker_Pwr = kfre*pow(abs(i_re),afre);
            I(br_eie_i) <+ flicker_noise(flicker_Pwr,1.0, "flicker_re");
        end

        //Shot noise
        twoq = 2.0 * `P_QEL;
        I(br_cibi) <+ white_noise(twoq*iavl, "iavl");
        I(br_bici) <+ white_noise(twoq*abs(ibci), "ibci");
        I(br_bpei) <+ white_noise(twoq*abs(ibep), "ibep");
        I(br_bpci) <+ white_noise(twoq*abs(ijbcx), "ijbcx");
        I(br_sici) <+ white_noise(twoq*abs(ijsc), "ijsc");

        //Correlated noise
        if (flcono == 1 && (alit > 0.0 && alqf > 0.0)) begin : HICCORRNOISE
            real betadc;
            real n_w,n_1,n_2,sqrt_n2;

            // Current gain computation for correlated noise implementation
            if (ibei > 0.0) begin
                betadc=it/ibei;
            end else begin
                betadc=1e9;
            end

            // correlation between mobile base charge noise and transfer current noise
            n_w = 1.0;
            n_1 = Tf*alit;
            sqrt_n2 = betadc*(2.0*alqf-alit*alit);
            if (sqrt_n2 > 0.0) begin
                n_2 = Tf*sqrt(sqrt_n2);
            end else begin
                n_2 = 0.0;
            end
            // modified base shot noise source I1(bi,ei)
            I(b_n1)  <+ white_noise(twoq*abs(ibei), "ibei");
            I(b_n1)  <+ -V(b_n1);
            I(bi,ei) <+ V(b_n1);
            I(bi,ei) <+ n_2/n_w*ddt(n_w*V(b_n1));
            // controlled base noise source I2(bi,ei)
            I(bi,ei) <+ n_1/n_w*ddt(n_w*V(b_n2));
            // modified collector shot noise source I(ci,ei) (not a controlled source)
            I(b_n2)  <+ white_noise(twoq*abs(it), "it");
            I(b_n2)  <+ -V(b_n2);
            I(ci,ei) <+ V(b_n2);
            // end  "Correlated noise in BJT"
        end else begin
            // non-correlated base and transfer current (shot) noise sources
            I(br_ciei) <+ white_noise(twoq*abs(it),   "it");
            I(br_biei) <+ white_noise(twoq*abs(ibei), "ibei");
            I(b_n1)    <+ V(b_n1);
            I(b_n2)    <+ V(b_n2);
        end // end of flcono section

    end  //of Noise_sources

    // Operating point calculations
    `ifdef CALC_OP
        `ifdef OP_STATIC
            if (analysis("static")) begin: OPERATING_POINT
            `else
            begin: OPERATING_POINT
            `endif
            real g_bei, g_avf, g_bhrf, g_betun, g_pii, g_bep, g_PI,  g_mi;
            real g_bci, g_avr, g_bhrr, g_mui, g_bcx, g_MU,  g_Oi;
            real Qm_op, cd_f, cd_r,  c_jcx, c_dS, c_pitot, c_mutot, R_tot;

            // terminal variables
            VBE = V(b,e);
            VBC = V(b,c);
            VCE = V(c,e);
            VSC = V(s,c);
`ifndef __XYCE__
            IB   = I(<b>);
            IC   = I(<c>);
            IS   = I(<s>);
            IAVL = iavl;

            // DC current gain
            if (IB != 0.0) begin
                BETADC = IC/IB;
            end else begin
                BETADC = 1e9;
            end
`endif
            // BE conductance
            g_bei  = -ddx(ibei,V(ei)) - ddx(irei,V(ei));
            g_avf  = -ddx(iavl,V(ei));
            g_bhrf = -ddx(ibh_rec,V(ei));
            g_betun= -ddx(ibebtb,V(ei)) - ddx(ibetat,V(ei));
            g_pii = g_bei-g_betun+g_bhrf-g_avf;
            g_bep = - ddx(ibep,V(ei)) - ddx(irep,V(ei));
            // total conductance
            g_PI = g_pii+g_bep;
            if (abs(g_PI) > `Gmin) RPI = 1.0/g_PI;
            else if (g_PI >= 0)    RPI = 1.0/`Gmin;
            else                   RPI =-1.0/`Gmin;

            // intrinsic forward transconductance
            g_mi  = ddx(it,V(bi));
            //g_bhrr= -ddx(ibh_rec,V(ci));
            GMi = g_mi+g_avf;

            // BC conductance
            g_bci = -ddx(ibci,V(ci));
            g_avr = -ddx(iavl,V(ci));
            g_bhrr = -ddx(ibh_rec,V(ci));
            g_mui = g_bci-g_avr+g_bhrr;
            g_bcx = -ddx(ijbcx,V(ci));
            g_MU = g_bci+g_bcx;
            if (abs(g_MU) > `Gmin) RMU = 1.0/g_MU;
            else if (g_MU >= 0)    RMU = 1.0/`Gmin;
            else                   RMU =-1.0/`Gmin;

            // intrinsic output transconductance
            g_Oi= ddx(it,V(ci));
            if (abs(g_Oi) > `Gmin) ROi = 1.0/g_Oi;
            else if (g_Oi >= 0)    ROi = 1.0/`Gmin;
            else                   ROi =-1.0/`Gmin;

            // intrinsic branch capacitances
            Qm_op = Qdei+Qdci;
            cd_f = -ddx(Qm_op,V(ei));
            cd_r = -ddx(Qm_op,V(ci));
            CPIi = Cjei+cd_f;
            CMUi = Cjci+cd_r;

            // intrinsic small-signal current and voltage gain
            BETAAC = (GMi-g_mui)/(g_pii+g_mui);
            AVi    = -(GMi-g_mui)/(g_Oi+g_mui);

            // external capacitances
            CPIx = Cjep+cbepar;
            c_jcx= CjCx_x+CjCx_p;
            c_dS = -type*ddx(Qdsu,V(ci));
            CMUx = cbcpar+c_jcx+c_dS;
            CCS = Cscp+Cjs;
            R_SU = rsu;
            C_SU = csu;

            // series resistances
            R_Bi = rbi;
            R_B  = rbi+rbx_t;
            R_Cx = rcx_t;
            R_E  = re_t;

            // transit time and frequency
            R_tot = R_Cx + R_E + ((R_B+R_E)/BETAAC);
            c_pitot = CPIi+CPIx;
            c_mutot = CMUi+CMUx;
            F_T  = GMi/(2.0*`M_PI*(c_pitot+c_mutot+(R_tot*c_mutot*GMi)));

            R_TH = rth_t;
            C_TH = cth;
            TK = Tdev;
            DTSH = V(br_sht);
            // for test
            //VAR_TST = var_out;
        end
    `endif

end //analog
endmodule
