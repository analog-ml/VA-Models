//======================================================================================
//======================================================================================
// Filename: PSP104_module.include
//======================================================================================
//======================================================================================
//
//  (c) Copyright notice
//
//  Since 2015 until today, PSP has been co-developed by NXP Semiconductors and
//  CEA-Leti. For this part of the model, each claim undivided ownership and copyrights
//  Since 2012 until 2015, PSP has been co-developed by NXP Semiconductors and
//  Delft University of Technology. For this part of the model, each claim undivided
//  ownership and copyrights
//  Until and including 2011, PSP has been co-developed by NXP Semiconductors and
//  Arizona State University. For this part of the model, NXP Semiconductors claims
//  undivided ownership and copyrights.
//
//
//  Version: 104.0.0 (PSP), 200.6.2 (JUNCAP), September 2023
//
//======================================================================================
//======================================================================================
//
// Further information can be found in the file releasenotesPSP104.txt
//

//  --------------------------------------------------------------------------------------------------------------
//  Node definitions
//  --------------------------------------------------------------------------------------------------------------

`ifdef SelfHeating
    inout d, g, s, b, dt;
`else // SelfHeating
    inout d, g, s, b;
`endif // SelfHeating
electrical d;
electrical g;
electrical s;
electrical b;
`ifdef SelfHeating
    thermal dt;
    branch (dt) br_rth, br_ith;
`endif // SelfHeating

//  Internal nodes and branches for correlated drain and gate noise
electrical noi;
branch (noi) NOII;
branch (noi) NOIR;
branch (noi) NOIC;

//  Internal nodes for gate and bulk resistors
electrical gp;
electrical si;
electrical di;
electrical bp;
electrical bi;
electrical bs;
electrical bd;

//  Internal nodes and branches for spline collocation (NQS)
`ifdef NQSmodel
    electrical int1;
    electrical int2;
    electrical int3;
    electrical int4;
    electrical int5;
    electrical int6;
    electrical int7;
    electrical int8;
    electrical int9;
    branch(int1) SPLINE1;
    branch(int2) SPLINE2;
    branch(int3) SPLINE3;
    branch(int4) SPLINE4;
    branch(int5) SPLINE5;
    branch(int6) SPLINE6;
    branch(int7) SPLINE7;
    branch(int8) SPLINE8;
    branch(int9) SPLINE9;
    branch(int1) RES1;
    branch(int2) RES2;
    branch(int3) RES3;
    branch(int4) RES4;
    branch(int5) RES5;
    branch(int6) RES6;
    branch(int7) RES7;
    branch(int8) RES8;
    branch(int9) RES9;
`endif // NQSmodel



//  --------------------------------------------------------------------------------------------------------------
//  Instance parameters
//  --------------------------------------------------------------------------------------------------------------

//  Instance parameters for global and binning models only
`IPRco(L              ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Design length")
`IPRco(W              ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Design width")
`IPRnb(SA             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from one side")
`IPRnb(SB             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from other side")
`IPRnb(SD             ,0.0        ,"m"                                  ,"Distance between neighbouring fingers")
`IPRcz(SCA            ,0.0        ,""                                   ,"Integral of the first distribution function for scattered well dopants")
`IPRcz(SCB            ,0.0        ,""                                   ,"Integral of the second distribution function for scattered well dopants")
`IPRcz(SCC            ,0.0        ,""                                   ,"Integral of the third distribution function for scattered well dopants")
`IPRnb(SC             ,0.0        ,"m"                                  ,"Distance between OD-edge and nearest well edge")
`IPRco(NF             ,1.0        ,""         ,1.0         ,inf         ,"Number of fingers")
`IPRcc(NGCON          ,1.0        ,""         ,1.0         ,2.0         ,"Number of gate contacts")
`IPRnb(XGW            ,1.0e-7     ,"m"                                  ,"Distance from the gate contact to the channel edge")
`IPRnb(NRS            ,0.0        ,""                                   ,"Number of squares of source diffusion")
`IPRnb(NRD            ,0.0        ,""                                   ,"Number of squares of drain diffusion")

//  Instance parameters for local model only
`IPRco(JW             ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source/drain junction")

//  Instance parameters for global, binning, and local models
`IPRnb(DELVTO         ,0.0        ,"V"                                  ,"Threshold voltage shift parameter")
`IPRcz(FACTUO         ,1.0        ,""                                   ,"Zero-field mobility pre-factor")
`IPRnb(DELVTOEDGE     ,0.0        ,"V"                                  ,"Threshold voltage shift parameter of edge transistor")
`IPRcz(FACTUOEDGE     ,1.0        ,""                                   ,"Zero-field mobility pre-factor of edge transistor")
`IPRco(ABSOURCE       ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(LSSOURCE       ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of source junction")
`IPRco(LGSOURCE       ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source junction")
`IPRco(ABDRAIN        ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(LSDRAIN        ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of drain junction")
`IPRco(LGDRAIN        ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of drain junction")
`IPRco(AS             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(PS             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of source junction")
`IPRco(AD             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(PD             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of drain junction")
`IPRco(MULT           ,1.0        ,""         ,0.0         ,inf         ,"Number of devices in parallel")
`IPRnb(TRISE          ,0.0        ,"K"                                  ,"Device temperature offset")
aliasparam DTEMP = TRISE;

//  --------------------------------------------------------------------------------------------------------------
//  PSP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "PSP104_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  JUNCAP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "JUNCAP200_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  Variables
//  --------------------------------------------------------------------------------------------------------------

//  Variables for switch (initial_model parts)
integer CHNL_TYPE;
`ifdef NQSmodel
    integer SWNQS_i;
    real r_nqs, vnorm, vnorm_inv;
`endif // NQSmodel

//  Instance local variables
real NF_i, invNF, L_i, W_i, SA_i, SB_i, SD_i, SC_i, XGW_i, JW_i, SCA_i, SCB_i, SCC_i, NGCON_i, MULT_i, FACTUO_i;
real DELVTO_i, FACTUOEDGE_i, DELVTOEDGE_i;

//  Instance local variables for juncap
real ABS_i, LSS_i, LGS_i, ABD_i, LSD_i, LGD_i, jwcorr, jww;

//  Variables of internal global-binning parameters of charge model
real PoParam_i, PlParam_i, PwParam_i, PlwParam_i;
real THESATACO_i, THESATACL_i, THESATACLEXP_i, THESATACW_i, THESATACLW_i, AXACO_i, AXACL_i;
real KVSATAC_i;

//  Variables of local model parameters
real VFB_p, STVFB_p, ST2VFB_p, TOX_p, EPSROX_p, NEFF_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, DPHIB_p, NP_p, CT_p, CTG_p;
real CTB_p, STCT_p, TOXOV_p, TOXOVD_p, NOV_p, NOVD_p, PSCE_p, PSCED_p, PSCEB_p, CF_p, CFD_p, CFB_p, BETN_p, STBET_p;
real MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, THECS_p, STTHECS_p, XCOR_p, STXCOR_p, FETA_p, RS_p, STRS_p;
real RSB_p, RSG_p, THESAT_p, STTHESAT_p, THESATB_p, THESATG_p, THESATT_p, AX_p, ALP_p, ALP1_p, ALP2_p, VP_p, A1_p;
real A2_p, STA2_p, A3_p, A4_p, GCO_p, IGINV_p, IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, GC2OV_p, GC3OV_p, CHIB_p;
real AGIDL_p, AGIDLD_p, BGIDL_p, BGIDLD_p, STBGIDL_p, STBGIDLD_p, CGIDL_p, CGIDLD_p, COX_p, DELVTAC_p, FACNEFFAC_p;
real THESATAC_p, AXAC_p, ALPAC_p, ALP1AC_p, CGOV_p, CGOVD_p, FCGOVACC_p, FCGOVACCD_p, CGOVACCG_p, CGBOV_p, CINR_p;
real CINRD_p, DVFBINR_p, FCINRDEP_p, FCINRACC_p, AXINR_p, CFR_p, CFRD_p, FNT_p, FNTEXC_p, NFA_p, NFB_p, NFC_p, EF_p;
real VFBEDGE_p, STVFBEDGE_p, DPHIBEDGE_p, NEFFEDGE_p, CTEDGE_p, BETNEDGE_p, STBETEDGE_p, PSCEEDGE_p, PSCEBEDGE_p;
real PSCEDEDGE_p, CFEDGE_p, CFDEDGE_p, CFBEDGE_p, FNTEDGE_p, NFAEDGE_p, NFBEDGE_p, NFCEDGE_p, EFEDGE_p, RG_p, RSH_i;
real RSHD_i, RSE_p, RDE_p, RWELL_p, RBULK_p, RJUNS_p, RJUND_p;
`ifdef SelfHeating
    real RTH_p, CTH_p, STRTH_p;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_p;
`endif // NQSmodel

//  Variables of clipped local model parameters
real VFB_i, STVFB_i, ST2VFB_i, STCT_i, TOX_i, EPSROX_i, NEFF_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, DPHIB_i, NP_i, CT_i;
real CTG_i, CTB_i, TOXOV_i, TOXOVD_i, NOV_i, NOVD_i, CF_i, CFD_i, CFB_i, PSCE_i, PSCEB_i, PSCED_i, BETN_i, STBET_i;
real MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, THECS_i, STTHECS_i, XCOR_i, STXCOR_i, FETA_i, RS_i, STRS_i;
real RSB_i, RSG_i, THESAT_i, STTHESAT_i, THESATB_i, THESATG_i, THESATT_i, AX_i, ALP_i, ALP1_i, ALP2_i, VP_i, A1_i;
real A2_i, STA2_i, A3_i, A4_i, GCO_i, IGINV_i, IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, GC2OV_i, GC3OV_i, CHIB_i;
real AGIDL_i, AGIDLD_i, BGIDL_i, BGIDLD_i, STBGIDL_i, STBGIDLD_i, CGIDL_i, CGIDLD_i, COX_i, DELVTAC_i, FACNEFFAC_i;
real THESATAC_i, AXAC_i, ALPAC_i, ALP1AC_i, CGOV_i, CGOVD_i, FCGOVACC_i, FCGOVACCD_i, CGOVACCG_i, CGBOV_i, CINR_i;
real CINRD_i, DVFBINR_i, FCINRDEP_i, FCINRACC_i, AXINR_i, CFR_i, CFRD_i, FNT_i, FNTEXC_i, NFA_i, NFB_i, NFC_i, EF_i;
real VFBEDGE_i, STVFBEDGE_i, DPHIBEDGE_i, NEFFEDGE_i, CTEDGE_i, BETNEDGE_i, STBETEDGE_i, PSCEEDGE_i, PSCEBEDGE_i;
real PSCEDEDGE_i, CFEDGE_i, CFDEDGE_i, CFBEDGE_i, FNTEDGE_i, NFAEDGE_i, NFBEDGE_i, NFCEDGE_i, EFEDGE_i, RG_i, RSE_i;
real RDE_i, RBULK_i, RJUNS_i, RJUND_i, RWELL_i;
`ifdef SelfHeating
    real RTH_i, CTH_i, STRTH_i;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_i;
`endif // NQSmodel

//  Variables for scaling rules
real iL, iW, delLPS, delWOD, LE, WE, iLE, iLE2, iWE, iiWE, iAE, iiAE, LEcv, WEcv, iiWEcv, Lcv, Wcv, iiLcv, iiWcv;
real L_f, L_slif, W_f, XGWE, NSUB0e, NPCKe, LPCKe, AA, BB, NSUB, FBET1e, LP1e, GPE, GWE, tmpx, Lnoi, Lred, WE_edge;
real iWE_edge, iAE_edge, GPE_edge, KVTHOWE, KUOWE;
`ifdef SelfHeating
    real deltaRth;
`endif // SelfHeating

//  Variables for general temperature scaling
real TKR, TKA, rTa, delTa, phita, inv_phita, TKD, TKD_sq, delT, rTn, ln_rTn, inv_phit, Eg, phibFac;

//  JUNCAP2 variables
`include "JUNCAP200_varlist.include"

//  Local parameters after temperature scaling and variables used in self heating effect
real VFB_T, CT_T, CTG_T, BETN_T, MUE_T, THEMU_T, CS_T, THECS_T, XCOR_T, RS_T, BGIDL_T, BGIDLD_T, A2_T, VFBEDGE_T;
real BETNEDGE_T;
`ifdef SelfHeating
    real RTH_T;
`else // SelfHeating
    // in the self heating model, these variables are declared locally in the evaluate block
    real phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2;
    real Sfl_prefac_edge, ntedge;
`endif // SelfHeating

//  Variables for channel temperature scaling (including self heating effect)
real phib_dc, G_0_dc, kp, np, arg2max, qlim2, qb0, dphibq, sqrt_phib_dc, phix_dc, aphi_dc, bphi_dc, phix2, phix1_dc;
real alpha_b, us1, us21, phib_ac, G_0_ac, phix_ac, aphi_ac, bphi_ac, phix1_ac, tf_ct, tf_bet, tf_mue, tf_cs, tf_xcor;
real tf_ther, THER_i, tf_thesat, tf_betedge, phibedge, Gfedge, phixedge, aphiedge, bphiedge, phix2edge, phix1edge;

//  Variables used in instance initializing
real EPSSI, EPSOX, CoxPrime, tox_sq, Cox_over_q, NEFFAC_i, qq, E_eff0, eta_mu, eta_mu1, ar, arac, inv_VP, CoxovPrime;
real CoxovPrime_d, GOV_s, GOV_d, GOV2_s, GOV2_d, dxgb_ov_th, dxgb_ov_s, dxgb_ov_d, SP_OV_eps2_s, SP_OV_a_s;
real SP_OV_delta1_s, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d, inv_CHIB, B_fact, BCH, BOV, BOV_d, GCQ, GCQOV, tf_ig;
real AGIDLs, AGIDLDs, BGIDLs, BGIDLDs, Vinr_max, ainr, fac_exc, ggate, gsource, gdrain, gbulk, gjuns, gjund, gwell;

//  Global variables used in macros
real tme1, tme2;
real inv_GOV, SP_OV_eps, SP_OV_delta, mutau, nu;

//  Variables for bias affectation
real V_gs, V_ds, V_sb, V_db, Vgb, Vdsx, sigVds, Vjun_s, Vjun_d, VgsPrime, VsbPrime, VdbPrime, VgdPrime;

//  Currents contributions
real I_ds, Igsov, Igdov, I_gcs, I_gcd, I_gb, I_gisl, I_gidl, I_dsedge, Iimpact, ijun_s, ijun_d;

//  Charges contributions
real Qs, Qg, Qb, Qd, Qfgs, Qfgd, Qgb_ov, qjun_s, qjun_d;

//  Noise contributions
real mig, CGeff, migid, sqid, c_igid, S_fl, shot_igs, shot_igd, jnoise_s, jnoise_d, Sfledge, sqidedge, rgatenoise;
real rsourcenoise, rdrainnoise, rbulknoise, rjunsnoise, rjundnoise, rwellnoise;

//  Gmin variable
real gmin;

//  --------------------------------------------------------------------------------------------------------------
//  Variables for operating point info
//  --------------------------------------------------------------------------------------------------------------
// Standard OP-output variables
`OPVarDecl

// Local parameters output for PSP-model including self-heating effect
`ifdef SelfHeating
    `OPVarDecl_she
`endif


//  --------------------------------------------------------------------------------------------------------------
//  Analog block with all calculations and contribs
//  --------------------------------------------------------------------------------------------------------------
analog begin

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of bias/instance independent model variables
    //  --------------------------------------------------------------------------------------------------------------
    begin : initial_model

        //  Clipping and rounding of switch parameters
        if (TYPE >= 0) begin
            CHNL_TYPE    = `NMOS;
        end else begin
            CHNL_TYPE    = `PMOS;
        end
        EPSSI        = `EPSO * `EPSRSI;
        `ifdef NQSmodel
            if (SWNQS < 0.5) begin
                SWNQS_i      =  0;
            end else begin
                if (SWNQS < 1.5) begin
                    SWNQS_i      =  1;
                end else begin
                    if (SWNQS < 2.5) begin
                        SWNQS_i      =  2;
                    end else begin
                        if (SWNQS < 4.0) begin
                            SWNQS_i      =  3;
                        end else begin
                            if (SWNQS < 7.0) begin
                                SWNQS_i      =  5;
                            end else begin
                                SWNQS_i      =  9;
                            end
                        end
                    end
                end
            end
            r_nqs        =  1.0e03;
            vnorm        =  10.0;
            vnorm_inv    =  1.0 / vnorm;
        `endif // NQSmodel

        //  Transistor temperature
        TKR          = `KELVINCONVERSION + TR;
        TKA          =  $temperature + DTA + TRISE;
        rTa          =  TKA / TKR;
        delTa        =  TKA - TKR;
        phita        =  TKA * `KBOL / `QELE;
        inv_phita    =  1.0 / phita;
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            TKD          =  TKA;
            `TempInitialize
        `endif // SelfHeating

        // JUNCAP2
        `include "JUNCAP200_InitModel.include"

        //  Gmin definition
        gmin         =  $simparam("gmin",0.0);

        //  Configuration of Op-output variables
        `OPConfig

    end // initial_model

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of instance dependent and bias independent variables
    //  --------------------------------------------------------------------------------------------------------------
    begin : initial_instance

        //  Declaration of local variables
        real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
        real temp, temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

        //  Instance variables
        NF_i         =  1.0;
        invNF        =  1.0;
        LE           =  0.0;
        WE           =  0.0;
        L_i          =  L;
        W_i          =  W;
        SA_i         =  SA;
        SB_i         =  SB;
        SD_i         =  SD;
        SC_i         =  SC;
        XGW_i        =  XGW;
        ABSOURCE_i   =  ABSOURCE;
        LSSOURCE_i   =  LSSOURCE;
        LGSOURCE_i   =  LGSOURCE;
        ABDRAIN_i    =  ABDRAIN;
        LSDRAIN_i    =  LSDRAIN;
        LGDRAIN_i    =  LGDRAIN;
        AS_i         =  AS;
        PS_i         =  PS;
        AD_i         =  AD;
        PD_i         =  PD;
        JW_i         =  JW;

        //  Clipping of the instance parameters
        if (SWGEO > 0) begin
            NF_i         = `CLIP_LOW(NF, 1.0);
            NF_i         =  floor(NF_i + 0.5); // round to nearest integer
            invNF        =  1.0 / NF_i;
        end
        W_i          = `CLIP_LOW(W_i * invNF, 1.0e-09);
        SCA_i        =  SCA;
        SCB_i        =  SCB;
        SCC_i        =  SCC;
        NGCON_i      =  (NGCON < 1.5) ? 1.0 : 2.0;

        //  Internal local parameters
        `include "PSP104_scaling.include"

        //  Local process variables
        EPSOX        = `EPSO * EPSROX_i;
        CoxPrime     =  EPSOX / TOX_i;
        tox_sq       =  TOX_i * TOX_i;
        Cox_over_q   =  CoxPrime / `QELE;
        NEFFAC_i     =  FACNEFFAC_i * NEFF_i;
        NEFFAC_i     = `CLIP_BOTH(NEFFAC_i, 1.0e20, 1.0e26);

        //  QM corrections
        qq           =  0.0;
        if (QMC > 0.0) begin
            qq           =  0.4 * `QMN * QMC * pow(CoxPrime, `twoThirds);
            if (CHNL_TYPE==`PMOS) begin
                qq           = `QMP / `QMN * qq;
            end
        end

        //  Electrical field variables
        E_eff0       =  1.0e-08 * CoxPrime / EPSSI;
        eta_mu       =  0.5 * FETA_i;
        eta_mu1      =  0.5;
        if (CHNL_TYPE == `PMOS) begin
            eta_mu       = `oneThird * FETA_i;
            eta_mu1      = `oneThird;
        end

        //  Linear-saturation transition variable
        temp         =  pow(2.0, (-2.0 / AX_i + 1.0)) - 1.0;
        ar           =  (temp - 1.0) * (temp - 1.0) / `MAX(4.0 * temp, 1.0e-04);
        temp         =  pow(2.0, (-2.0 / AXAC_i + 1.0)) - 1.0;
        arac         =  (temp - 1.0) * (temp - 1.0) / `MAX(4.0 * temp, 1.0e-04);

        //  CLM variable
        inv_VP       =  1.0 / VP_i;

        //  Gate overlap variables
        CoxovPrime   =  EPSOX / TOXOV_i;
        CoxovPrime_d =  EPSOX / TOXOVD_i;
        GOV_s        =  sqrt(2.0 * `QELE * NOV_i * EPSSI * inv_phita) / CoxovPrime;
        GOV_d        =  sqrt(2.0 * `QELE * NOVD_i * EPSSI * inv_phita) / CoxovPrime_d;
        GOV2_s       =  GOV_s * GOV_s;
        GOV2_d       =  GOV_d * GOV_d;
        dxgb_ov_th   =  ln(exp(CGOVACCG_i * 0.005 * inv_phita) - 1.0) / CGOVACCG_i - ln(exp(0.005 * inv_phita) - 1.0);
        dxgb_ov_s    =  ln(0.5 * GOV_s) + dxgb_ov_th;
        dxgb_ov_d    =  ln(0.5 * GOV_d) + dxgb_ov_th;
        `sp_ovInit(GOV_s, GOV2_s, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s)
        `sp_ovInit(GOV_d, GOV2_d, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d)

        //  Temperature scaling variables
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            `TempScaling
        `endif // SelfHeating

        //  Gate to channel leakage variables
        inv_CHIB     =  1.0 / CHIB_i;
        B_fact       =  4.0 * `oneThird * sqrt(2.0 * `QELE * `MELE * CHIB_i) / `HBAR;
        BCH          =  B_fact * TOX_i;
        BOV          =  B_fact * TOXOV_i;
        BOV_d        =  B_fact * TOXOVD_i;
        GCQ          =  0.0;
        if (GC3_i < 0.0) begin
            GCQ          = -0.495 * GC2_i / GC3_i;
        end
        GCQOV        =  GCQ;
        if (SWIGATE == 2) begin
            GCQOV        =  0.0;
            if (GC3OV_i < 0.0) begin
                GCQOV          = -0.495 * GC2OV_i / GC3OV_i;
            end
        end
        tf_ig        =  pow(rTa, STIG_i);
        IGINV_i      =  IGINV_i * tf_ig;
        IGOV_i       =  IGOV_i * tf_ig;
        IGOVD_i      =  IGOVD_i * tf_ig;

        //  GIDL variables
        AGIDLs       =  AGIDL_i * 4.0e-18 / (TOXOV_i * TOXOV_i);
        AGIDLDs      =  AGIDLD_i * 4.0e-18 / (TOXOVD_i * TOXOVD_i);
        B_fact       = `MAX(1.0 + STBGIDL_i * delTa, 0.0);
        BGIDL_T      =  BGIDL_i * B_fact;
        BGIDLs       =  BGIDL_T * TOXOV_i * 5.0e08;
        B_fact       = `MAX(1.0 + STBGIDLD_i * delTa, 0.0);
        BGIDLD_T     =  BGIDLD_i * B_fact;
        BGIDLDs      =  BGIDLD_T * TOXOVD_i * 5.0e8;

        //  Inner fringe charge variables
        Vinr_max     =  0.0;
        if (FCINRACC_i > 1.0e-10) begin
            Vinr_max     =  0.75 / FCINRACC_i;
        end
        ainr         =  AXINR_i * AXINR_i;

        //  Self Heating variables
        `ifdef SelfHeating
            RTH_T        =  RTH_i * pow(rTa, STRTH_i);
        `endif // SelfHeating

        //  Noise model variables
        fac_exc      = `MELE * 1.0e09 * FNTEXC_i;

        //  Conductance of parasitic resistances
        if (RG_i > 0.0) begin
            ggate        =  1.0 / RG_i;
        end else begin
            ggate        =  0.0;
        end
        if (RSE_i > 0.0) begin
            gsource      =  1.0 / RSE_i;
        end else begin
            gsource      =  0.0;
        end
        if (RDE_i > 0.0) begin
            gdrain       =  1.0 / RDE_i;
        end else begin
            gdrain       =  0.0;
        end
        if (RBULK_i > 0.0) begin
            gbulk        =  1.0 / RBULK_i;
        end else begin
            gbulk        =  0.0;
        end
        if (RJUNS_i > 0.0) begin
            gjuns        =  1.0 / RJUNS_i;
        end else begin
            gjuns        =  0.0;
        end
        if (RJUND_i > 0.0) begin
            gjund        =  1.0 / RJUND_i;
        end else begin
            gjund        =  0.0;
        end
        if (RWELL_i > 0.0) begin
            gwell        =  1.0 / RWELL_i;
        end else begin
            gwell        =  0.0;
        end

        //  JUNCAP instance variables
        ABS_i        =  ABSOURCE_i * invNF;
        LSS_i        =  LSSOURCE_i * invNF;
        LGS_i        =  LGSOURCE_i * invNF;
        ABD_i        =  ABDRAIN_i * invNF;
        LSD_i        =  LSDRAIN_i * invNF;
        LGD_i        =  LGDRAIN_i * invNF;
        jwcorr       =  0.0;
        if (SWJUNCAP == 3) begin
            jwcorr       =  1.0;
        end
        jww          =  WE;
        if (SWGEO == 0) begin
            jww          = `CLIP_LOW(JW_i, `LG_cliplow);
        end
        if ((SWJUNCAP == 2) || (SWJUNCAP == 3)) begin
            ABS_i        =  AS_i * invNF;
            LSS_i        =  PS_i * invNF - jwcorr * jww;
            LGS_i        =  jww;
            ABD_i        =  AD_i * invNF;
            LSD_i        =  PD_i * invNF - jwcorr * jww;
            LGD_i        =  jww;
        end
        if ((SWJUNCAP == 1) || (SWJUNCAP == 2) || (SWJUNCAP == 3)) begin
            ABSOURCE_i   = `CLIP_LOW(ABS_i, `AB_cliplow);
            LSSOURCE_i   = `CLIP_LOW(LSS_i, `LS_cliplow);
            LGSOURCE_i   = `CLIP_LOW(LGS_i, `LG_cliplow);
            ABDRAIN_i    = `CLIP_LOW(ABD_i, `AB_cliplow);
            LSDRAIN_i    = `CLIP_LOW(LSD_i, `LS_cliplow);
            LGDRAIN_i    = `CLIP_LOW(LGD_i, `LG_cliplow);
        end else begin
            ABSOURCE_i   =  0.0;
            LSSOURCE_i   =  0.0;
            LGSOURCE_i   =  0.0;
            ABDRAIN_i    =  0.0;
            LSDRAIN_i    =  0.0;
            LGDRAIN_i    =  0.0;
        end

        //  Initialization of JUNCAP (global) variables; required for some verilog-A compilers
        vbimin_s     =  0.0;
        vbimin_d     =  0.0;
        vfmin_s      =  0.0;
        vfmin_d      =  0.0;
        vch_s        =  0.0;
        vch_d        =  0.0;
        vbbtlim_s    =  0.0;
        vbbtlim_d    =  0.0;
        VMAX_s       =  0.0;
        VMAX_d       =  0.0;
        exp_VMAX_over_phitd_s =  0.0;
        exp_VMAX_over_phitd_d =  0.0;
        ISATFOR1_s   =  0.0;
        ISATFOR1_d   =  0.0;
        MFOR1_s      =  1.0;
        MFOR1_d      =  1.0;
        ISATFOR2_s   =  0.0;
        ISATFOR2_d   =  0.0;
        MFOR2_s      =  1.0;
        MFOR2_d      =  1.0;
        ISATREV_s    =  0.0;
        ISATREV_d    =  0.0;
        MREV_s       =  1.0;
        MREV_d       =  1.0;
        m0flag_s     =  0.0;
        m0flag_d     =  0.0;
        xhighf1_s    =  0.0;
        xhighf1_d    =  0.0;
        expxhf1_s    =  0.0;
        expxhf1_d    =  0.0;
        xhighf2_s    =  0.0;
        xhighf2_d    =  0.0;
        expxhf2_s    =  0.0;
        expxhf2_d    =  0.0;
        xhighr_s     =  0.0;
        xhighr_d     =  0.0;
        expxhr_s     =  0.0;
        expxhr_d     =  0.0;
        zflagbot_s   =  1.0;
        zflagbot_d   =  1.0;
        zflagsti_s   =  1.0;
        zflagsti_d   =  1.0;
        zflaggat_s   =  1.0;
        zflaggat_d   =  1.0;
        m0_rev       =  0.0;
        mcor_rev     =  0.0;
        I1_cor       =  0.0;
        I2_cor       =  0.0;
        I3_cor       =  0.0;
        I4_cor       =  0.0;
        I5_cor       =  0.0;
        tt0          =  0.0;
        tt1          =  0.0;
        tt2          =  0.0;
        zfrac        =  0.0;
        alphaje      =  0.0;

        if (SWJUNCAP > 0) begin
            `JuncapInitInstance(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot,   idsatsti,   idsatgat,   vbibot,   vbisti,   vbigat,   PBOT,  PSTI,  PGAT,  VBIRBOT,  VBIRSTI, VBIRGAT,  VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
            `JuncapInitInstance(ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  idsatbot_d, idsatsti_d, idsatgat_d, vbibot_d, vbisti_d, vbigat_d, PBOTD_i, PSTID_i, PGATD_i, VBIRBOTD_i, VBIRSTID_i, VBIRGATD_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)

            if (SWJUNEXP_i == 1) begin : JUNCAPexpressInit
                // Local variable declaration
                `LocalGlobalVars

                real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

                //  Initialization of (local) variables; required for some verilog-A compilers
                `JuncapLocalVarInit

                //  Computation of JUNCAP-express internal variables for source side
                `JuncapExpressInit1(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VJUNREF, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit2(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit3(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot, idsatsti, idsatgat, ISATFOR1_s, MFOR1_s, ISATFOR2_s, MFOR2_s, ISATREV_s, MREV_s, m0flag_s)
                `JuncapExpressInit4(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, FJUNQ, cjobot, cjosti, cjogat, zflagbot_s, zflagsti_s, zflaggat_s)
                `JuncapExpressInit5(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, ISATFOR2_s, ISATREV_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s)

                //  Computation of JUNCAP-express internal variables for drain side
                `JuncapExpressInit1(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VJUNREFD_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit2(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit3(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, idsatbot_d, idsatsti_d, idsatgat_d, ISATFOR1_d, MFOR1_d, ISATFOR2_d, MFOR2_d, ISATREV_d, MREV_d, m0flag_d)
                `JuncapExpressInit4(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, FJUNQD_i, cjobot_d, cjosti_d, cjogat_d, zflagbot_d, zflagsti_d, zflaggat_d)
                `JuncapExpressInit5(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, ISATFOR2_d, ISATREV_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d)
            end // JUNCAPexpressInit

        end

    end // initial_instance

    begin : evaluateblock

        // Declaration of variables
        real xgs_ov, xgd_ov, xgb_ov, Vsbstar_dc_tmp, Vgb1_dc, Vsbx_dc, phit1_dc, inv_phit1_dc, Gf_dc, Gf2_dc, inv_Gf2_dc;
        real xg_dc, xno_s_dc, xn_s_dc, xi_dc, margin_dc, inv_xi_dc, SP_S_x1_dc, delta_ns_dc, x_s_dc, xi1s_dc;
        real xi2s_dc, delta_1s_dc, Es_dc, Ps_dc, Ds_dc, sqs_dc, alphas_dc, Rxcor_dc, xgs_dc, qis_dc, qbs_dc, rhob_dc, rhog_dc;
        real Gmobs_dc, xitsb_dc, factheta_dc, Vdsat_lim_dc, Vdsat_dc, Vdse_dc, Udse_dc, x_ds_dc, dps_dc, qbd_dc, x_m_dc, eta_p_dc;
        real alpha_dc, qim_dc, qim1_dc, qbm_dc, qeff1_dc, Gmob_dc, thesateff_dc, s1_dc, Voxm_dc, GdL_dc, Gmob_dL_dc, thesat1_dc, Gvsatinv_dc, H_dc;
        real Vovs, Vovd, xgedge, qdseffedge, qmeffedge, dsqredge;
        real alphabmedge, mavl, Vsbstar_ac, Vgb1_ac, phit1_ac, Gf_ac, xg_ac, xno_s_ac, qbs_ac, dps_ac, qbd_ac, eta_p_ac, alpha_ac, qim_ac, qim1_ac, qeff1_ac;
        real Gmob_ac, s1_ac, thesateff_ac, Voxm_ac, COX_qm, GdL_ac, Gmob_dL_ac, thesat1_ac, Gvsat_ac, H_ac, Qgs_ov, Qgd_ov;
        real ijunbot_s, ijunsti_s, ijungat_s, ijunbot_d, ijunsti_d, ijungat_d, qjunbot_s, qjunsti_s, qjungat_s, qjunbot_d;
        real qjunsti_d, qjungat_d, shot_igcsx, shot_igcdx, shot_igsov, shot_igdov, shot_iavl, jnoisex_s, jnoisex_d;
        `ifdef NQSmodel
            real xgm_dc, inv_phit1_ac, margin_ac, x_m_ac, xgm_ac, ym, pd, Gp, Gp2, a_factrp, marginp;
            real Qp1_0, Qp2_0, Qp3_0, Qp4_0, Qp5_0, Qp6_0, Qp7_0, Qp8_0, Qp9_0, fk1, fk2, fk3, fk4, fk5, fk6, fk7, fk8, fk9;
            real phi_p1, phi_p2, phi_p3, phi_p4, phi_p5, phi_p6, phi_p7, phi_p8, phi_p9, Qp1, Qp2, Qp3, Qp4, Qp5, Qp6, Qp7;
            real Qp8, Qp9, Qp0, QpN, QG_NQS, QS_NQS, QD_NQS, x_sp, x_dp, zsat_nqs, dfQi, fQi, dQis, dQis_1, d2Qis, dQbs, dQy;
            real d2Qy, dpsy2, Tnorm, Qb_tmp, QbSIGN, NQS_xg1, NQS_yg, NQS_z, NQS_eta, NQS_a, NQS_c, NQS_tau, NQS_D0, NQS_xi;
            real NQS_p, NQS_q, NQS_temp, NQS_A_fac, NQS_xbar, NQS_w, NQS_x0, NQS_u, NQS_y0, xphi, fk0, thesat2, Fvsat, temp3;
            real temp4, temp5, temp6, temp7, temp8, temp9;
        `endif // NQSmodel
        `ifdef SelfHeating
            real Pdiss, phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2;
            real Sfl_prefac_edge, ntedge;
        `endif // SelfHeating
        real temp, temp1, temp2;


        //  --------------------------------------------------------------------------------------------------------------
        //  DC bias dependent quantities (calculations for current contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStatic

            //  Declaration of local variables
            real Vsbstar_dc, Vmb, us, usnew, Vmbnew, dL, s2, zsat, Gvsat, alpha1, SP_OV_xg, xs_ov, xd_ov, zg, TP, Fs1, Fs2, Fs3, Fs, Vm, Dch, arg2mina;
            real psi_t, arg1, Dsi, Dgate, Igc0, u0, x, u0_div_H, Bg, Ag, xsq, igc, igcd_h, inv_x, ex, inv_ex, Sg, Igc;
            real Vtovd, Vtovs, Vsbstaredge, Vsbxedge, dphit1edge, phit1edge, inv_phit1edge, Vdspedge, delVgedge, xbedge;
            real dxthedge, xnedge_s, qseffedge, xnedge_d, qdeffedge, delVsat;
            real Q_EDGE_xsth, Q_EDGE_xth0, Q_EDGE_xth, Q_EDGE_n, Q_EDGE_n_inv, Q_EDGE_xgt, Q_EDGE_xgt0, Q_EDGE_xgt0e;
            real Q_EDGE_qi0si, Q_EDGE_qi0, Q_EDGE_exp_x, Q_EDGE_d0, Q_EDGE_d0p, Q_EDGE_sqerr, Q_EDGE_errq;

            //  Initialize temporary variables
            temp         =  0.0;
            temp1        =  0.0;
            temp2        =  0.0;

            //  Initialization of variables for SHE effect
            `ifdef SelfHeating
                TKD          =  TKA + Temp(br_rth);
                `TempInitialize
                `TempScaling
            `endif // SelfHeating

            //  Initialization of variables for NQS model
            `ifdef NQSmodel
                pd           =  1.0;
                ym           =  0.0;
            `endif // NQSmodel

            //  Voltage affectations
            if (CHNL_TYPE == `NMOS) begin
                V_gs         =  V(gp, si);
                V_ds         =  V(di, si);
                V_sb         =  V(si, bp);
                Vjun_s       = -V(si, bs);
                Vjun_d       = -V(di, bd);
            end else begin
                V_gs         = -V(gp, si);
                V_ds         = -V(di, si);
                V_sb         = -V(si, bp);
                Vjun_s       =  V(si, bs);
                Vjun_d       =  V(di, bd);
            end
            Vgb          =  V_gs + V_sb;

            //  Voltages NOT subject to S/D-interchange
            VgsPrime     =  V_gs;
            VsbPrime     =  V_sb;
            VdbPrime     =  V_ds + V_sb;
            VgdPrime     =  V_gs - V_ds;

            //  Voltages for overlaps
            xgs_ov       = -VgsPrime * inv_phita;
            xgd_ov       = -VgdPrime * inv_phita;
            xgb_ov       = -(Vgb - VFB_T) * inv_phita;

            //  Source-drain interchange
            sigVds       =  1.0;
            if (V_ds < 0.0) begin
                sigVds       = -1.0;
                V_gs         =  V_gs - V_ds;
                V_sb         =  V_sb + V_ds;
                V_ds         = -V_ds;
            end
            V_db         =  V_ds + V_sb;
            Vdsx         =  V_ds * V_ds / (sqrt(V_ds * V_ds + 0.01) + 0.1);

            //  Core's model calculation for DC
            begin : SPcalc_dc

                //  Local variable declaration
                `SPcalcLocalVarDecl

                //  Conditioning of terminal voltages
                temp         = `MINA(V_db, V_sb, bphi_dc) + phix_dc;
                Vsbstar_dc   =  V_sb - `MINA(temp, 0, aphi_dc) + phix1_dc;
                Vsbstar_dc_tmp = Vsbstar_dc;

                //  Adapt Vsb for NUD-effect
                if ((SWNUD != 0) && (GFACNUD_i != 1.0)) begin
                    Vmb          =  Vsbstar_dc + 0.5 * (V_ds - Vdsx);
                    us           =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                    temp         =  2.0 * (us - us1) / us21 - 1.0;
                    usnew        =  us - 0.25 * (1.0 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                    Vmbnew       =  usnew * usnew + (2.0 * sqrt_phib_dc) * usnew;
                    Vsbstar_dc   =  Vmbnew - 0.5 * (V_ds - Vdsx);
                end

                //  Set variables needed in PSP_core macro
                phib         =  phib_dc;
                G_0          =  G_0_dc;
                Vsbstar      =  Vsbstar_dc;
                thesatloc    =  THESAT_T;
                arloc        =  ar;

                //  Calculation of PSP model's core
                `SPCalculation_s
                Vgb1_dc      =  Vgb1;
                Vsbx_dc      =  Vsbx;
                phit1_dc     =  phit1;
                inv_phit1_dc =  inv_phit1;
                Gf_dc        =  Gf;
                Gf2_dc       =  Gf2;
                inv_Gf2_dc   =  inv_Gf2;
                xg_dc        =  xg;
                xno_s_dc     =  xno_s;
                xn_s_dc      =  xn_s;
                xi_dc        =  xi;
                margin_dc    =  margin;
                inv_xi_dc    =  inv_xi;
                SP_S_x1_dc   =  SP_S_x1;
                delta_ns_dc  =  delta_ns;
                x_s_dc       =  x_s;
                xi1s_dc      =  xi1s;
                xi2s_dc      =  xi2s;
                delta_1s_dc  =  delta_1s;
                Es_dc        =  Es;
                Ps_dc        =  Ps;
                Ds_dc        =  Ds;
                sqs_dc       =  sqs;
                alphas_dc    =  alphas;
                Rxcor_dc     =  Rxcor;
                xgs_dc       =  xgs;
                qis_dc       =  qis;
                qbs_dc       =  qbs;
                rhob_dc      =  rhob;
                rhog_dc      =  rhog;
                Gmobs_dc     =  Gmobs;
                xitsb_dc     =  xitsb;
                factheta_dc  =  factheta;

                `SPCalculation_d
                Vdsat_lim_dc =  Vdsat_lim;
                Vdsat_dc     =  V_dsat;
                Vdse_dc      =  Vdse;
                Udse_dc      =  Udse;
                x_ds_dc      =  x_ds;
                dps_dc       =  dps;
                x_m_dc       =  x_m;
                qbd_dc       =  qbd;
                eta_p_dc     =  eta_p;
                alpha_dc     =  alpha;
                qim_dc       =  qim;
                qim1_dc      =  qim1;
                qbm_dc       =  qbm;
                qeff1_dc     =  qeff1;
                Gmob_dc      =  Gmob;
                s1_dc        =  s1;
                thesateff_dc =  thesateff;
                Voxm_dc      =  Voxm;
                `ifdef NQSmodel
                    xgm_dc       =  xgm;
                `endif // NQSmodel

                //  Threshold voltage calculation for .OP
                `OPVThvarCalc
                vtho_i       =  vtho_op;
                vth_i        =  vth_op;

            end // SPcalc_dc

            GdL_dc       =  1.0;
            Gmob_dL_dc   =  1.0;
            Gvsatinv_dc  =  1.0;
            H_dc         =  1.0;
            I_ds         =  0.0;
            if (xg_dc > 0.0) begin
                // Channel length modulation
                s2           =  ln(1.0 + Vdsx * inv_VP);
                temp         =  phit1_dc * alpha_dc / qim1_dc;
                dL           =  (ALP_i + ALP1_i / qim1_dc) * qim_dc / qim1_dc * s1_dc + ALP2_i * qbm_dc * temp * temp * s2;
                GdL_dc       =  1.0 / (1.0 + dL + dL * dL);
                // Velocity saturation
                Gmob_dL_dc   =  Gmob_dc * GdL_dc;
                thesat1_dc   =  thesateff_dc / Gmob_dL_dc;
                zsat         =  thesat1_dc * thesat1_dc * dps_dc * dps_dc;
                if (CHNL_TYPE == `PMOS) begin
                    zsat         =  zsat / (1.0 + thesat1_dc * dps_dc);
                end
                Gvsat        =  0.5 * (Gmob_dL_dc * (1.0 + sqrt(1.0 + 2.0 * zsat)));
                Gvsatinv_dc  =  1.0 / Gvsat;
                // Variables for calculation of gate to channel current and thermal channel noise
                temp         =  Gmob_dL_dc * Gvsatinv_dc;
                alpha1       =  alpha_dc * (1.0 + 0.5 * (zsat * temp * temp));
                H_dc         =  temp * qim1_dc / alpha1;
                //  Drain-source current
                I_ds         =  BET_i * qim1_dc * dps_dc * Gvsatinv_dc;
            end

            //  Surface potential in gate overlap regions
            xs_ov        =  0.0;
            xd_ov        =  0.0;
            Vovs         =  0.0;
            Vovd         =  0.0;
            if (((SWIGATE != 0) && ((IGOV_i > 0.0) || (IGOVD_i > 0.0))) || ((SWGIDL != 0) && ((AGIDL_i > 0.0) || (AGIDLD_i > 0.0))) || (CGOV_i > 0.0) || (CGOVD_i > 0.0)) begin
                SP_OV_xg     = 0.5 * (xgs_ov + sqrt(xgs_ov * xgs_ov + SP_OV_eps2_s));
                xs_ov        = -SP_OV_xg - GOV2_s * 0.5 + GOV_s * sqrt(SP_OV_xg + GOV2_s * 0.25 + SP_OV_a_s) + SP_OV_delta1_s;
                SP_OV_xg     = 0.5 * (xgd_ov + sqrt(xgd_ov * xgd_ov + SP_OV_eps2_d));
                xd_ov        = -SP_OV_xg - GOV2_d * 0.5 + GOV_d * sqrt(SP_OV_xg + GOV2_d * 0.25 + SP_OV_a_d) + SP_OV_delta1_d;
                Vovs         = -phita * (xgs_ov + xs_ov);
                Vovd         = -phita * (xgd_ov + xd_ov);
            end

            //  Gate current
            Igsov        =  0.0;
            Igdov        =  0.0;
            Igc          =  0.0;
            I_gb         =  0.0;
            I_gcs        =  0.0;
            I_gcd        =  0.0;
            if (SWIGATE != 0) begin
                if (IGOV_i > 0.0) begin
                    //  Gate-source overlap component of gate current
                    zg           =  sqrt(Vovs * Vovs + 1.0e-06) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-06);
                    end
                    temp         =  BOV * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xs_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgsPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igsov        =  IGOV_i * (TP * Fs);
                end

                if (IGOVD_i > 0.0) begin
                    //  Gate-drain overlap component of gate current
                    zg           =  sqrt(Vovd * Vovd + 1.0e-06) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-06);
                    end
                    temp         =  BOV_d * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xd_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgdPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igdov        =  IGOVD_i * (TP * Fs);
                end

                //  Gate-channel component of gate current
                if (IGINV_i > 0.0) begin
                    if (xg_dc <= 0.0) begin
                        temp         =  1.0 + ar;
                        temp1        =  sqrt(temp) * V_ds / Vdsat_lim_dc;
                        temp2        =  temp1 * temp1 + temp;
                        temp         =  2.0 * temp1;
                        Udse_dc      =  Vdsat_lim_dc * inv_phit1_dc * temp / (sqrt(temp2 - temp) + sqrt(temp2 + temp));
                    end
                    `expl_low(x_ds_dc - Udse_dc, temp)
                    Vm           =  Vsbstar_dc + phit1_dc * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));
                    Dch          =  GCO_i * phit1_dc;
                    arg2mina     =  Voxm_dc + Dch;
                    psi_t        = `MINA(0.0, arg2mina, 0.01);
                    zg           =  sqrt(Voxm_dc * Voxm_dc + 1.0e-06) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-06);
                    end
                    arg1         =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1_dc);
                    `expl(arg1,Dsi)
                    arg1         = -(V_gs + Vsbstar_dc - Vm) * inv_phit1_dc;
                    `expl(arg1,temp)
                    Dgate        =  Dsi * temp;
                    temp         =  BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igc0         =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

                    //  Source/drain partitioning of gate-channel current
                    if ((xg_dc <= 0.0) || ((GC2_i == 0.0) && (GC3_i == 0.0))) begin
                        igc          =  1.0;
                        igcd_h       =  0.5;
                    end else begin
                        temp         =  GC2_i + 2.0 * GC3_i * zg;
                        u0           =  CHIB_i / (temp * BCH);
                        x            =  0.5 * (dps_dc / u0);
                        u0_div_H     =  u0 / H_dc;
                        Bg           =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                        Ag           =  0.5 - 3.0 * Bg;
                        if (x < 1.0e-3) begin
                            xsq          =  x * x;
                            igc          =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                            igcd_h       =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                        end else begin
                            inv_x        =  1.0 / x;
                            `expl(x, ex)
                            inv_ex       =  1.0 / ex;
                            temp         =  ex - inv_ex;
                            temp2        =  ex + inv_ex;
                            igc          =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                            igcd_h       =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                        end
                    end
                    Sg           =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-06));
                    Igc          =  Igc0 * igc * Sg;
                    I_gcd        =  Igc0 * igcd_h * Sg;
                    I_gcs        =  Igc - I_gcd;
                    I_gb         =  Igc0 * igc * (1.0 - Sg);
                end // (IGINV >0.0)
            end // (SWIGATE != 0)

            //  GIDL/GISL currents
            I_gidl       =  0.0;
            I_gisl       =  0.0;
            if (SWGIDL != 0) begin
                //  GIDL current computation
                if ((AGIDLD_i > 0.0) && (Vovd < 0.0)) begin
                    Vtovd        =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                    temp         = -BGIDLDs / Vtovd;
                    `expl_low(temp, temp2)
                    I_gidl       = -AGIDLDs * (VdbPrime * Vovd * Vtovd * temp2);
                end

                //  GISL current computation
                if ((AGIDL_i > 0.0) && (Vovs < 0.0)) begin
                    Vtovs        =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-06);
                    temp         = -BGIDLs / Vtovs;
                    `expl_low(temp, temp2)
                    I_gisl       = -AGIDLs * (VsbPrime * Vovs * Vtovs * temp2);
                end
            end // (SWGIDL != 0)

            //  Drain current of edge transistors
            phit1edge    =  phit;
            xgedge       =  0.0;
            qdseffedge   =  0.0;
            qmeffedge    =  0.0;
            dsqredge     =  1.0e-40;
            alphabmedge  =  1.0;
            I_dsedge     =  0.0;
            if ((SWEDGE != 0) && (BETNEDGE_i > 0.0)) begin
                temp         = `MINA(V_db, V_sb, bphiedge) + phixedge;
                Vsbstaredge  =  V_sb - `MINA(temp, 0.0, aphiedge) + phix1edge;
                Vsbxedge     =  Vsbstaredge + 0.5 * (V_ds - Vdsx);
                dphit1edge   =  PSCEEDGE_i * (1.0 + PSCEDEDGE_i * Vdsx)* (1.0 + PSCEBEDGE_i * Vsbxedge); // SCE on subthreshold slope
                phit1edge    =  phit0edge * (1.0 + dphit1edge);
                inv_phit1edge =  1.0 / phit1edge;
                Vdspedge     =  2.0 * Vdsx / (1.0 + sqrt(1.0 + CFDEDGE_i * Vdsx));
                delVgedge    =  CFEDGE_i * Vdspedge * (1.0 + CFBEDGE_i * Vsbxedge); // DIBL effect
                xgedge       =  inv_phit1edge * (Vgb + delVgedge - VFBEDGE_T);
                xbedge       =  inv_phit1edge * phibedge;
                dxthedge     =  2.0 * ln(xbedge / Gfedge + sqrt(xbedge));
                xnedge_s     =  inv_phit1edge * Vsbstaredge;
                `qi_edge(qseffedge,xgedge,xnedge_s)
                xnedge_d     =  inv_phit1edge * (Vdse_dc + Vsbstaredge);
                if ((qseffedge < 1.0e-03) && (Vdse_dc < 1.0e-06)) begin
                    `expl_low((-xnedge_d + xnedge_s), temp)
                    qdseffedge   =  qseffedge * (temp - 1.0);
                    qdeffedge    =  qdseffedge + qseffedge;
                end else begin
                    `qi_edge(qdeffedge,xgedge,xnedge_d)
                    qdseffedge   =  qdeffedge - qseffedge;
                end
                qmeffedge    =  0.5 * (qdeffedge + qseffedge);
                dsqredge     = `MAX(xgedge - qmeffedge, 1.0e-40);
                alphabmedge  =  1.0 - 0.5 * Gfedge / sqrt(dsqredge + 0.25 * Gfedge2);
                I_dsedge     = -BETEDGE_i * phit1edge * phit1edge * (alphabmedge * qmeffedge  + 1.0) * qdseffedge / Gmob_dc;
            end

            //  Impact-Ionization current
            mavl         =  0.0;
            Iimpact      =  0.0;
            if ((xg_dc > 0.0) && (SWIMPACT != 0)) begin
                delVsat      =  V_ds - A3_i * dps_dc;
                if (delVsat > 0.0) begin
                    temp2        =  A2_T * ((1.0 + A4_i * (sqrt(phib_dc + Vsbstar_dc) - sqrt_phib_dc)) / (delVsat + 1.0e-30));
                    `expl(-temp2, temp)
                    mavl         =  A1_i * (delVsat * temp);
                    Iimpact      =  mavl * (I_ds + I_dsedge);
                end
            end

        end // evaluateStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  AC bias dependent quantities (calculations for charge contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateDynamic

            //  Declaration of local variables
            real dL, zsat, alpha1, Fj, Fj2, QG, QCLM, QD, QI, QB, Vginr, Vginreff, fqinr, dVinracc, finracc, xginrdep;
            real finrdep, dVinrdep, finr, dVinr, Vgsinr, Vsginr, Vgdinr, Vdginr, Qginr, Qsinr, Qdinr, yb_ov_s, xgbeff_ov_s;
            real Qg_ov_s, yb_ov_d, xgbeff_ov_d, Qg_ov_d, Qg_ov;

            //  Core's model calculation for AC
            begin : SPcalc_ac

                //  Local variable declaration
                `SPcalcLocalVarDecl

                //  SP calculations
                if ((SWNUD > 0) || (SWDELVTAC > 0) || (SWQSAT > 0)) begin
                    // New calculation of the surface potential at the source side
                    if ((SWNUD > 0) || (SWDELVTAC > 0)) begin
                        phib         =  phib_dc;
                        G_0          =  G_0_dc;
                        Vsbstar      =  Vsbstar_dc_tmp;
                        if (SWDELVTAC > 0) begin
                            //  Conditioning of terminal voltages
                            temp         = `MINA(V_db, V_sb, bphi_ac) + phix_ac;
                            Vsbstar_ac   =  V_sb - `MINA(temp, 0.0, aphi_ac) + phix1_ac;
                            Vsbstar      =  Vsbstar_ac;
                            phib         =  phib_ac;
                            G_0          =  G_0_ac;
                        end
                        `SPCalculation_s
                        //  Threshold voltage calculation for .OP
                        `OPVThvarCalc
                        vthac_i      =  vth_op;
                    end else begin
                        Vgb1         =  Vgb1_dc;
                        Vsbx         =  Vsbx_dc;
                        phit1        =  phit1_dc;
                        inv_phit1    =  inv_phit1_dc;
                        Gf           =  Gf_dc;
                        Gf2          =  Gf2_dc;
                        inv_Gf2      =  inv_Gf2_dc;
                        xg           =  xg_dc;
                        xno_s        =  xno_s_dc;
                        xn_s         =  xn_s_dc;
                        xi           =  xi_dc;
                        margin       =  margin_dc;
                        inv_xi       =  inv_xi_dc;
                        SP_S_x1      =  SP_S_x1_dc;
                        delta_ns     =  delta_ns_dc;
                        x_s          =  x_s_dc;
                        xi1s         =  xi1s_dc;
                        xi2s         =  xi2s_dc;
                        delta_1s     =  delta_1s_dc;
                        Es           =  Es_dc;
                        Ps           =  Ps_dc;
                        Ds           =  Ds_dc;
                        sqs          =  sqs_dc;
                        alphas       =  alphas_dc;
                        Rxcor        =  Rxcor_dc;
                        xgs          =  xgs_dc;
                        qis          =  qis_dc;
                        qbs          =  qbs_dc;
                        rhob         =  rhob_dc;
                        rhog         =  rhog_dc;
                        Gmobs        =  Gmobs_dc;
                        xitsb        =  xitsb_dc;
                        factheta     =  factheta_dc;
                        //  Threshold voltage calculation for .OP
                        vthac_i      =  vth_i;
                    end

                    // New calculation of the surface potential at the drain side
                    thesatloc    =  THESAT_T;
                    arloc        =  ar;
                    if (SWQSAT != 0) begin
                        thesatloc    =  THESATAC_T;
                        arloc        =  arac;
                    end
                    `SPCalculation_d
                    Vgb1_ac      =  Vgb1;
                    phit1_ac     =  phit1;
                    Gf_ac        =  Gf;
                    xg_ac        =  xg;
                    xno_s_ac     =  xno_s;
                    qbs_ac       =  qbs;
                    dps_ac       =  dps;
                    qbd_ac       =  qbd;
                    eta_p_ac     =  eta_p;
                    alpha_ac     =  alpha;
                    qim_ac       =  qim;
                    qim1_ac      =  qim1;
                    qeff1_ac     =  qeff1;
                    Gmob_ac      =  Gmob;
                    s1_ac        =  s1;
                    thesateff_ac =  thesateff;
                    Voxm_ac      =  Voxm;
                    `ifdef NQSmodel
                        inv_phit1_ac =  inv_phit1;
                        margin_ac    =  margin;
                        x_m_ac       =  x_m;
                        xgm_ac       =  xgm;
                    `endif // NQSmodel
                end else begin
                    phib_ac      =  phib_dc;
                    Vgb1_ac      =  Vgb1_dc;
                    phit1_ac     =  phit1_dc;
                    Gf_ac        =  Gf_dc;
                    xg_ac        =  xg_dc;
                    xno_s_ac     =  xno_s_dc;
                    qbs_ac       =  qbs_dc;
                    dps_ac       =  dps_dc;
                    qbd_ac       =  qbd_dc;
                    eta_p_ac     =  eta_p_dc;
                    alpha_ac     =  alpha_dc;
                    qim_ac       =  qim_dc;
                    qim1_ac      =  qim1_dc;
                    qeff1_ac     =  qeff1_dc;
                    Gmob_ac      =  Gmob_dc;
                    s1_ac        =  s1_dc;
                    thesateff_ac =  thesateff_dc;
                    Voxm_ac      =  Voxm_dc;
                    `ifdef NQSmodel
                        inv_phit1_ac =  inv_phit1_dc;
                        margin_ac    =  margin_dc;
                        x_m_ac       =  x_m_dc;
                        xgm_ac       =  xgm_dc;
                    `endif // NQSmodel
                    //  Threshold voltage calculation for .OP
                    vthac_i      =  vth_i;
                end
            end // SPcalc_ac

            //  Quantum mechanical corrections
            COX_qm       =  COX_i;
            if (qq > 0.0) begin
                COX_qm       =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
            end

            //  Intrinsic charge model
            GdL_ac       =  1.0;
            Gmob_dL_ac   =  1.0;
            thesat1_ac   =  0.0;
            Gvsat_ac     =  1.0;
            H_ac         =  1.0;
            QG           =  Voxm_ac;
            QI           =  0.0;
            QD           =  0.0;
            QB           =  QG;
            if (xg_ac > 0.0) begin
                // Channel length modulation
                dL           =  (ALPAC_i + ALP1AC_i / qim1_ac) * qim_ac / qim1_ac * s1_ac;
                if (dL > 0.0) begin
                    GdL_ac       =  1.0 / (1.0 + dL + dL * dL);
                end else begin
                    GdL_ac       =  1.0 - dL;
                end
                // Velocity saturation
                Gmob_dL_ac   =  Gmob_ac * GdL_ac;
                thesat1_ac   =  thesateff_ac / Gmob_dL_ac;
                zsat         =  thesat1_ac * thesat1_ac * dps_ac * dps_ac;
                if (CHNL_TYPE == `PMOS) begin
                    zsat         =  zsat / (1.0 + thesat1_ac * dps_ac);
                end
                Gvsat_ac     =  0.5 * (Gmob_dL_ac * (1.0 + sqrt(1.0 + 2.0 * zsat)));
                // Intrinsic charges
                temp         =  Gmob_dL_ac / Gvsat_ac;
                alpha1       =  alpha_ac * (1.0 + 0.5 * (zsat * temp * temp));
                H_ac         =  temp * qim1_ac / alpha1;
                Fj           =  0.5 * (dps_ac / H_ac);
                Fj2          =  Fj * Fj;
                QG           =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                temp         =  alpha_ac * dps_ac * `oneSixth;
                if (SWQPART == 1) begin
                    QCLM         =  0.0;
                    QD           =  0.5 * GdL_ac * GdL_ac * (qim_ac - 3.0 * temp * (2.0 - Fj));
                end else begin
                    QCLM         =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                    QD           =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                end
                QI           =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                QB           =  QG - QI;
            end
            Qg           =  QG * COX_qm;
            Qd           = -QD * COX_qm;
            Qb           = -QB * COX_qm;

            //  Inner fringe charge model
            Qsinr        =  0.0;
            Qdinr        =  0.0;
            Qginr        =  0.0;
            if ((CINR_i > 0.0)||(CINRD_i > 0.0)) begin
                finracc      =  1.0;
                dVinracc     =  Vgb1_ac;
                if (FCINRACC_i > 1.0e-10) begin
                    Vginr        =  Vgb1_ac - DVFBINR_i + Vinr_max;
                    temp         = `MAXA(Vginr, Vinr_max, ainr);
                    temp1        =  temp * (2.0 * temp - Vinr_max - Vginr);
                    temp2        =  Vinr_max / temp;
                    Vginreff     =  Vginr * temp2;
                    fqinr        =  sqrt(1.0 - Vginreff * FCINRACC_i);
                    dVinracc     =  (1.0 - fqinr) / FCINRACC_i + Vginr - Vginreff;
                    finracc      =  (0.5 / fqinr - 1.0) * (temp1 + Vginr * (Vinr_max - temp)) * temp2 / temp1 + 1.0;
                end
                finrdep      =  1.0;
                dVinrdep     =  0.0;
                if (FCINRDEP_i > 0.0) begin
                    temp         =  0.5 * phib_ac + phit1_ac * (1.0 + Gf_ac * `invSqrt2);
                    xginrdep     =  Vgb1_ac / temp;
                    if (abs(xginrdep) < `se05) begin
                        finrdep      =  1.0 / (1.0 + exp(-xginrdep));
                    end else begin
                        if (xginrdep < 0.0) begin
                            finrdep      =  `ke05 / `P3(-`se05 + xginrdep);
                        end
                    end
                    if (xginrdep < `se05) begin
                        temp1        =  ln(1.0 + exp(xginrdep));
                    end else begin
                        temp1        =  xginrdep;
                    end
                    dVinrdep     =  temp * temp1;
                end
                finr         =  FCINRDEP_i * (finrdep - finracc) + finracc;
                dVinr        =  FCINRDEP_i * (dVinrdep - dVinracc) + dVinracc;
                Vgsinr       =  Vgb1_ac - phit1_ac * xno_s_ac - Voxm_ac - 0.5 * dps_ac;
                Vsginr       =  Vgb1_ac - Vgsinr - qbs_ac;
                Vgdinr       =  dps_ac + Vgsinr - V_ds;
                Vdginr       =  Vgb1_ac - Vgdinr - qbd_ac;
                if (sigVds > 0.0) begin
                    Qginr        =  finr * (CINRD_i * Vgdinr + CINR_i * Vgsinr);
                    Qsinr        =  CINR_i * (Vsginr - dVinr);
                    Qdinr        =  CINRD_i * (Vdginr - dVinr);
                end else begin
                    Qginr        =  finr * (CINR_i * Vgdinr + CINRD_i * Vgsinr);
                    Qsinr        =  CINRD_i * (Vsginr - dVinr);
                    Qdinr        =  CINR_i * (Vdginr - dVinr);
                end
                Qg           =  Qg + Qginr;
                Qd           =  Qd + Qdinr;
                Qb           =  Qb - Qginr - Qdinr - Qsinr;
            end

            //  Overlaps charge model
            Qgs_ov       =  CGOV_i * Vovs;
            Qgd_ov       =  CGOVD_i * Vovd;
            Qg_ov_s      =  0.0;
            yb_ov_s      =  0.0;
            if ((CGOV_i > 0.0)&&(FCGOVACC_i > 0.0)) begin
                temp         =  CGOVACCG_i * (0.5 * xgb_ov + dxgb_ov_s);
                if (temp < `se05) begin
                    `expl_low(temp, yb_ov_s)
                    if (yb_ov_s > 1.0e-10) begin
                        xgbeff_ov_s  =  ln(1.0 + yb_ov_s);
                        temp1        =  xgbeff_ov_s * (1.0 - ln(1.0 + xgbeff_ov_s) / (2.0 + xgbeff_ov_s));
                    end else begin
                        xgbeff_ov_s  =  yb_ov_s;
                        temp1        =  2.0 * xgbeff_ov_s / (2.0 + xgbeff_ov_s);
                    end
                end else begin
                    xgbeff_ov_s  =  temp;
                    temp1        =  xgbeff_ov_s * (1.0 - ln(1.0 + xgbeff_ov_s) / (2.0 + xgbeff_ov_s));
                end
                Qg_ov_s      = -2.0 * FCGOVACC_i / CGOVACCG_i * CGOV_i * phita * temp1;
            end
            Qg_ov_d      =  0.0;
            yb_ov_d      =  0.0;
            if ((CGOVD_i > 0.0)&&(FCGOVACCD_i > 0.0)) begin
                temp         =  CGOVACCG_i * (0.5 * xgb_ov + dxgb_ov_d);
                if (temp < `se05) begin
                    `expl_low(temp, yb_ov_d)
                    if (yb_ov_d > 1.0e-10) begin
                        xgbeff_ov_d  =  ln(1.0 + yb_ov_d);
                        temp1        =  xgbeff_ov_d * (1.0 - ln(1.0 + xgbeff_ov_d) / (2.0 + xgbeff_ov_d));
                    end else begin
                        xgbeff_ov_d  =  yb_ov_d;
                        temp1        =  2.0 * xgbeff_ov_d / (2.0 + xgbeff_ov_d);
                    end
                end else begin
                    xgbeff_ov_d  =  temp;
                    temp1        =  xgbeff_ov_d * (1.0 - ln(1.0 + xgbeff_ov_d) / (2.0 + xgbeff_ov_d));
                end
                Qg_ov_d      = -2.0 * FCGOVACCD_i / CGOVACCG_i * CGOVD_i * phita * temp1;
            end
            Qg_ov        =  Qg_ov_s + Qg_ov_d;
            Qgb_ov       =  CGBOV_i * Vgb + Qg_ov;

            //  Outer fringe charges
            Qfgs         =  CFR_i * VgsPrime;
            Qfgd         =  CFRD_i * VgdPrime;

            //  Variables for NQS model
            `ifdef NQSmodel
                Gp           =  0.0;
                Gp2          =  0.0;
                a_factrp     =  0.0;
                marginp      =  0.0;
                if (SWNQS_i != 0) begin
                    if (xg_ac <= 0.0) begin
                        ym           =  0.5;
                        pd           =  1.0;
                        Gp           =  Gf_ac;
                    end else begin
                        ym           =  0.5 * ( 1.0 + 0.25 * (dps_ac / H_ac));
                        pd           =  xgm_ac / (xg_ac - x_m_ac);
                        Gp           =  Gf_ac / pd;
                    end
                    Gp2          =  Gp * Gp;
                    a_factrp     =  1.0 + Gp * `invSqrt2;
                    marginp      =  1.0e-5 * a_factrp;
                end
            `endif // NQSmodel

        end // evaluateDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  JUNCAP2 contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStaticDynamic

            //  Fix: add here variables declaration; required for some verilog-A compilers
            `LocalGlobalVars

            // Fix: initialization of (local) variables; required for some verilog-A compilers
            `JuncapLocalVarInit

            ijun_s       =  0.0;
            ijunbot_s    =  0.0;
            ijunsti_s    =  0.0;
            ijungat_s    =  0.0;
            ijun_d       =  0.0;
            ijunbot_d    =  0.0;
            ijunsti_d    =  0.0;
            ijungat_d    =  0.0;
            qjun_s       =  0.0;
            qjunbot_s    =  0.0;
            qjunsti_s    =  0.0;
            qjungat_s    =  0.0;
            qjun_d       =  0.0;
            qjunbot_d    =  0.0;
            qjunsti_d    =  0.0;
            qjungat_d    =  0.0;
            if (SWJUNCAP > 0) begin
                if (SWJUNEXP_i == 1) begin
                    `JuncapExpressCurrent(Vjun_s, MFOR1_s, ISATFOR1_s, MFOR2_s, ISATFOR2_s, MREV_s, ISATREV_s, m0flag_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s, ijun_s)
                    `JuncapExpressCurrent(Vjun_d, MFOR1_d, ISATFOR1_d, MFOR2_d, ISATFOR2_d, MREV_d, ISATREV_d, m0flag_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d, ijun_d)
                    begin : evaluateDynamic
                        real tmpv, vjv;
                        `JuncapExpressCharge(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot,   qprefsti,   qprefgat,   qpref2bot,   qpref2sti,   qpref2gat,   vbiinvbot,   vbiinvsti,   vbiinvgat,   one_minus_PBOT,   one_minus_PSTI,   one_minus_PGAT,   vfmin_s, vch_s, zflagbot_s, zflagsti_s, zflaggat_s, qjunbot_s, qjunsti_s, qjungat_s)
                        `JuncapExpressCharge(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qprefsti_d, qprefgat_d, qpref2bot_d, qpref2sti_d, qpref2gat_d, vbiinvbot_d, vbiinvsti_d, vbiinvgat_d, one_minus_PBOT_d, one_minus_PSTI_d, one_minus_PGAT_d, vfmin_d, vch_d, zflagbot_d, zflagsti_d, zflaggat_d, qjunbot_d, qjunsti_d, qjungat_d)
                    end
                end else begin
                    `juncapcommon(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT, CTATBOT, vbibot, wdepnulrbot, VBIRBOTinv, PBOT, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT, VBIRBOT, wdepnulrinvbot, fbbtbot, VBRBOT, VBRinvbot, PBRBOT, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI, CTATSTI, vbisti, wdepnulrsti, VBIRSTIinv, PSTI, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI, VBIRSTI, wdepnulrinvsti, fbbtsti, VBRSTI, VBRinvsti, PBRSTI, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT, CTATGAT, vbigat, wdepnulrgat, VBIRGATinv, PGAT, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT, VBIRGAT, wdepnulrinvgat, fbbtgat, VBRGAT, VBRinvgat, PBRGAT, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s, ijunbot_s, qjunbot_s, ijunsti_s, qjunsti_s, ijungat_s, qjungat_s)
                    ijun_s = ABSOURCE_i * ijunbot_s + LSSOURCE_i * ijunsti_s + LGSOURCE_i * ijungat_s;
                    `juncapcommon(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d, ijunbot_d, qjunbot_d, ijunsti_d, qjunsti_d, ijungat_d, qjungat_d)
                    ijun_d = ABDRAIN_i * ijunbot_d + LSDRAIN_i * ijunsti_d + LGDRAIN_i * ijungat_d;
                end
            end

            //  --------------------------------------------------------------------------------------------------------------
            //  NQS and parasitic resistance contribs
            //  --------------------------------------------------------------------------------------------------------------

            //  Set initial conditions for NQS model
            `ifdef NQSmodel
                `InitNQS
            `endif // NQSmodel

            //  Parasitic resistances (including noise)
            rgatenoise   =  nt0 * ggate;
            rsourcenoise =  nt0 * gsource;
            rdrainnoise  =  nt0 * gdrain;
            rbulknoise   =  nt0 * gbulk;
            rjunsnoise   =  nt0 * gjuns;
            rjundnoise   =  nt0 * gjund;
            rwellnoise   =  nt0 * gwell;

        end // evaluateStaticDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Current contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStatic

            //  Convert back for NMOS-PMOS and Source-Drain interchange
            if (sigVds > 0.0) begin
                I(di, bp)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(di, si)    <+  CHNL_TYPE * MULT_i * (I_ds + I_dsedge);
                I(gp, si)    <+  CHNL_TYPE * MULT_i * I_gcs;
                I(gp, di)    <+  CHNL_TYPE * MULT_i * I_gcd;
            end else begin
                I(si, bp)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(si, di)    <+  CHNL_TYPE * MULT_i * (I_ds + I_dsedge);
                I(gp, di)    <+  CHNL_TYPE * MULT_i * I_gcs;
                I(gp, si)    <+  CHNL_TYPE * MULT_i * I_gcd;
            end
            I(gp, bp)    <+  CHNL_TYPE * MULT_i * I_gb;
            I(gp, si)    <+  CHNL_TYPE * MULT_i * Igsov;
            I(gp, di)    <+  CHNL_TYPE * MULT_i * Igdov;
            I(si, bp)    <+  CHNL_TYPE * MULT_i * I_gisl;
            I(di, bp)    <+  CHNL_TYPE * MULT_i * I_gidl;
            I(bs, si)    <+  CHNL_TYPE * MULT_i * ijun_s;
            I(bd, di)    <+  CHNL_TYPE * MULT_i * ijun_d;

            `CollapsableR(ggate,   RG_i,    rgatenoise,   g,  gp, "rgate")
            `CollapsableR(gsource, RSE_i,   rsourcenoise, s,  si, "rsource")
            `CollapsableR(gdrain,  RDE_i,   rdrainnoise,  d,  di, "rdrain")
            `CollapsableR(gbulk,   RBULK_i, rbulknoise,   bp, bi, "rbulk")
            `CollapsableR(gjuns,   RJUNS_i, rjunsnoise,   bs, bi, "rjuns")
            `CollapsableR(gjund,   RJUND_i, rjundnoise,   bd, bi, "rjund")
            `CollapsableR(gwell,   RWELL_i, rwellnoise,   b,  bi, "rwell")

            I(di, bp)    <+  gmin * V(di, bp);
            I(si, bp)    <+  gmin * V(si, bp);

        end // loadStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  ddt() contribs from charges (Note: MULT is handled explicitly)
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStaticDynamic

            //  Implementation of NQS charges
            `ifdef NQSmodel
                `CalcChargesNQS
            `endif // NQSmodel

            //  Implementation of Self heating effect
            `ifdef SelfHeating
                begin : self_heating
                    real Pdiss_s, Pdiss_d;
                    Pdiss        =  0.0;
                    Pdiss_s      =  0.0;
                    Pdiss_d      =  0.0;
                    if (RSE_i > 0.0) begin
                        Pdiss_s      =  gsource * V(s, si) * V(s, si);
                    end
                    if (RDE_i > 0.0) begin
                        Pdiss_d      =  gdrain * V(d, di) * V(d, di);
                    end
                    if (RTH_p > 1.0e-3) begin
                        Pdiss        =  ((I_ds + I_dsedge) * V_ds + Iimpact * (V_ds + V_sb) + Pdiss_s + Pdiss_d);
                    end
                    Pwr(br_ith)  <+ -MULT_i * Pdiss;
                    Pwr(br_rth)  <+  ddt(MULT_i * CTH_i * Temp(br_rth));
                    Pwr(br_rth)  <+  MULT_i * Temp(br_rth) / RTH_T;
                end // self_heating
            `endif // SelfHeating

        end // loadStaticDynamic

        begin : loadDynamic

            //  Local variable
            real temp;

            //  Intrinsic MOSFET charges
            Qs           =  -(Qg + Qb + Qd);

            //  Total outerFringe + overlap for gate-source and gate-drain.
            Qfgs         =  Qfgs + Qgs_ov;
            Qfgd         =  Qfgd + Qgd_ov;

            //  JUNCAP2 charges
            qjun_s       =  ABSOURCE_i * qjunbot_s + LSSOURCE_i * qjunsti_s + LGSOURCE_i * qjungat_s;
            qjun_d       =  ABDRAIN_i * qjunbot_d + LSDRAIN_i * qjunsti_d + LGDRAIN_i * qjungat_d;

            //  Convert back (undo S-D interchange)
            if (sigVds < 0.0) begin
                temp         =  Qd;    // Qd <--> Qs
                Qd           =  Qs;
                Qs           =  temp;
            end

            I(gp, si)    <+  ddt(CHNL_TYPE * MULT_i * Qg);
            I(bp, si)    <+  ddt(CHNL_TYPE * MULT_i * Qb);
            I(di, si)    <+  ddt(CHNL_TYPE * MULT_i * Qd);
            I(gp, si)    <+  ddt(CHNL_TYPE * MULT_i * Qfgs);
            I(gp, di)    <+  ddt(CHNL_TYPE * MULT_i * Qfgd);
            I(gp, bp)    <+  ddt(CHNL_TYPE * MULT_i * Qgb_ov);
            I(bs, si)    <+  ddt(CHNL_TYPE * MULT_i * qjun_s);
            I(bd, di)    <+  ddt(CHNL_TYPE * MULT_i * qjun_d);

        end // loadDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Noise
        //  --------------------------------------------------------------------------------------------------------------
        begin : noise

            //  Declaration of local variables
            real N1, Nm1, Delta_N1, H0, t1, sqt2, t2, r, lc, lcinv2, g_ideal, mid;
            real thesat1_exc, zsat_exc, Gvsat_exc, gfac, Sidexc, migid0, sqig, anoisedge, N1edge, Nm1edge, Delta_N1edge;
            real H0edge, t1edge, sqt2edge, t2edge, redge, lcedge, lcinv2edge, g_idealedge, midedge;

            //  Noise variable calculation
            S_fl         =  0.0;
            Sidexc       =  0.0;
            mid          =  0.0;
            mig          =  1.0e-40;
            migid        =  0.0;
            c_igid       =  0.0;
            CGeff        =  COX_qm * eta_p_ac;
            sqid         =  0.0;
            sqig         =  0.0;
            Sfledge      =  0.0;
            midedge      =  0.0;
            sqidedge     =  0.0;

            //  Channel noise contributions
            if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin
                // Flicker noise
                N1           =  Cox_over_q * alpha_dc * phit;
                Nm1          =  Cox_over_q * qim1_dc;
                Delta_N1     =  Cox_over_q * alpha_dc * dps_dc;
                S_fl         =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                S_fl         =  S_fl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                S_fl         =  Sfl_prefac * I_ds * Gvsatinv_dc * S_fl / N1;
                S_fl         = `CLIP_LOW(S_fl, 0.0);

                //  Thermal channel noise
                H0           =  qim1_dc / alpha_dc;
                t1           =  qim_dc / qim1_dc;
                sqt2         =  0.5 * `oneSixth * (dps_dc / H0);
                t2           =  sqt2 * sqt2;
                r            =  H0 / H_dc - 1.0;
                lc           = `CLIP_LOW(1.0 - 12.0 * (r * t2), 1.0e-20);
                lcinv2       =  1.0 / (lc * lc);
                g_ideal      =  BET_i * qim1_dc * Gvsatinv_dc;
                mid          =  t1 + 12.0 * t2 - 24.0 * ((1.0 + t1) * t2 * r);
                mid          = `CLIP_LOW(mid, 1.0e-40);
                mid          =  g_ideal * lcinv2 * mid;
                if (FNTEXC_i > 0.0) begin
                    //  Recalculate Gvsat, excluding GdL-effect
                    thesat1_exc  =  thesateff_dc / Gmob_dc;
                    zsat_exc     =  thesat1_exc * thesat1_exc * dps_dc * dps_dc;
                    if (CHNL_TYPE == `PMOS) begin
                        zsat_exc     =  zsat_exc / (1.0 + thesat1_exc * dps_dc);
                    end
                    Gvsat_exc    =  0.5 * (Gmob_dc * (1.0 + sqrt(1.0 + 2.0 * zsat_exc)));
                    gfac         =  Gmob_dc / (Gvsat_exc * lc);
                    Sidexc       =  fac_exc * I_ds * Vdse_dc * gfac * gfac;
                    mid          =  mid + Sidexc / nt0;
                end
                sqid         =  sqrt(nt * mid);

                //  Induced gate noise
                if ((SWIGN == 1) && (nt > 0.0)) begin
                    mig          =  t1 / 12.0 - t2 * (t1 + 0.2 - 12.0 * t2) - 1.6 * (t2 * (t1 + 1.0 - 12.0 * t2) * r);
                    mig          = `CLIP_LOW(mig, 1.0e-40);
                    mig          =  lcinv2 / g_ideal * mig;
                    migid0       =  lcinv2 * sqt2 * (1.0 - 12.0 * t2 - (t1 + 19.2 * t2 - 12.0 * (t1 * t2)) * r);
                    CGeff        =  Gvsat_ac * Gvsat_ac * COX_qm * eta_p_ac / (Gmob_dL_ac * Gmob_dL_ac);
                    if (FNTEXC_i > 0.0) begin
                        mig          =  mig + Sidexc * (1.0 + 12.0 * t2) / (12.0 * g_ideal * g_ideal * nt0);
                        migid0       =  migid0 - Sidexc * sqt2 * (1.0 + r) / (g_ideal * nt0);
                    end
                    sqig         =  sqrt(nt / mig);
                    if (sqid <= 0) begin
                        c_igid       =  0.0;
                    end else begin
                        c_igid       =  migid0 * sqig / sqid; // = migid0 / sqrt(mig * mid);
                    end
                    c_igid       = `CLIP_BOTH(c_igid, 0.0, 1.0);
                    migid        =  c_igid * sqid / sqig;
                end
            end

            //  Noise of gate leakage currents
            shot_igcsx   =  2.0 * `QELE * abs(I_gcs);
            shot_igcdx   =  2.0 * `QELE * abs(I_gcd);
            shot_igsov   =  2.0 * `QELE * abs(Igsov);
            shot_igdov   =  2.0 * `QELE * abs(Igdov);

            //  Noise of impact ionization currents
            shot_iavl    =  2.0 * `QELE * ((mavl + 1) * abs(Iimpact));

            //  Noise of junctions (JUNCAP2)
            jnoisex_s    =  2.0 * `QELE * abs(ijun_s);
            jnoisex_d    =  2.0 * `QELE * abs(ijun_d);
            if (sigVds > 0.0) begin
                shot_igs     =  shot_igcsx + shot_igsov;
                shot_igd     =  shot_igcdx + shot_igdov;
                jnoise_s     =  jnoisex_s;
                jnoise_d     =  jnoisex_d + shot_iavl;
            end else begin
                shot_igs     =  shot_igcdx + shot_igsov;
                shot_igd     =  shot_igcsx + shot_igdov;
                jnoise_s     =  jnoisex_s + shot_iavl;
                jnoise_d     =  jnoisex_d;
            end

            //  Noise of edge transistors
            if ((SWEDGE != 0) && (BETNEDGE_i > 0.0) && (xgedge > 0.0)) begin
                // Flicker noise of edge transistor
                temp1        =  4.0 * dsqredge / Gfedge2;
                anoisedge    =  sqrt(temp1 + 1.0) / (sqrt(temp1 + 1.1) - 1.0);
                temp1        =  Cox_over_q * phit;
                N1edge       =  temp1 * anoisedge;
                Nm1edge      =  temp1 * (qmeffedge + anoisedge);
                Delta_N1edge = -temp1 * anoisedge * alphabmedge * qdseffedge;
                Sfledge      =  (NFAEDGE_i - (NFBEDGE_i - NFCEDGE_i * N1edge) * N1edge) * ln((Nm1edge + 0.5 * Delta_N1edge) / (Nm1edge - 0.5 * Delta_N1edge));
                Sfledge      =  Sfledge + (NFBEDGE_i + NFCEDGE_i * (Nm1edge - 2.0 * N1edge)) * Delta_N1edge;
                Sfledge      =  Sfl_prefac_edge * I_dsedge * Gvsatinv_dc * Sfledge / N1edge;
                Sfledge      = `CLIP_LOW(Sfledge, 0.0);

                //  Thermal channel noise of edge transistor
                H0edge       =  phit * (qmeffedge + anoisedge) / anoisedge;
                t1edge       =  phit1_dc / phit * qmeffedge / (qmeffedge + anoisedge);
                sqt2edge     = -0.5 * `oneSixth * phit * alphabmedge * qdseffedge / H0edge;
                t2edge       =  sqt2edge * sqt2edge;
                redge        =  0.0;
                temp1        =  alpha_dc * H_dc;
                if (temp1 > 1.0e-10) begin
                    redge        =  anoisedge * H0edge / temp1 - 1.0;
                end
                lcedge       = `CLIP_LOW(1.0 - 12.0 * (redge * t2edge), 1.0e-20);
                lcinv2edge   =  1.0 / (lcedge * lcedge);
                g_idealedge  =  BETEDGE_i * phit * (qmeffedge + anoisedge) * Gvsatinv_dc;
                midedge      =  t1edge + 12.0 * t2edge - 24.0 * ((1.0 + t1edge) * t2edge * redge);
                midedge      = `CLIP_LOW(midedge, 1.0e-40);
                midedge      =  g_idealedge * lcinv2edge * midedge;
                sqidedge     =  sqrt(ntedge * midedge);
            end

            //  Noise contributions
            I(NOII)      <+  white_noise((nt / mig), "igig");
            I(NOIR)      <+  V(NOIR) / mig;
            I(NOIC)      <+  ddt(CGeff * V(NOIC));
            I(gp,si)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
            I(gp,di)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
            I(di,si)     <+  sigVds * sqrt(MULT_i) * migid * I(NOII);
            I(di,si)     <+  white_noise(MULT_i * sqid * sqid * (1.0 - c_igid * c_igid), "idid");
            I(di,si)     <+  flicker_noise(sigVds * MULT_i * S_fl, EF_i, "flicker");
            I(gp,si)     <+  white_noise(MULT_i * shot_igs, "igs");
            I(gp,di)     <+  white_noise(MULT_i * shot_igd, "igd");
            I(bs,si)     <+  white_noise(MULT_i * jnoise_s, "ibs");
            I(bd,di)     <+  white_noise(MULT_i * jnoise_d, "ibd");
            I(di,si)     <+  flicker_noise(sigVds * MULT_i * Sfledge, EFEDGE_i, "flicker");
            I(di,si)     <+  white_noise(MULT_i * sqidedge * sqidedge, "ididedge");

        end // noise

        //  --------------------------------------------------------------------------------------------------------------
        //  Operating point info
        //  --------------------------------------------------------------------------------------------------------------
        begin : OPinfo

            // Local variables declaration
            `OPLocVarDecl

            // Calculation of variables related to OP-output variables
            `OPVarCalc
            `OPVarCalcRacc
            `OPVarCalcAnalog
            `OPVarSDInter

            // Definition of OP-output variables
            `OPVarDef
            `ifdef SelfHeating
                `OPVarDef_she
            `endif

        end // OPinfo

    end // evaluateblock

end // analogBlock
